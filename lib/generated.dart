// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: com.example.webview_demo.NativeViewFactory
class NativeViewFactory extends jni.JObject {
  @override
  late final jni.JObjType<NativeViewFactory> $type = type;

  NativeViewFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/webview_demo/NativeViewFactory");

  /// The type which includes information such as the signature of this class.
  static const type = $NativeViewFactoryType();
  static final _id_create = _class.instanceMethodId(
    r"create",
    r"(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;",
  );

  /// from: public abstract io.flutter.plugin.platform.PlatformView create(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  PlatformView create(
    jni.JObject context,
    int i,
    jni.JObject object,
  ) {
    return _id_create(this, const $PlatformViewType(), [
      context.reference.pointer,
      jni.JValueInt(i),
      object.reference.pointer
    ]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $NativeViewFactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"create(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;") {
        final $r = _$impls[$p]!.create(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory NativeViewFactory.implement(
    $NativeViewFactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = NativeViewFactory.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.example.webview_demo.NativeViewFactory",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $NativeViewFactoryImpl {
  factory $NativeViewFactoryImpl({
    required PlatformView Function(
            jni.JObject context, int i, jni.JObject object)
        create,
  }) = _$NativeViewFactoryImpl;

  PlatformView create(jni.JObject context, int i, jni.JObject object);
}

class _$NativeViewFactoryImpl implements $NativeViewFactoryImpl {
  _$NativeViewFactoryImpl({
    required PlatformView Function(
            jni.JObject context, int i, jni.JObject object)
        create,
  }) : _create = create;

  final PlatformView Function(jni.JObject context, int i, jni.JObject object)
      _create;

  PlatformView create(jni.JObject context, int i, jni.JObject object) {
    return _create(context, i, object);
  }
}

final class $NativeViewFactoryType extends jni.JObjType<NativeViewFactory> {
  const $NativeViewFactoryType();

  @override
  String get signature => r"Lcom/example/webview_demo/NativeViewFactory;";

  @override
  NativeViewFactory fromReference(jni.JReference reference) =>
      NativeViewFactory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($NativeViewFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NativeViewFactoryType) &&
        other is $NativeViewFactoryType;
  }
}

/// from: com.example.webview_demo.NativeViewFactoryWrapper
class NativeViewFactoryWrapper extends jni.JObject {
  @override
  late final jni.JObjType<NativeViewFactoryWrapper> $type = type;

  NativeViewFactoryWrapper.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/webview_demo/NativeViewFactoryWrapper");

  /// The type which includes information such as the signature of this class.
  static const type = $NativeViewFactoryWrapperType();
  static final _id_new0 = _class.constructorId(
    r"(Lcom/example/webview_demo/NativeViewFactory;)V",
  );

  /// from: public void <init>(com.example.webview_demo.NativeViewFactory nativeViewFactory)
  /// The returned object must be released after use, by calling the [release] method.
  factory NativeViewFactoryWrapper(
    NativeViewFactory nativeViewFactory,
  ) {
    return NativeViewFactoryWrapper.fromReference(
        _id_new0(_class, referenceType, [nativeViewFactory.reference.pointer]));
  }

  static final _id_create = _class.instanceMethodId(
    r"create",
    r"(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;",
  );

  /// from: public io.flutter.plugin.platform.PlatformView create(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  PlatformView create(
    jni.JObject context,
    int i,
    jni.JObject object,
  ) {
    return _id_create(this, const $PlatformViewType(), [
      context.reference.pointer,
      jni.JValueInt(i),
      object.reference.pointer
    ]);
  }
}

final class $NativeViewFactoryWrapperType
    extends jni.JObjType<NativeViewFactoryWrapper> {
  const $NativeViewFactoryWrapperType();

  @override
  String get signature =>
      r"Lcom/example/webview_demo/NativeViewFactoryWrapper;";

  @override
  NativeViewFactoryWrapper fromReference(jni.JReference reference) =>
      NativeViewFactoryWrapper.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($NativeViewFactoryWrapperType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NativeViewFactoryWrapperType) &&
        other is $NativeViewFactoryWrapperType;
  }
}

/// from: com.example.webview_demo.MainActivity$Companion
class MainActivity_Companion extends jni.JObject {
  @override
  late final jni.JObjType<MainActivity_Companion> $type = type;

  MainActivity_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/webview_demo/MainActivity$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $MainActivity_CompanionType();
  static final _id_getTheView = _class.instanceMethodId(
    r"getTheView",
    r"()Ljava/util/HashMap;",
  );

  /// from: public final java.util.HashMap getTheView()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTheView() {
    return _id_getTheView(this, const jni.JObjectType(), []);
  }

  static final _id_setTheView = _class.instanceMethodId(
    r"setTheView",
    r"(Ljava/util/HashMap;)V",
  );

  /// from: public final void setTheView(java.util.HashMap hashMap)
  void setTheView(
    jni.JObject hashMap,
  ) {
    _id_setTheView(this, const jni.jvoidType(), [hashMap.reference.pointer]);
  }

  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory MainActivity_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return MainActivity_Companion.fromReference(_id_new0(
        _class, referenceType, [defaultConstructorMarker.reference.pointer]));
  }
}

final class $MainActivity_CompanionType
    extends jni.JObjType<MainActivity_Companion> {
  const $MainActivity_CompanionType();

  @override
  String get signature => r"Lcom/example/webview_demo/MainActivity$Companion;";

  @override
  MainActivity_Companion fromReference(jni.JReference reference) =>
      MainActivity_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MainActivity_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MainActivity_CompanionType) &&
        other is $MainActivity_CompanionType;
  }
}

/// from: com.example.webview_demo.MainActivity
class MainActivity extends jni.JObject {
  @override
  late final jni.JObjType<MainActivity> $type = type;

  MainActivity.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/webview_demo/MainActivity");

  /// The type which includes information such as the signature of this class.
  static const type = $MainActivityType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lcom/example/webview_demo/MainActivity$Companion;",
  );

  /// from: static public final com.example.webview_demo.MainActivity$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static MainActivity_Companion get Companion =>
      _id_Companion.get(_class, const $MainActivity_CompanionType());

  static final _id_theView = _class.staticFieldId(
    r"theView",
    r"Ljava/util/HashMap;",
  );

  /// from: static public java.util.HashMap theView
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get theView =>
      _id_theView.get(_class, const jni.JObjectType());

  /// from: static public java.util.HashMap theView
  /// The returned object must be released after use, by calling the [release] method.
  static set theView(jni.JObject value) =>
      _id_theView.set(_class, const jni.JObjectType(), value);

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MainActivity() {
    return MainActivity.fromReference(_id_new0(_class, referenceType, []));
  }

  static final _id_configureFlutterEngine = _class.instanceMethodId(
    r"configureFlutterEngine",
    r"(Lio/flutter/embedding/engine/FlutterEngine;)V",
  );

  /// from: public void configureFlutterEngine(io.flutter.embedding.engine.FlutterEngine flutterEngine)
  void configureFlutterEngine(
    FlutterEngine flutterEngine,
  ) {
    _id_configureFlutterEngine(
        this, const jni.jvoidType(), [flutterEngine.reference.pointer]);
  }

  static final _id_getTheView = _class.staticMethodId(
    r"getTheView",
    r"()Ljava/util/HashMap;",
  );

  /// from: static public final java.util.HashMap getTheView()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getTheView() {
    return _id_getTheView(_class, const jni.JObjectType(), []);
  }

  static final _id_setTheView = _class.staticMethodId(
    r"setTheView",
    r"(Ljava/util/HashMap;)V",
  );

  /// from: static public final void setTheView(java.util.HashMap hashMap)
  static void setTheView(
    jni.JObject hashMap,
  ) {
    _id_setTheView(_class, const jni.jvoidType(), [hashMap.reference.pointer]);
  }
}

final class $MainActivityType extends jni.JObjType<MainActivity> {
  const $MainActivityType();

  @override
  String get signature => r"Lcom/example/webview_demo/MainActivity;";

  @override
  MainActivity fromReference(jni.JReference reference) =>
      MainActivity.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MainActivityType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MainActivityType) &&
        other is $MainActivityType;
  }
}

/// from: io.flutter.plugin.platform.PlatformView
///
/// A handle to an Android view to be embedded in the Flutter hierarchy.
class PlatformView extends jni.JObject {
  @override
  late final jni.JObjType<PlatformView> $type = type;

  PlatformView.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"io/flutter/plugin/platform/PlatformView");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewType();
  static final _id_getView = _class.instanceMethodId(
    r"getView",
    r"()Landroid/view/View;",
  );

  /// from: public abstract android.view.View getView()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the Android view to be embedded in the Flutter hierarchy.
  View getView() {
    return _id_getView(this, const $ViewType(), []);
  }

  static final _id_onFlutterViewAttached = _class.instanceMethodId(
    r"onFlutterViewAttached",
    r"(Landroid/view/View;)V",
  );

  /// from: default public void onFlutterViewAttached(android.view.View flutterView)
  ///
  /// Called by the io.flutter.embedding.engine.FlutterEngine that owns this {@code
  /// PlatformView} when the Android View responsible for rendering a Flutter UI is
  /// associated with the io.flutter.embedding.engine.FlutterEngine.
  ///
  /// This means that our associated io.flutter.embedding.engine.FlutterEngine can now
  /// render a UI and interact with the user.
  ///
  /// Some platform views may have unusual dependencies on the View that renders Flutter
  /// UIs, such as unique keyboard interactions. That View is provided here for those
  /// purposes. Use of this View should be avoided if it is not absolutely necessary, because
  /// depending on this View will tend to make platform view code more brittle to future
  /// changes.
  void onFlutterViewAttached(
    View flutterView,
  ) {
    _id_onFlutterViewAttached(
        this, const jni.jvoidType(), [flutterView.reference.pointer]);
  }

  static final _id_onFlutterViewDetached = _class.instanceMethodId(
    r"onFlutterViewDetached",
    r"()V",
  );

  /// from: default public void onFlutterViewDetached()
  ///
  /// Called by the io.flutter.embedding.engine.FlutterEngine that owns this {@code
  /// PlatformView} when the Android View responsible for rendering a Flutter UI is detached
  /// and disassociated from the io.flutter.embedding.engine.FlutterEngine.
  ///
  /// This means that our associated io.flutter.embedding.engine.FlutterEngine no longer
  /// has a rendering surface, or a user interaction surface of any kind.
  ///
  /// This platform view must release any references related to the Android View that was
  /// provided in \#onFlutterViewAttached(View).
  void onFlutterViewDetached() {
    _id_onFlutterViewDetached(this, const jni.jvoidType(), []);
  }

  static final _id_dispose = _class.instanceMethodId(
    r"dispose",
    r"()V",
  );

  /// from: public abstract void dispose()
  ///
  /// Dispose this platform view.
  ///
  /// The PlatformView object is unusable after this method is called.
  ///
  /// Plugins implementing PlatformView must clear all references to the View object and
  /// the PlatformView after this method is called. Failing to do so will result in a memory leak.
  ///
  /// References related to the Android View attached in \#onFlutterViewAttached(View) must be released in {@code dispose()} to avoid memory leaks.
  void dispose() {
    _id_dispose(this, const jni.jvoidType(), []);
  }

  static final _id_onInputConnectionLocked = _class.instanceMethodId(
    r"onInputConnectionLocked",
    r"()V",
  );

  /// from: default public void onInputConnectionLocked()
  ///
  /// Callback fired when the platform's input connection is locked, or should be used.
  ///
  /// This hook only exists for rare cases where the plugin relies on the state of the input
  /// connection. This probably doesn't need to be implemented.
  void onInputConnectionLocked() {
    _id_onInputConnectionLocked(this, const jni.jvoidType(), []);
  }

  static final _id_onInputConnectionUnlocked = _class.instanceMethodId(
    r"onInputConnectionUnlocked",
    r"()V",
  );

  /// from: default public void onInputConnectionUnlocked()
  ///
  /// Callback fired when the platform input connection has been unlocked.
  ///
  /// This hook only exists for rare cases where the plugin relies on the state of the input
  /// connection. This probably doesn't need to be implemented.
  void onInputConnectionUnlocked() {
    _id_onInputConnectionUnlocked(this, const jni.jvoidType(), []);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"getView()Landroid/view/View;") {
        final $r = _$impls[$p]!.getView();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"onFlutterViewAttached(Landroid/view/View;)V") {
        _$impls[$p]!.onFlutterViewAttached(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onFlutterViewDetached()V") {
        _$impls[$p]!.onFlutterViewDetached();
        return jni.nullptr;
      }
      if ($d == r"dispose()V") {
        _$impls[$p]!.dispose();
        return jni.nullptr;
      }
      if ($d == r"onInputConnectionLocked()V") {
        _$impls[$p]!.onInputConnectionLocked();
        return jni.nullptr;
      }
      if ($d == r"onInputConnectionUnlocked()V") {
        _$impls[$p]!.onInputConnectionUnlocked();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformView.implement(
    $PlatformViewImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformView.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.plugin.platform.PlatformView",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $PlatformViewImpl {
  factory $PlatformViewImpl({
    required View Function() getView,
    required void Function(View flutterView) onFlutterViewAttached,
    required void Function() onFlutterViewDetached,
    required void Function() dispose,
    required void Function() onInputConnectionLocked,
    required void Function() onInputConnectionUnlocked,
  }) = _$PlatformViewImpl;

  View getView();
  void onFlutterViewAttached(View flutterView);
  void onFlutterViewDetached();
  void dispose();
  void onInputConnectionLocked();
  void onInputConnectionUnlocked();
}

class _$PlatformViewImpl implements $PlatformViewImpl {
  _$PlatformViewImpl({
    required View Function() getView,
    required void Function(View flutterView) onFlutterViewAttached,
    required void Function() onFlutterViewDetached,
    required void Function() dispose,
    required void Function() onInputConnectionLocked,
    required void Function() onInputConnectionUnlocked,
  })  : _getView = getView,
        _onFlutterViewAttached = onFlutterViewAttached,
        _onFlutterViewDetached = onFlutterViewDetached,
        _dispose = dispose,
        _onInputConnectionLocked = onInputConnectionLocked,
        _onInputConnectionUnlocked = onInputConnectionUnlocked;

  final View Function() _getView;
  final void Function(View flutterView) _onFlutterViewAttached;
  final void Function() _onFlutterViewDetached;
  final void Function() _dispose;
  final void Function() _onInputConnectionLocked;
  final void Function() _onInputConnectionUnlocked;

  View getView() {
    return _getView();
  }

  void onFlutterViewAttached(View flutterView) {
    return _onFlutterViewAttached(flutterView);
  }

  void onFlutterViewDetached() {
    return _onFlutterViewDetached();
  }

  void dispose() {
    return _dispose();
  }

  void onInputConnectionLocked() {
    return _onInputConnectionLocked();
  }

  void onInputConnectionUnlocked() {
    return _onInputConnectionUnlocked();
  }
}

final class $PlatformViewType extends jni.JObjType<PlatformView> {
  const $PlatformViewType();

  @override
  String get signature => r"Lio/flutter/plugin/platform/PlatformView;";

  @override
  PlatformView fromReference(jni.JReference reference) =>
      PlatformView.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewType) &&
        other is $PlatformViewType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized
///
/// Allows to notify when a platform view buffer has been resized.
class PlatformViewsChannel_PlatformViewBufferResized extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewBufferResized>
      $type = type;

  PlatformViewsChannel_PlatformViewBufferResized.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewBufferResizedType();
  static final _id_run = _class.instanceMethodId(
    r"run",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize;)V",
  );

  /// from: public abstract void run(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewBufferSize bufferSize)
  void run(
    PlatformViewsChannel_PlatformViewBufferSize bufferSize,
  ) {
    _id_run(this, const jni.jvoidType(), [bufferSize.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewsChannel_PlatformViewBufferResizedImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"run(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize;)V") {
        _$impls[$p]!.run(
          $a[0].castTo(const $PlatformViewsChannel_PlatformViewBufferSizeType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformViewsChannel_PlatformViewBufferResized.implement(
    $PlatformViewsChannel_PlatformViewBufferResizedImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformViewsChannel_PlatformViewBufferResized.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $PlatformViewsChannel_PlatformViewBufferResizedImpl {
  factory $PlatformViewsChannel_PlatformViewBufferResizedImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewBufferSize bufferSize)
        run,
  }) = _$PlatformViewsChannel_PlatformViewBufferResizedImpl;

  void run(PlatformViewsChannel_PlatformViewBufferSize bufferSize);
}

class _$PlatformViewsChannel_PlatformViewBufferResizedImpl
    implements $PlatformViewsChannel_PlatformViewBufferResizedImpl {
  _$PlatformViewsChannel_PlatformViewBufferResizedImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewBufferSize bufferSize)
        run,
  }) : _run = run;

  final void Function(PlatformViewsChannel_PlatformViewBufferSize bufferSize)
      _run;

  void run(PlatformViewsChannel_PlatformViewBufferSize bufferSize) {
    return _run(bufferSize);
  }
}

final class $PlatformViewsChannel_PlatformViewBufferResizedType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewBufferResized> {
  const $PlatformViewsChannel_PlatformViewBufferResizedType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized;";

  @override
  PlatformViewsChannel_PlatformViewBufferResized fromReference(
          jni.JReference reference) =>
      PlatformViewsChannel_PlatformViewBufferResized.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewBufferResizedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewBufferResizedType) &&
        other is $PlatformViewsChannel_PlatformViewBufferResizedType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize
///
/// The platform view buffer size.
class PlatformViewsChannel_PlatformViewBufferSize extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewBufferSize> $type =
      type;

  PlatformViewsChannel_PlatformViewBufferSize.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewBufferSizeType();
  static final _id_width = _class.instanceFieldId(
    r"width",
    r"I",
  );

  /// from: public final int width
  ///
  /// The width of the screen buffer.
  int get width => _id_width.get(this, const jni.jintType());

  static final _id_height = _class.instanceFieldId(
    r"height",
    r"I",
  );

  /// from: public final int height
  ///
  /// The height of the screen buffer.
  int get height => _id_height.get(this, const jni.jintType());

  static final _id_new0 = _class.constructorId(
    r"(II)V",
  );

  /// from: public void <init>(int width, int height)
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsChannel_PlatformViewBufferSize(
    int width,
    int height,
  ) {
    return PlatformViewsChannel_PlatformViewBufferSize.fromReference(_id_new0(
        _class, referenceType, [jni.JValueInt(width), jni.JValueInt(height)]));
  }
}

final class $PlatformViewsChannel_PlatformViewBufferSizeType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewBufferSize> {
  const $PlatformViewsChannel_PlatformViewBufferSizeType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize;";

  @override
  PlatformViewsChannel_PlatformViewBufferSize fromReference(
          jni.JReference reference) =>
      PlatformViewsChannel_PlatformViewBufferSize.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewBufferSizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewBufferSizeType) &&
        other is $PlatformViewsChannel_PlatformViewBufferSizeType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode
///
/// Platform view display modes that can be requested at creation time.
class PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
    extends jni.JObject {
  @override
  late final jni.JObjType<
          PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode>
      $type = type;

  PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode");

  /// The type which includes information such as the signature of this class.
  static const type =
      $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType();
  static final _id_values = _class.staticMethodId(
    r"values",
    r"()[Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;",
  );

  /// from: static public io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<
          PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode>
      values() {
    return _id_values(
        _class,
        const jni.JArrayType(
            $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType()),
        []);
  }

  static final _id_valueOf = _class.staticMethodId(
    r"valueOf",
    r"(Ljava/lang/String;)Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;",
  );

  /// from: static public io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode valueOf(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  static PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
      valueOf(
    jni.JString name,
  ) {
    return _id_valueOf(
        _class,
        const $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType(),
        [name.reference.pointer]);
  }
}

final class $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType
    extends jni.JObjType<
        PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode> {
  const $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;";

  @override
  PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
      fromReference(jni.JReference reference) =>
          PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
              .fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType)
          .hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType) &&
        other
            is $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest
///
/// Request sent from Flutter to create a new platform view.
class PlatformViewsChannel_PlatformViewCreationRequest extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewCreationRequest>
      $type = type;

  PlatformViewsChannel_PlatformViewCreationRequest.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewCreationRequestType();
  static final _id_viewId = _class.instanceFieldId(
    r"viewId",
    r"I",
  );

  /// from: public final int viewId
  ///
  /// The ID of the platform view as seen by the Flutter side.
  int get viewId => _id_viewId.get(this, const jni.jintType());

  static final _id_viewType = _class.instanceFieldId(
    r"viewType",
    r"Ljava/lang/String;",
  );

  /// from: public final java.lang.String viewType
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The type of Android {@code View} to create for this platform view.
  jni.JString get viewType => _id_viewType.get(this, const jni.JStringType());

  static final _id_logicalWidth = _class.instanceFieldId(
    r"logicalWidth",
    r"D",
  );

  /// from: public final double logicalWidth
  ///
  /// The density independent width to display the platform view.
  double get logicalWidth =>
      _id_logicalWidth.get(this, const jni.jdoubleType());

  static final _id_logicalHeight = _class.instanceFieldId(
    r"logicalHeight",
    r"D",
  );

  /// from: public final double logicalHeight
  ///
  /// The density independent height to display the platform view.
  double get logicalHeight =>
      _id_logicalHeight.get(this, const jni.jdoubleType());

  static final _id_logicalTop = _class.instanceFieldId(
    r"logicalTop",
    r"D",
  );

  /// from: public final double logicalTop
  ///
  /// The density independent top position to display the platform view.
  double get logicalTop => _id_logicalTop.get(this, const jni.jdoubleType());

  static final _id_logicalLeft = _class.instanceFieldId(
    r"logicalLeft",
    r"D",
  );

  /// from: public final double logicalLeft
  ///
  /// The density independent left position to display the platform view.
  double get logicalLeft => _id_logicalLeft.get(this, const jni.jdoubleType());

  static final _id_direction = _class.instanceFieldId(
    r"direction",
    r"I",
  );

  /// from: public final int direction
  ///
  /// The layout direction of the new platform view.
  ///
  /// See android.view.View\#LAYOUT_DIRECTION_LTR and android.view.View\#LAYOUT_DIRECTION_RTL
  int get direction => _id_direction.get(this, const jni.jintType());

  static final _id_displayMode = _class.instanceFieldId(
    r"displayMode",
    r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;",
  );

  /// from: public final io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode displayMode
  /// The returned object must be released after use, by calling the [release] method.
  PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
      get displayMode => _id_displayMode.get(this,
          const $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType());

  static final _id_params = _class.instanceFieldId(
    r"params",
    r"Ljava/nio/ByteBuffer;",
  );

  /// from: public final java.nio.ByteBuffer params
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Custom parameters that are unique to the desired platform view.
  jni.JByteBuffer get params =>
      _id_params.get(this, const jni.JByteBufferType());

  static final _id_new0 = _class.constructorId(
    r"(ILjava/lang/String;DDDDILjava/nio/ByteBuffer;)V",
  );

  /// from: public void <init>(int viewId, java.lang.String viewType, double logicalTop, double logicalLeft, double logicalWidth, double logicalHeight, int direction, java.nio.ByteBuffer params)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a request to construct a platform view.
  factory PlatformViewsChannel_PlatformViewCreationRequest(
    int viewId,
    jni.JString viewType,
    double logicalTop,
    double logicalLeft,
    double logicalWidth,
    double logicalHeight,
    int direction,
    jni.JByteBuffer params,
  ) {
    return PlatformViewsChannel_PlatformViewCreationRequest.fromReference(
        _id_new0(_class, referenceType, [
      jni.JValueInt(viewId),
      viewType.reference.pointer,
      logicalTop,
      logicalLeft,
      logicalWidth,
      logicalHeight,
      jni.JValueInt(direction),
      params.reference.pointer
    ]));
  }

  static final _id_new1 = _class.constructorId(
    r"(ILjava/lang/String;DDDDILio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;Ljava/nio/ByteBuffer;)V",
  );

  /// from: public void <init>(int viewId, java.lang.String viewType, double logicalTop, double logicalLeft, double logicalWidth, double logicalHeight, int direction, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode displayMode, java.nio.ByteBuffer params)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a request to construct a platform view with the given display mode.
  factory PlatformViewsChannel_PlatformViewCreationRequest.new1(
    int viewId,
    jni.JString viewType,
    double logicalTop,
    double logicalLeft,
    double logicalWidth,
    double logicalHeight,
    int direction,
    PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
        displayMode,
    jni.JByteBuffer params,
  ) {
    return PlatformViewsChannel_PlatformViewCreationRequest.fromReference(
        _id_new1(_class, referenceType, [
      jni.JValueInt(viewId),
      viewType.reference.pointer,
      logicalTop,
      logicalLeft,
      logicalWidth,
      logicalHeight,
      jni.JValueInt(direction),
      displayMode.reference.pointer,
      params.reference.pointer
    ]));
  }
}

final class $PlatformViewsChannel_PlatformViewCreationRequestType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewCreationRequest> {
  const $PlatformViewsChannel_PlatformViewCreationRequestType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;";

  @override
  PlatformViewsChannel_PlatformViewCreationRequest fromReference(
          jni.JReference reference) =>
      PlatformViewsChannel_PlatformViewCreationRequest.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewCreationRequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewCreationRequestType) &&
        other is $PlatformViewsChannel_PlatformViewCreationRequestType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewResizeRequest
///
/// Request sent from Flutter to resize a platform view.
class PlatformViewsChannel_PlatformViewResizeRequest extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewResizeRequest>
      $type = type;

  PlatformViewsChannel_PlatformViewResizeRequest.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewResizeRequestType();
  static final _id_viewId = _class.instanceFieldId(
    r"viewId",
    r"I",
  );

  /// from: public final int viewId
  ///
  /// The ID of the platform view as seen by the Flutter side.
  int get viewId => _id_viewId.get(this, const jni.jintType());

  static final _id_newLogicalWidth = _class.instanceFieldId(
    r"newLogicalWidth",
    r"D",
  );

  /// from: public final double newLogicalWidth
  ///
  /// The new density independent width to display the platform view.
  double get newLogicalWidth =>
      _id_newLogicalWidth.get(this, const jni.jdoubleType());

  static final _id_newLogicalHeight = _class.instanceFieldId(
    r"newLogicalHeight",
    r"D",
  );

  /// from: public final double newLogicalHeight
  ///
  /// The new density independent height to display the platform view.
  double get newLogicalHeight =>
      _id_newLogicalHeight.get(this, const jni.jdoubleType());

  static final _id_new0 = _class.constructorId(
    r"(IDD)V",
  );

  /// from: public void <init>(int viewId, double newLogicalWidth, double newLogicalHeight)
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsChannel_PlatformViewResizeRequest(
    int viewId,
    double newLogicalWidth,
    double newLogicalHeight,
  ) {
    return PlatformViewsChannel_PlatformViewResizeRequest.fromReference(
        _id_new0(_class, referenceType,
            [jni.JValueInt(viewId), newLogicalWidth, newLogicalHeight]));
  }
}

final class $PlatformViewsChannel_PlatformViewResizeRequestType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewResizeRequest> {
  const $PlatformViewsChannel_PlatformViewResizeRequestType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest;";

  @override
  PlatformViewsChannel_PlatformViewResizeRequest fromReference(
          jni.JReference reference) =>
      PlatformViewsChannel_PlatformViewResizeRequest.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewResizeRequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewResizeRequestType) &&
        other is $PlatformViewsChannel_PlatformViewResizeRequestType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewTouch
///
/// The state of a touch event in Flutter within a platform view.
class PlatformViewsChannel_PlatformViewTouch extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewTouch> $type = type;

  PlatformViewsChannel_PlatformViewTouch.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewTouchType();
  static final _id_viewId = _class.instanceFieldId(
    r"viewId",
    r"I",
  );

  /// from: public final int viewId
  ///
  /// The ID of the platform view as seen by the Flutter side.
  int get viewId => _id_viewId.get(this, const jni.jintType());

  static final _id_downTime = _class.instanceFieldId(
    r"downTime",
    r"Ljava/lang/Number;",
  );

  /// from: public final java.lang.Number downTime
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The amount of time that the touch has been pressed.
  jni.JNumber get downTime => _id_downTime.get(this, const jni.JNumberType());

  static final _id_eventTime = _class.instanceFieldId(
    r"eventTime",
    r"Ljava/lang/Number;",
  );

  /// from: public final java.lang.Number eventTime
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// TODO(mattcarroll): javadoc
  jni.JNumber get eventTime => _id_eventTime.get(this, const jni.JNumberType());

  static final _id_action = _class.instanceFieldId(
    r"action",
    r"I",
  );

  /// from: public final int action
  int get action => _id_action.get(this, const jni.jintType());

  static final _id_pointerCount = _class.instanceFieldId(
    r"pointerCount",
    r"I",
  );

  /// from: public final int pointerCount
  ///
  /// The number of pointers (e.g, fingers) involved in the touch event.
  int get pointerCount => _id_pointerCount.get(this, const jni.jintType());

  static final _id_rawPointerPropertiesList = _class.instanceFieldId(
    r"rawPointerPropertiesList",
    r"Ljava/lang/Object;",
  );

  /// from: public final java.lang.Object rawPointerPropertiesList
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Properties for each pointer, encoded in a raw format.
  jni.JObject get rawPointerPropertiesList =>
      _id_rawPointerPropertiesList.get(this, const jni.JObjectType());

  static final _id_rawPointerCoords = _class.instanceFieldId(
    r"rawPointerCoords",
    r"Ljava/lang/Object;",
  );

  /// from: public final java.lang.Object rawPointerCoords
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Coordinates for each pointer, encoded in a raw format.
  jni.JObject get rawPointerCoords =>
      _id_rawPointerCoords.get(this, const jni.JObjectType());

  static final _id_metaState = _class.instanceFieldId(
    r"metaState",
    r"I",
  );

  /// from: public final int metaState
  ///
  /// TODO(mattcarroll): javadoc
  int get metaState => _id_metaState.get(this, const jni.jintType());

  static final _id_buttonState = _class.instanceFieldId(
    r"buttonState",
    r"I",
  );

  /// from: public final int buttonState
  ///
  /// TODO(mattcarroll): javadoc
  int get buttonState => _id_buttonState.get(this, const jni.jintType());

  static final _id_xPrecision = _class.instanceFieldId(
    r"xPrecision",
    r"F",
  );

  /// from: public final float xPrecision
  ///
  /// Coordinate precision along the x-axis.
  double get xPrecision => _id_xPrecision.get(this, const jni.jfloatType());

  static final _id_yPrecision = _class.instanceFieldId(
    r"yPrecision",
    r"F",
  );

  /// from: public final float yPrecision
  ///
  /// Coordinate precision along the y-axis.
  double get yPrecision => _id_yPrecision.get(this, const jni.jfloatType());

  static final _id_deviceId = _class.instanceFieldId(
    r"deviceId",
    r"I",
  );

  /// from: public final int deviceId
  ///
  /// TODO(mattcarroll): javadoc
  int get deviceId => _id_deviceId.get(this, const jni.jintType());

  static final _id_edgeFlags = _class.instanceFieldId(
    r"edgeFlags",
    r"I",
  );

  /// from: public final int edgeFlags
  ///
  /// TODO(mattcarroll): javadoc
  int get edgeFlags => _id_edgeFlags.get(this, const jni.jintType());

  static final _id_source = _class.instanceFieldId(
    r"source",
    r"I",
  );

  /// from: public final int source
  ///
  /// TODO(mattcarroll): javadoc
  int get source => _id_source.get(this, const jni.jintType());

  static final _id_flags = _class.instanceFieldId(
    r"flags",
    r"I",
  );

  /// from: public final int flags
  ///
  /// TODO(mattcarroll): javadoc
  int get flags => _id_flags.get(this, const jni.jintType());

  static final _id_motionEventId = _class.instanceFieldId(
    r"motionEventId",
    r"J",
  );

  /// from: public final long motionEventId
  ///
  /// TODO(iskakaushik): javadoc
  int get motionEventId => _id_motionEventId.get(this, const jni.jlongType());

  static final _id_new0 = _class.constructorId(
    r"(ILjava/lang/Number;Ljava/lang/Number;IILjava/lang/Object;Ljava/lang/Object;IIFFIIIIJ)V",
  );

  /// from: public void <init>(int viewId, java.lang.Number downTime, java.lang.Number eventTime, int action, int pointerCount, java.lang.Object rawPointerPropertiesList, java.lang.Object rawPointerCoords, int metaState, int buttonState, float xPrecision, float yPrecision, int deviceId, int edgeFlags, int source, int flags, long motionEventId)
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsChannel_PlatformViewTouch(
    int viewId,
    jni.JNumber downTime,
    jni.JNumber eventTime,
    int action,
    int pointerCount,
    jni.JObject rawPointerPropertiesList,
    jni.JObject rawPointerCoords,
    int metaState,
    int buttonState,
    double xPrecision,
    double yPrecision,
    int deviceId,
    int edgeFlags,
    int source,
    int flags,
    int motionEventId,
  ) {
    return PlatformViewsChannel_PlatformViewTouch.fromReference(
        _id_new0(_class, referenceType, [
      jni.JValueInt(viewId),
      downTime.reference.pointer,
      eventTime.reference.pointer,
      jni.JValueInt(action),
      jni.JValueInt(pointerCount),
      rawPointerPropertiesList.reference.pointer,
      rawPointerCoords.reference.pointer,
      jni.JValueInt(metaState),
      jni.JValueInt(buttonState),
      jni.JValueFloat(xPrecision),
      jni.JValueFloat(yPrecision),
      jni.JValueInt(deviceId),
      jni.JValueInt(edgeFlags),
      jni.JValueInt(source),
      jni.JValueInt(flags),
      motionEventId
    ]));
  }
}

final class $PlatformViewsChannel_PlatformViewTouchType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewTouch> {
  const $PlatformViewsChannel_PlatformViewTouchType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;";

  @override
  PlatformViewsChannel_PlatformViewTouch fromReference(
          jni.JReference reference) =>
      PlatformViewsChannel_PlatformViewTouch.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsChannel_PlatformViewTouchType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewsChannel_PlatformViewTouchType) &&
        other is $PlatformViewsChannel_PlatformViewTouchType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler
///
/// Handler that receives platform view messages sent from Flutter to Android through a given
/// PlatformViewsChannel.
///
/// To register a {@code PlatformViewsHandler} with a PlatformViewsChannel, see PlatformViewsChannel\#setPlatformViewsHandler(PlatformViewsHandler).
class PlatformViewsChannel_PlatformViewsHandler extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewsHandler> $type =
      type;

  PlatformViewsChannel_PlatformViewsHandler.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewsHandler");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewsHandlerType();

  /// from: static public final long NON_TEXTURE_FALLBACK
  static const NON_TEXTURE_FALLBACK = -2;
  static final _id_createForPlatformViewLayer = _class.instanceMethodId(
    r"createForPlatformViewLayer",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)V",
  );

  /// from: public abstract void createForPlatformViewLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request)
  ///
  /// The Flutter application would like to display a new Android {@code View}, i.e., platform
  /// view.
  ///
  /// The Android View is added to the view hierarchy. This view is rendered in the Flutter
  /// framework by a PlatformViewLayer.
  ///@param request The metadata sent from the framework.
  void createForPlatformViewLayer(
    PlatformViewsChannel_PlatformViewCreationRequest request,
  ) {
    _id_createForPlatformViewLayer(
        this, const jni.jvoidType(), [request.reference.pointer]);
  }

  static final _id_createForTextureLayer = _class.instanceMethodId(
    r"createForTextureLayer",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)J",
  );

  /// from: public abstract long createForTextureLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request)
  ///
  /// The Flutter application would like to display a new Android {@code View}, i.e., platform
  /// view.
  ///
  /// The Android View is added to the view hierarchy. This view is rendered in the Flutter
  /// framework by a TextureLayer.
  ///@param request The metadata sent from the framework.
  ///@return The texture ID.
  int createForTextureLayer(
    PlatformViewsChannel_PlatformViewCreationRequest request,
  ) {
    return _id_createForTextureLayer(
        this, const jni.jlongType(), [request.reference.pointer]);
  }

  static final _id_dispose = _class.instanceMethodId(
    r"dispose",
    r"(I)V",
  );

  /// from: public abstract void dispose(int viewId)
  ///
  /// The Flutter application would like to dispose of an existing Android {@code View}.
  void dispose(
    int viewId,
  ) {
    _id_dispose(this, const jni.jvoidType(), [jni.JValueInt(viewId)]);
  }

  static final _id_resize = _class.instanceMethodId(
    r"resize",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest;Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized;)V",
  );

  /// from: public abstract void resize(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewResizeRequest request, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewBufferResized onComplete)
  ///
  /// The Flutter application would like to resize an existing Android {@code View}.
  ///@param request The request to resize the platform view.
  ///@param onComplete Once the resize is completed, this is the handler to notify the size of the
  ///     platform view buffer.
  void resize(
    PlatformViewsChannel_PlatformViewResizeRequest request,
    PlatformViewsChannel_PlatformViewBufferResized onComplete,
  ) {
    _id_resize(this, const jni.jvoidType(),
        [request.reference.pointer, onComplete.reference.pointer]);
  }

  static final _id_offset = _class.instanceMethodId(
    r"offset",
    r"(IDD)V",
  );

  /// from: public abstract void offset(int viewId, double top, double left)
  ///
  /// The Flutter application would like to change the offset of an existing Android {@code View}.
  void offset(
    int viewId,
    double top,
    double left,
  ) {
    _id_offset(this, const jni.jvoidType(), [jni.JValueInt(viewId), top, left]);
  }

  static final _id_onTouch = _class.instanceMethodId(
    r"onTouch",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;)V",
  );

  /// from: public abstract void onTouch(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewTouch touch)
  ///
  /// The user touched a platform view within Flutter.
  ///
  /// Touch data is reported in {@code touch}.
  void onTouch(
    PlatformViewsChannel_PlatformViewTouch touch,
  ) {
    _id_onTouch(this, const jni.jvoidType(), [touch.reference.pointer]);
  }

  static final _id_setDirection = _class.instanceMethodId(
    r"setDirection",
    r"(II)V",
  );

  /// from: public abstract void setDirection(int viewId, int direction)
  ///
  /// The Flutter application would like to change the layout direction of an existing Android
  /// {@code View}, i.e., platform view.
  void setDirection(
    int viewId,
    int direction,
  ) {
    _id_setDirection(this, const jni.jvoidType(),
        [jni.JValueInt(viewId), jni.JValueInt(direction)]);
  }

  static final _id_clearFocus = _class.instanceMethodId(
    r"clearFocus",
    r"(I)V",
  );

  /// from: public abstract void clearFocus(int viewId)
  ///
  /// Clears the focus from the platform view with a give id if it is currently focused.
  void clearFocus(
    int viewId,
  ) {
    _id_clearFocus(this, const jni.jvoidType(), [jni.JValueInt(viewId)]);
  }

  static final _id_synchronizeToNativeViewHierarchy = _class.instanceMethodId(
    r"synchronizeToNativeViewHierarchy",
    r"(Z)V",
  );

  /// from: public abstract void synchronizeToNativeViewHierarchy(boolean yes)
  ///
  /// Whether the render surface of {@code FlutterView} should be converted to a {@code
  /// FlutterImageView} when a {@code PlatformView} is added.
  ///
  /// This is done to syncronize the rendering of the PlatformView and the FlutterView. Defaults
  /// to true.
  void synchronizeToNativeViewHierarchy(
    bool yes,
  ) {
    _id_synchronizeToNativeViewHierarchy(
        this, const jni.jvoidType(), [yes ? 1 : 0]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewsChannel_PlatformViewsHandlerImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"createForPlatformViewLayer(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)V") {
        _$impls[$p]!.createForPlatformViewLayer(
          $a[0].castTo(
              const $PlatformViewsChannel_PlatformViewCreationRequestType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"createForTextureLayer(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)J") {
        final $r = _$impls[$p]!.createForTextureLayer(
          $a[0].castTo(
              const $PlatformViewsChannel_PlatformViewCreationRequestType(),
              releaseOriginal: true),
        );
        return jni.JLong($r).reference.toPointer();
      }
      if ($d == r"dispose(I)V") {
        _$impls[$p]!.dispose(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"resize(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest;Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized;)V") {
        _$impls[$p]!.resize(
          $a[0].castTo(
              const $PlatformViewsChannel_PlatformViewResizeRequestType(),
              releaseOriginal: true),
          $a[1].castTo(
              const $PlatformViewsChannel_PlatformViewBufferResizedType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"offset(IDD)V") {
        _$impls[$p]!.offset(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"onTouch(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;)V") {
        _$impls[$p]!.onTouch(
          $a[0].castTo(const $PlatformViewsChannel_PlatformViewTouchType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"setDirection(II)V") {
        _$impls[$p]!.setDirection(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"clearFocus(I)V") {
        _$impls[$p]!.clearFocus(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"synchronizeToNativeViewHierarchy(Z)V") {
        _$impls[$p]!.synchronizeToNativeViewHierarchy(
          $a[0]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformViewsChannel_PlatformViewsHandler.implement(
    $PlatformViewsChannel_PlatformViewsHandlerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformViewsChannel_PlatformViewsHandler.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $PlatformViewsChannel_PlatformViewsHandlerImpl {
  factory $PlatformViewsChannel_PlatformViewsHandlerImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForPlatformViewLayer,
    required int Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForTextureLayer,
    required void Function(int viewId) dispose,
    required void Function(
            PlatformViewsChannel_PlatformViewResizeRequest request,
            PlatformViewsChannel_PlatformViewBufferResized onComplete)
        resize,
    required void Function(int viewId, double top, double left) offset,
    required void Function(PlatformViewsChannel_PlatformViewTouch touch)
        onTouch,
    required void Function(int viewId, int direction) setDirection,
    required void Function(int viewId) clearFocus,
    required void Function(bool yes) synchronizeToNativeViewHierarchy,
  }) = _$PlatformViewsChannel_PlatformViewsHandlerImpl;

  void createForPlatformViewLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request);
  int createForTextureLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request);
  void dispose(int viewId);
  void resize(PlatformViewsChannel_PlatformViewResizeRequest request,
      PlatformViewsChannel_PlatformViewBufferResized onComplete);
  void offset(int viewId, double top, double left);
  void onTouch(PlatformViewsChannel_PlatformViewTouch touch);
  void setDirection(int viewId, int direction);
  void clearFocus(int viewId);
  void synchronizeToNativeViewHierarchy(bool yes);
}

class _$PlatformViewsChannel_PlatformViewsHandlerImpl
    implements $PlatformViewsChannel_PlatformViewsHandlerImpl {
  _$PlatformViewsChannel_PlatformViewsHandlerImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForPlatformViewLayer,
    required int Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForTextureLayer,
    required void Function(int viewId) dispose,
    required void Function(
            PlatformViewsChannel_PlatformViewResizeRequest request,
            PlatformViewsChannel_PlatformViewBufferResized onComplete)
        resize,
    required void Function(int viewId, double top, double left) offset,
    required void Function(PlatformViewsChannel_PlatformViewTouch touch)
        onTouch,
    required void Function(int viewId, int direction) setDirection,
    required void Function(int viewId) clearFocus,
    required void Function(bool yes) synchronizeToNativeViewHierarchy,
  })  : _createForPlatformViewLayer = createForPlatformViewLayer,
        _createForTextureLayer = createForTextureLayer,
        _dispose = dispose,
        _resize = resize,
        _offset = offset,
        _onTouch = onTouch,
        _setDirection = setDirection,
        _clearFocus = clearFocus,
        _synchronizeToNativeViewHierarchy = synchronizeToNativeViewHierarchy;

  final void Function(PlatformViewsChannel_PlatformViewCreationRequest request)
      _createForPlatformViewLayer;
  final int Function(PlatformViewsChannel_PlatformViewCreationRequest request)
      _createForTextureLayer;
  final void Function(int viewId) _dispose;
  final void Function(PlatformViewsChannel_PlatformViewResizeRequest request,
      PlatformViewsChannel_PlatformViewBufferResized onComplete) _resize;
  final void Function(int viewId, double top, double left) _offset;
  final void Function(PlatformViewsChannel_PlatformViewTouch touch) _onTouch;
  final void Function(int viewId, int direction) _setDirection;
  final void Function(int viewId) _clearFocus;
  final void Function(bool yes) _synchronizeToNativeViewHierarchy;

  void createForPlatformViewLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request) {
    return _createForPlatformViewLayer(request);
  }

  int createForTextureLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request) {
    return _createForTextureLayer(request);
  }

  void dispose(int viewId) {
    return _dispose(viewId);
  }

  void resize(PlatformViewsChannel_PlatformViewResizeRequest request,
      PlatformViewsChannel_PlatformViewBufferResized onComplete) {
    return _resize(request, onComplete);
  }

  void offset(int viewId, double top, double left) {
    return _offset(viewId, top, left);
  }

  void onTouch(PlatformViewsChannel_PlatformViewTouch touch) {
    return _onTouch(touch);
  }

  void setDirection(int viewId, int direction) {
    return _setDirection(viewId, direction);
  }

  void clearFocus(int viewId) {
    return _clearFocus(viewId);
  }

  void synchronizeToNativeViewHierarchy(bool yes) {
    return _synchronizeToNativeViewHierarchy(yes);
  }
}

final class $PlatformViewsChannel_PlatformViewsHandlerType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewsHandler> {
  const $PlatformViewsChannel_PlatformViewsHandlerType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewsHandler;";

  @override
  PlatformViewsChannel_PlatformViewsHandler fromReference(
          jni.JReference reference) =>
      PlatformViewsChannel_PlatformViewsHandler.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsChannel_PlatformViewsHandlerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewsHandlerType) &&
        other is $PlatformViewsChannel_PlatformViewsHandlerType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel
///
/// System channel that sends 2-way communication between Flutter and Android to facilitate embedding
/// of Android Views within a Flutter application.
///
/// Register a PlatformViewsHandler to implement the Android side of this channel.
class PlatformViewsChannel extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel> $type = type;

  PlatformViewsChannel.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannelType();
  static final _id_invokeViewFocused = _class.instanceMethodId(
    r"invokeViewFocused",
    r"(I)V",
  );

  /// from: public void invokeViewFocused(int viewId)
  void invokeViewFocused(
    int viewId,
  ) {
    _id_invokeViewFocused(this, const jni.jvoidType(), [jni.JValueInt(viewId)]);
  }

  static final _id_new0 = _class.constructorId(
    r"(Lio/flutter/embedding/engine/dart/DartExecutor;)V",
  );

  /// from: public void <init>(io.flutter.embedding.engine.dart.DartExecutor dartExecutor)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructs a {@code PlatformViewsChannel} that connects Android to the Dart code running in
  /// {@code dartExecutor}.
  ///
  /// The given {@code dartExecutor} is permitted to be idle or executing code.
  ///
  /// See DartExecutor.
  factory PlatformViewsChannel(
    jni.JObject dartExecutor,
  ) {
    return PlatformViewsChannel.fromReference(
        _id_new0(_class, referenceType, [dartExecutor.reference.pointer]));
  }

  static final _id_setPlatformViewsHandler = _class.instanceMethodId(
    r"setPlatformViewsHandler",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewsHandler;)V",
  );

  /// from: public void setPlatformViewsHandler(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewsHandler handler)
  ///
  /// Sets the PlatformViewsHandler which receives all events and requests that are parsed
  /// from the underlying platform views channel.
  void setPlatformViewsHandler(
    PlatformViewsChannel_PlatformViewsHandler handler,
  ) {
    _id_setPlatformViewsHandler(
        this, const jni.jvoidType(), [handler.reference.pointer]);
  }
}

final class $PlatformViewsChannelType
    extends jni.JObjType<PlatformViewsChannel> {
  const $PlatformViewsChannelType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel;";

  @override
  PlatformViewsChannel fromReference(jni.JReference reference) =>
      PlatformViewsChannel.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsChannelType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewsChannelType) &&
        other is $PlatformViewsChannelType;
  }
}

/// from: io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterAssets
///
/// Provides Flutter plugins with access to Flutter asset information.
class FlutterPlugin_FlutterAssets extends jni.JObject {
  @override
  late final jni.JObjType<FlutterPlugin_FlutterAssets> $type = type;

  FlutterPlugin_FlutterAssets.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterPlugin_FlutterAssetsType();
  static final _id_getAssetFilePathByName = _class.instanceMethodId(
    r"getAssetFilePathByName",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  /// from: public abstract java.lang.String getAssetFilePathByName(java.lang.String assetFileName)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the relative file path to the Flutter asset with the given name, including the file's
  /// extension, e.g., {@code "myImage.jpg"}.
  ///
  /// The returned file path is relative to the Android app's standard assets directory.
  /// Therefore, the returned path is appropriate to pass to Android's {@code AssetManager}, but
  /// the path is not appropriate to load as an absolute path.
  jni.JString getAssetFilePathByName(
    jni.JString assetFileName,
  ) {
    return _id_getAssetFilePathByName(
        this, const jni.JStringType(), [assetFileName.reference.pointer]);
  }

  static final _id_getAssetFilePathByName1 = _class.instanceMethodId(
    r"getAssetFilePathByName",
    r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
  );

  /// from: public abstract java.lang.String getAssetFilePathByName(java.lang.String assetFileName, java.lang.String packageName)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#getAssetFilePathByName(String) but with added support for an explicit
  /// Android {@code packageName}.
  jni.JString getAssetFilePathByName1(
    jni.JString assetFileName,
    jni.JString packageName,
  ) {
    return _id_getAssetFilePathByName1(this, const jni.JStringType(),
        [assetFileName.reference.pointer, packageName.reference.pointer]);
  }

  static final _id_getAssetFilePathBySubpath = _class.instanceMethodId(
    r"getAssetFilePathBySubpath",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  /// from: public abstract java.lang.String getAssetFilePathBySubpath(java.lang.String assetSubpath)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the relative file path to the Flutter asset with the given subpath, including the
  /// file's extension, e.g., {@code "/dir1/dir2/myImage.jpg"}.
  ///
  /// The returned file path is relative to the Android app's standard assets directory.
  /// Therefore, the returned path is appropriate to pass to Android's {@code AssetManager}, but
  /// the path is not appropriate to load as an absolute path.
  jni.JString getAssetFilePathBySubpath(
    jni.JString assetSubpath,
  ) {
    return _id_getAssetFilePathBySubpath(
        this, const jni.JStringType(), [assetSubpath.reference.pointer]);
  }

  static final _id_getAssetFilePathBySubpath1 = _class.instanceMethodId(
    r"getAssetFilePathBySubpath",
    r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
  );

  /// from: public abstract java.lang.String getAssetFilePathBySubpath(java.lang.String assetSubpath, java.lang.String packageName)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#getAssetFilePathBySubpath(String) but with added support for an explicit
  /// Android {@code packageName}.
  jni.JString getAssetFilePathBySubpath1(
    jni.JString assetSubpath,
    jni.JString packageName,
  ) {
    return _id_getAssetFilePathBySubpath1(this, const jni.JStringType(),
        [assetSubpath.reference.pointer, packageName.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FlutterPlugin_FlutterAssetsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"getAssetFilePathByName(Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathByName(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r"getAssetFilePathByName(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathByName1(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r"getAssetFilePathBySubpath(Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathBySubpath(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r"getAssetFilePathBySubpath(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathBySubpath1(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory FlutterPlugin_FlutterAssets.implement(
    $FlutterPlugin_FlutterAssetsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FlutterPlugin_FlutterAssets.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterAssets",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FlutterPlugin_FlutterAssetsImpl {
  factory $FlutterPlugin_FlutterAssetsImpl({
    required jni.JString Function(jni.JString assetFileName)
        getAssetFilePathByName,
    required jni.JString Function(
            jni.JString assetFileName, jni.JString packageName)
        getAssetFilePathByName1,
    required jni.JString Function(jni.JString assetSubpath)
        getAssetFilePathBySubpath,
    required jni.JString Function(
            jni.JString assetSubpath, jni.JString packageName)
        getAssetFilePathBySubpath1,
  }) = _$FlutterPlugin_FlutterAssetsImpl;

  jni.JString getAssetFilePathByName(jni.JString assetFileName);
  jni.JString getAssetFilePathByName1(
      jni.JString assetFileName, jni.JString packageName);
  jni.JString getAssetFilePathBySubpath(jni.JString assetSubpath);
  jni.JString getAssetFilePathBySubpath1(
      jni.JString assetSubpath, jni.JString packageName);
}

class _$FlutterPlugin_FlutterAssetsImpl
    implements $FlutterPlugin_FlutterAssetsImpl {
  _$FlutterPlugin_FlutterAssetsImpl({
    required jni.JString Function(jni.JString assetFileName)
        getAssetFilePathByName,
    required jni.JString Function(
            jni.JString assetFileName, jni.JString packageName)
        getAssetFilePathByName1,
    required jni.JString Function(jni.JString assetSubpath)
        getAssetFilePathBySubpath,
    required jni.JString Function(
            jni.JString assetSubpath, jni.JString packageName)
        getAssetFilePathBySubpath1,
  })  : _getAssetFilePathByName = getAssetFilePathByName,
        _getAssetFilePathByName1 = getAssetFilePathByName1,
        _getAssetFilePathBySubpath = getAssetFilePathBySubpath,
        _getAssetFilePathBySubpath1 = getAssetFilePathBySubpath1;

  final jni.JString Function(jni.JString assetFileName) _getAssetFilePathByName;
  final jni.JString Function(jni.JString assetFileName, jni.JString packageName)
      _getAssetFilePathByName1;
  final jni.JString Function(jni.JString assetSubpath)
      _getAssetFilePathBySubpath;
  final jni.JString Function(jni.JString assetSubpath, jni.JString packageName)
      _getAssetFilePathBySubpath1;

  jni.JString getAssetFilePathByName(jni.JString assetFileName) {
    return _getAssetFilePathByName(assetFileName);
  }

  jni.JString getAssetFilePathByName1(
      jni.JString assetFileName, jni.JString packageName) {
    return _getAssetFilePathByName1(assetFileName, packageName);
  }

  jni.JString getAssetFilePathBySubpath(jni.JString assetSubpath) {
    return _getAssetFilePathBySubpath(assetSubpath);
  }

  jni.JString getAssetFilePathBySubpath1(
      jni.JString assetSubpath, jni.JString packageName) {
    return _getAssetFilePathBySubpath1(assetSubpath, packageName);
  }
}

final class $FlutterPlugin_FlutterAssetsType
    extends jni.JObjType<FlutterPlugin_FlutterAssets> {
  const $FlutterPlugin_FlutterAssetsType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets;";

  @override
  FlutterPlugin_FlutterAssets fromReference(jni.JReference reference) =>
      FlutterPlugin_FlutterAssets.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterPlugin_FlutterAssetsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterPlugin_FlutterAssetsType) &&
        other is $FlutterPlugin_FlutterAssetsType;
  }
}

/// from: io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding
///
/// Resources made available to all plugins registered with a given io.flutter.embedding.engine.FlutterEngine.
///
/// The provided BinaryMessenger can be used to communicate with Dart code running in
/// the Flutter context associated with this plugin binding.
///
/// Plugins that need to respond to {@code Lifecycle} events should implement the additional
/// io.flutter.embedding.engine.plugins.activity.ActivityAware and/or io.flutter.embedding.engine.plugins.service.ServiceAware interfaces, where a Lifecycle
/// reference can be obtained.
class FlutterPlugin_FlutterPluginBinding extends jni.JObject {
  @override
  late final jni.JObjType<FlutterPlugin_FlutterPluginBinding> $type = type;

  FlutterPlugin_FlutterPluginBinding.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterPlugin_FlutterPluginBindingType();
  static final _id_new0 = _class.constructorId(
    r"(Landroid/content/Context;Lio/flutter/embedding/engine/FlutterEngine;Lio/flutter/plugin/common/BinaryMessenger;Lio/flutter/view/TextureRegistry;Lio/flutter/plugin/platform/PlatformViewRegistry;Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets;Lio/flutter/embedding/engine/FlutterEngineGroup;)V",
  );

  /// from: public void <init>(android.content.Context applicationContext, io.flutter.embedding.engine.FlutterEngine flutterEngine, io.flutter.plugin.common.BinaryMessenger binaryMessenger, io.flutter.view.TextureRegistry textureRegistry, io.flutter.plugin.platform.PlatformViewRegistry platformViewRegistry, io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterAssets flutterAssets, io.flutter.embedding.engine.FlutterEngineGroup group)
  /// The returned object must be released after use, by calling the [release] method.
  factory FlutterPlugin_FlutterPluginBinding(
    jni.JObject applicationContext,
    FlutterEngine flutterEngine,
    jni.JObject binaryMessenger,
    jni.JObject textureRegistry,
    PlatformViewRegistry platformViewRegistry,
    FlutterPlugin_FlutterAssets flutterAssets,
    jni.JObject group,
  ) {
    return FlutterPlugin_FlutterPluginBinding.fromReference(
        _id_new0(_class, referenceType, [
      applicationContext.reference.pointer,
      flutterEngine.reference.pointer,
      binaryMessenger.reference.pointer,
      textureRegistry.reference.pointer,
      platformViewRegistry.reference.pointer,
      flutterAssets.reference.pointer,
      group.reference.pointer
    ]));
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r"getApplicationContext",
    r"()Landroid/content/Context;",
  );

  /// from: public android.content.Context getApplicationContext()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getApplicationContext() {
    return _id_getApplicationContext(this, const jni.JObjectType(), []);
  }

  static final _id_getFlutterEngine = _class.instanceMethodId(
    r"getFlutterEngine",
    r"()Lio/flutter/embedding/engine/FlutterEngine;",
  );

  /// from: public io.flutter.embedding.engine.FlutterEngine getFlutterEngine()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// @deprecated Use {@code getBinaryMessenger()}, {@code getTextureRegistry()}, or {@code
  ///     getPlatformViewRegistry()} instead.
  FlutterEngine getFlutterEngine() {
    return _id_getFlutterEngine(this, const $FlutterEngineType(), []);
  }

  static final _id_getBinaryMessenger = _class.instanceMethodId(
    r"getBinaryMessenger",
    r"()Lio/flutter/plugin/common/BinaryMessenger;",
  );

  /// from: public io.flutter.plugin.common.BinaryMessenger getBinaryMessenger()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBinaryMessenger() {
    return _id_getBinaryMessenger(this, const jni.JObjectType(), []);
  }

  static final _id_getTextureRegistry = _class.instanceMethodId(
    r"getTextureRegistry",
    r"()Lio/flutter/view/TextureRegistry;",
  );

  /// from: public io.flutter.view.TextureRegistry getTextureRegistry()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTextureRegistry() {
    return _id_getTextureRegistry(this, const jni.JObjectType(), []);
  }

  static final _id_getPlatformViewRegistry = _class.instanceMethodId(
    r"getPlatformViewRegistry",
    r"()Lio/flutter/plugin/platform/PlatformViewRegistry;",
  );

  /// from: public io.flutter.plugin.platform.PlatformViewRegistry getPlatformViewRegistry()
  /// The returned object must be released after use, by calling the [release] method.
  PlatformViewRegistry getPlatformViewRegistry() {
    return _id_getPlatformViewRegistry(
        this, const $PlatformViewRegistryType(), []);
  }

  static final _id_getFlutterAssets = _class.instanceMethodId(
    r"getFlutterAssets",
    r"()Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets;",
  );

  /// from: public io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterAssets getFlutterAssets()
  /// The returned object must be released after use, by calling the [release] method.
  FlutterPlugin_FlutterAssets getFlutterAssets() {
    return _id_getFlutterAssets(
        this, const $FlutterPlugin_FlutterAssetsType(), []);
  }

  static final _id_getEngineGroup = _class.instanceMethodId(
    r"getEngineGroup",
    r"()Lio/flutter/embedding/engine/FlutterEngineGroup;",
  );

  /// from: public io.flutter.embedding.engine.FlutterEngineGroup getEngineGroup()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Accessor for the FlutterEngineGroup used to create the FlutterEngine for the
  /// app.
  ///
  /// This is useful in the rare case that a plugin has to spawn its own engine (for example,
  /// running an engine the background). The result is nullable since old versions of Flutter and
  /// custom setups may not have used a FlutterEngineGroup. Failing to use this when it is
  /// available will result in suboptimal performance and odd behaviors related to Dart isolate
  /// groups.
  jni.JObject getEngineGroup() {
    return _id_getEngineGroup(this, const jni.JObjectType(), []);
  }
}

final class $FlutterPlugin_FlutterPluginBindingType
    extends jni.JObjType<FlutterPlugin_FlutterPluginBinding> {
  const $FlutterPlugin_FlutterPluginBindingType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;";

  @override
  FlutterPlugin_FlutterPluginBinding fromReference(jni.JReference reference) =>
      FlutterPlugin_FlutterPluginBinding.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterPlugin_FlutterPluginBindingType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterPlugin_FlutterPluginBindingType) &&
        other is $FlutterPlugin_FlutterPluginBindingType;
  }
}

/// from: io.flutter.embedding.engine.plugins.FlutterPlugin
///
/// Interface to be implemented by all Flutter plugins.
///
/// A Flutter plugin allows Flutter developers to interact with a host platform, e.g., Android and
/// iOS, via Dart code. It includes platform code, as well as Dart code. A plugin author is
/// responsible for setting up an appropriate io.flutter.plugin.common.MethodChannel to
/// communicate between platform code and Dart code.
///
/// A Flutter plugin has a lifecycle. First, a developer must add a {@code FlutterPlugin} to an
/// instance of io.flutter.embedding.engine.FlutterEngine. To do this, obtain a PluginRegistry with FlutterEngine\#getPlugins(), then call PluginRegistry\#add(FlutterPlugin), passing the instance of the Flutter plugin. During the call
/// to PluginRegistry\#add(FlutterPlugin), the io.flutter.embedding.engine.FlutterEngine will invoke \#onAttachedToEngine(FlutterPluginBinding) on the given {@code FlutterPlugin}. If the {@code
/// FlutterPlugin} is removed from the io.flutter.embedding.engine.FlutterEngine via PluginRegistry\#remove(Class), or if the io.flutter.embedding.engine.FlutterEngine is
/// destroyed, the FlutterEngine will invoke FlutterPlugin\#onDetachedFromEngine(FlutterPluginBinding) on the given {@code FlutterPlugin}.
///
/// Once a {@code FlutterPlugin} is attached to a io.flutter.embedding.engine.FlutterEngine, the plugin's code is permitted to access and invoke
/// methods on resources within the FlutterPluginBinding that the io.flutter.embedding.engine.FlutterEngine gave to the {@code FlutterPlugin} in \#onAttachedToEngine(FlutterPluginBinding). This includes, for example, the application Context for the running app.
///
/// The FlutterPluginBinding provided in \#onAttachedToEngine(FlutterPluginBinding)
/// is no longer valid after the execution of \#onDetachedFromEngine(FlutterPluginBinding). Do
/// not access any properties of the FlutterPluginBinding after the completion of \#onDetachedFromEngine(FlutterPluginBinding).
///
/// To register a io.flutter.plugin.common.MethodChannel, obtain a BinaryMessenger
/// via the FlutterPluginBinding.
///
/// An Android Flutter plugin may require access to app resources or other artifacts that can only
/// be retrieved through a Context. Developers can access the application context via FlutterPluginBinding\#getApplicationContext().
///
/// Some plugins may require access to the {@code Activity} that is displaying a Flutter
/// experience, or may need to react to {@code Activity} lifecycle events, e.g., {@code onCreate()},
/// {@code onStart()}, {@code onResume()}, {@code onPause()}, {@code onStop()}, {@code onDestroy()}.
/// Any such plugin should implement io.flutter.embedding.engine.plugins.activity.ActivityAware in addition to implementing {@code
/// FlutterPlugin}. {@code ActivityAware} provides callback hooks that expose access to an associated
/// {@code Activity} and its {@code Lifecycle}. All plugins must respect the possibility that a
/// Flutter experience may never be associated with an {@code Activity}, e.g., when Flutter is used
/// for background behavior. Additionally, all plugins must respect that a {@code Activity}s may come
/// and go over time, thus requiring plugins to cleanup resources and recreate those resources as the
/// {@code Activity} comes and goes.
class FlutterPlugin extends jni.JObject {
  @override
  late final jni.JObjType<FlutterPlugin> $type = type;

  FlutterPlugin.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"io/flutter/embedding/engine/plugins/FlutterPlugin");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterPluginType();
  static final _id_onAttachedToEngine = _class.instanceMethodId(
    r"onAttachedToEngine",
    r"(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V",
  );

  /// from: public abstract void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterPluginBinding binding)
  ///
  /// This {@code FlutterPlugin} has been associated with a io.flutter.embedding.engine.FlutterEngine instance.
  ///
  /// Relevant resources that this {@code FlutterPlugin} may need are provided via the {@code
  /// binding}. The {@code binding} may be cached and referenced until \#onDetachedFromEngine(FlutterPluginBinding) is invoked and returns.
  void onAttachedToEngine(
    FlutterPlugin_FlutterPluginBinding binding,
  ) {
    _id_onAttachedToEngine(
        this, const jni.jvoidType(), [binding.reference.pointer]);
  }

  static final _id_onDetachedFromEngine = _class.instanceMethodId(
    r"onDetachedFromEngine",
    r"(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V",
  );

  /// from: public abstract void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterPluginBinding binding)
  ///
  /// This {@code FlutterPlugin} has been removed from a io.flutter.embedding.engine.FlutterEngine instance.
  ///
  /// The {@code binding} passed to this method is the same instance that was passed in \#onAttachedToEngine(FlutterPluginBinding). It is provided again in this method as a
  /// convenience. The {@code binding} may be referenced during the execution of this method, but it
  /// must not be cached or referenced after this method returns.
  ///
  /// {@code FlutterPlugin}s should release all resources in this method.
  void onDetachedFromEngine(
    FlutterPlugin_FlutterPluginBinding binding,
  ) {
    _id_onDetachedFromEngine(
        this, const jni.jvoidType(), [binding.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FlutterPluginImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onAttachedToEngine(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V") {
        _$impls[$p]!.onAttachedToEngine(
          $a[0].castTo(const $FlutterPlugin_FlutterPluginBindingType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"onDetachedFromEngine(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V") {
        _$impls[$p]!.onDetachedFromEngine(
          $a[0].castTo(const $FlutterPlugin_FlutterPluginBindingType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory FlutterPlugin.implement(
    $FlutterPluginImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FlutterPlugin.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.plugins.FlutterPlugin",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FlutterPluginImpl {
  factory $FlutterPluginImpl({
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onAttachedToEngine,
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onDetachedFromEngine,
  }) = _$FlutterPluginImpl;

  void onAttachedToEngine(FlutterPlugin_FlutterPluginBinding binding);
  void onDetachedFromEngine(FlutterPlugin_FlutterPluginBinding binding);
}

class _$FlutterPluginImpl implements $FlutterPluginImpl {
  _$FlutterPluginImpl({
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onAttachedToEngine,
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onDetachedFromEngine,
  })  : _onAttachedToEngine = onAttachedToEngine,
        _onDetachedFromEngine = onDetachedFromEngine;

  final void Function(FlutterPlugin_FlutterPluginBinding binding)
      _onAttachedToEngine;
  final void Function(FlutterPlugin_FlutterPluginBinding binding)
      _onDetachedFromEngine;

  void onAttachedToEngine(FlutterPlugin_FlutterPluginBinding binding) {
    return _onAttachedToEngine(binding);
  }

  void onDetachedFromEngine(FlutterPlugin_FlutterPluginBinding binding) {
    return _onDetachedFromEngine(binding);
  }
}

final class $FlutterPluginType extends jni.JObjType<FlutterPlugin> {
  const $FlutterPluginType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/plugins/FlutterPlugin;";

  @override
  FlutterPlugin fromReference(jni.JReference reference) =>
      FlutterPlugin.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterPluginType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterPluginType) &&
        other is $FlutterPluginType;
  }
}

/// from: io.flutter.embedding.engine.FlutterEngine$EngineLifecycleListener
///
/// Lifecycle callbacks for Flutter engine lifecycle events.
class FlutterEngine_EngineLifecycleListener extends jni.JObject {
  @override
  late final jni.JObjType<FlutterEngine_EngineLifecycleListener> $type = type;

  FlutterEngine_EngineLifecycleListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"io/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterEngine_EngineLifecycleListenerType();
  static final _id_onPreEngineRestart = _class.instanceMethodId(
    r"onPreEngineRestart",
    r"()V",
  );

  /// from: public abstract void onPreEngineRestart()
  ///
  /// Lifecycle callback invoked before a hot restart of the Flutter engine.
  void onPreEngineRestart() {
    _id_onPreEngineRestart(this, const jni.jvoidType(), []);
  }

  static final _id_onEngineWillDestroy = _class.instanceMethodId(
    r"onEngineWillDestroy",
    r"()V",
  );

  /// from: public abstract void onEngineWillDestroy()
  ///
  /// Lifecycle callback invoked before the Flutter engine is destroyed.
  ///
  /// For the duration of the call, the Flutter engine is still valid.
  void onEngineWillDestroy() {
    _id_onEngineWillDestroy(this, const jni.jvoidType(), []);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FlutterEngine_EngineLifecycleListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onPreEngineRestart()V") {
        _$impls[$p]!.onPreEngineRestart();
        return jni.nullptr;
      }
      if ($d == r"onEngineWillDestroy()V") {
        _$impls[$p]!.onEngineWillDestroy();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory FlutterEngine_EngineLifecycleListener.implement(
    $FlutterEngine_EngineLifecycleListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FlutterEngine_EngineLifecycleListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.FlutterEngine$EngineLifecycleListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FlutterEngine_EngineLifecycleListenerImpl {
  factory $FlutterEngine_EngineLifecycleListenerImpl({
    required void Function() onPreEngineRestart,
    required void Function() onEngineWillDestroy,
  }) = _$FlutterEngine_EngineLifecycleListenerImpl;

  void onPreEngineRestart();
  void onEngineWillDestroy();
}

class _$FlutterEngine_EngineLifecycleListenerImpl
    implements $FlutterEngine_EngineLifecycleListenerImpl {
  _$FlutterEngine_EngineLifecycleListenerImpl({
    required void Function() onPreEngineRestart,
    required void Function() onEngineWillDestroy,
  })  : _onPreEngineRestart = onPreEngineRestart,
        _onEngineWillDestroy = onEngineWillDestroy;

  final void Function() _onPreEngineRestart;
  final void Function() _onEngineWillDestroy;

  void onPreEngineRestart() {
    return _onPreEngineRestart();
  }

  void onEngineWillDestroy() {
    return _onEngineWillDestroy();
  }
}

final class $FlutterEngine_EngineLifecycleListenerType
    extends jni.JObjType<FlutterEngine_EngineLifecycleListener> {
  const $FlutterEngine_EngineLifecycleListenerType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener;";

  @override
  FlutterEngine_EngineLifecycleListener fromReference(
          jni.JReference reference) =>
      FlutterEngine_EngineLifecycleListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterEngine_EngineLifecycleListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterEngine_EngineLifecycleListenerType) &&
        other is $FlutterEngine_EngineLifecycleListenerType;
  }
}

/// from: io.flutter.embedding.engine.FlutterEngine
///
/// A single Flutter execution environment.
///
/// The {@code FlutterEngine} is the container through which Dart code can be run in an Android
/// application.
///
/// Dart code in a {@code FlutterEngine} can execute in the background, or it can be render to the
/// screen by using the accompanying FlutterRenderer and Dart code using the Flutter
/// framework on the Dart side. Rendering can be started and stopped, thus allowing a {@code
/// FlutterEngine} to move from UI interaction to data-only processing and then back to UI
/// interaction.
///
/// Multiple {@code FlutterEngine}s may exist, execute Dart code, and render UIs within a single
/// Android app. For better memory performance characteristics, construct multiple {@code
/// FlutterEngine}s via io.flutter.embedding.engine.FlutterEngineGroup rather than via {@code
/// FlutterEngine}'s constructor directly.
///
/// To start running Dart and/or Flutter within this {@code FlutterEngine}, get a reference to
/// this engine's DartExecutor and then use DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint). The DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint) method must not be invoked twice
/// on the same {@code FlutterEngine}.
///
/// To start rendering Flutter content to the screen, use \#getRenderer() to obtain a
/// FlutterRenderer and then attach a RenderSurface. Consider using a io.flutter.embedding.android.FlutterView as a RenderSurface.
///
/// Instatiating the first {@code FlutterEngine} per process will also load the Flutter engine's
/// native library and start the Dart VM. Subsequent {@code FlutterEngine}s will run on the same VM
/// instance but will have their own Dart <a href="https://api.dartlang.org/stable/dart-isolate/Isolate-class.html">Isolate</a> when the
/// DartExecutor is run. Each Isolate is a self-contained Dart environment and cannot
/// communicate with each other except via Isolate ports.
class FlutterEngine extends jni.JObject {
  @override
  late final jni.JObjType<FlutterEngine> $type = type;

  FlutterEngine.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"io/flutter/embedding/engine/FlutterEngine");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterEngineType();
  static final _id_new0 = _class.constructorId(
    r"(Landroid/content/Context;)V",
  );

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructs a new {@code FlutterEngine}.
  ///
  /// A new {@code FlutterEngine} does not execute any Dart code automatically. See \#getDartExecutor() and DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint)
  /// to begin executing Dart code within this {@code FlutterEngine}.
  ///
  /// A new {@code FlutterEngine} will not display any UI until a RenderSurface is
  /// registered. See \#getRenderer() and FlutterRenderer\#startRenderingToSurface(Surface, boolean).
  ///
  /// A new {@code FlutterEngine} automatically attaches all plugins. See \#getPlugins().
  ///
  /// A new {@code FlutterEngine} does come with all default system channels attached.
  ///
  /// The first {@code FlutterEngine} instance constructed per process will also load the Flutter
  /// native library and start a Dart VM.
  ///
  /// In order to pass Dart VM initialization arguments (see io.flutter.embedding.engine.FlutterShellArgs) when creating the VM, manually set the
  /// initialization arguments by calling io.flutter.embedding.engine.loader.FlutterLoader\#startInitialization(Context) and io.flutter.embedding.engine.loader.FlutterLoader\#ensureInitializationComplete(Context,
  /// String[]) before constructing the engine.
  factory FlutterEngine(
    jni.JObject context,
  ) {
    return FlutterEngine.fromReference(
        _id_new0(_class, referenceType, [context.reference.pointer]));
  }

  static final _id_new1 = _class.constructorId(
    r"(Landroid/content/Context;[Ljava/lang/String;)V",
  );

  /// from: public void <init>(android.content.Context context, java.lang.String[] dartVmArgs)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context) with added support for passing Dart VM arguments.
  ///
  /// If the Dart VM has already started, the given arguments will have no effect.
  factory FlutterEngine.new1(
    jni.JObject context,
    jni.JArray<jni.JString> dartVmArgs,
  ) {
    return FlutterEngine.fromReference(_id_new1(_class, referenceType,
        [context.reference.pointer, dartVmArgs.reference.pointer]));
  }

  static final _id_new2 = _class.constructorId(
    r"(Landroid/content/Context;[Ljava/lang/String;Z)V",
  );

  /// from: public void <init>(android.content.Context context, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context) with added support for passing Dart VM arguments and
  /// avoiding automatic plugin registration.
  ///
  /// If the Dart VM has already started, the given arguments will have no effect.
  factory FlutterEngine.new2(
    jni.JObject context,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
  ) {
    return FlutterEngine.fromReference(_id_new2(_class, referenceType, [
      context.reference.pointer,
      dartVmArgs.reference.pointer,
      automaticallyRegisterPlugins ? 1 : 0
    ]));
  }

  static final _id_new3 = _class.constructorId(
    r"(Landroid/content/Context;[Ljava/lang/String;ZZ)V",
  );

  /// from: public void <init>(android.content.Context context, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, String[], boolean) with added support for configuring
  /// whether the engine will receive restoration data.
  ///
  /// The {@code waitForRestorationData} flag controls whether the engine delays responding to
  /// requests from the framework for restoration data until that data has been provided to the
  /// engine via {@code RestorationChannel.setRestorationData(byte[] data)}. If the flag is false,
  /// the framework may temporarily initialize itself to default values before the restoration data
  /// has been made available to the engine. Setting {@code waitForRestorationData} to true avoids
  /// this extra work by delaying initialization until the data is available.
  ///
  /// When {@code waitForRestorationData} is set, {@code
  /// RestorationChannel.setRestorationData(byte[] data)} must be called at a later point in time. If
  /// it later turns out that no restoration data is available to restore the framework from, that
  /// method must still be called with null as an argument to indicate "no data".
  ///
  /// If the framework never requests the restoration data, this flag has no effect.
  factory FlutterEngine.new3(
    jni.JObject context,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
    bool waitForRestorationData,
  ) {
    return FlutterEngine.fromReference(_id_new3(_class, referenceType, [
      context.reference.pointer,
      dartVmArgs.reference.pointer,
      automaticallyRegisterPlugins ? 1 : 0,
      waitForRestorationData ? 1 : 0
    ]));
  }

  static final _id_new4 = _class.constructorId(
    r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;)V",
  );

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, FlutterLoader, FlutterJNI, String[], boolean) but with
  /// no Dart VM flags and automatically registers plugins.
  ///
  /// {@code flutterJNI} should be a new instance that has never been attached to an engine
  /// before.
  factory FlutterEngine.new4(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
  ) {
    return FlutterEngine.fromReference(_id_new4(_class, referenceType, [
      context.reference.pointer,
      flutterLoader.reference.pointer,
      flutterJNI.reference.pointer
    ]));
  }

  static final _id_new5 = _class.constructorId(
    r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;[Ljava/lang/String;Z)V",
  );

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, FlutterLoader, FlutterJNI), plus Dart VM flags in
  /// {@code dartVmArgs}, and control over whether plugins are automatically registered with this
  /// {@code FlutterEngine} in {@code automaticallyRegisterPlugins}. If plugins are automatically
  /// registered, then they are registered during the execution of this constructor.
  factory FlutterEngine.new5(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
  ) {
    return FlutterEngine.fromReference(_id_new5(_class, referenceType, [
      context.reference.pointer,
      flutterLoader.reference.pointer,
      flutterJNI.reference.pointer,
      dartVmArgs.reference.pointer,
      automaticallyRegisterPlugins ? 1 : 0
    ]));
  }

  static final _id_new6 = _class.constructorId(
    r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;Lio/flutter/plugin/platform/PlatformViewsController;[Ljava/lang/String;Z)V",
  );

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, io.flutter.plugin.platform.PlatformViewsController platformViewsController, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, FlutterLoader, FlutterJNI, String[], boolean), plus the
  /// ability to provide a custom {@code PlatformViewsController}.
  factory FlutterEngine.new6(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    PlatformViewsController platformViewsController,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
  ) {
    return FlutterEngine.fromReference(_id_new6(_class, referenceType, [
      context.reference.pointer,
      flutterLoader.reference.pointer,
      flutterJNI.reference.pointer,
      platformViewsController.reference.pointer,
      dartVmArgs.reference.pointer,
      automaticallyRegisterPlugins ? 1 : 0
    ]));
  }

  static final _id_new7 = _class.constructorId(
    r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;Lio/flutter/plugin/platform/PlatformViewsController;[Ljava/lang/String;ZZ)V",
  );

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, io.flutter.plugin.platform.PlatformViewsController platformViewsController, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Fully configurable {@code FlutterEngine} constructor.
  factory FlutterEngine.new7(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    PlatformViewsController platformViewsController,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
    bool waitForRestorationData,
  ) {
    return FlutterEngine.fromReference(_id_new7(_class, referenceType, [
      context.reference.pointer,
      flutterLoader.reference.pointer,
      flutterJNI.reference.pointer,
      platformViewsController.reference.pointer,
      dartVmArgs.reference.pointer,
      automaticallyRegisterPlugins ? 1 : 0,
      waitForRestorationData ? 1 : 0
    ]));
  }

  static final _id_new8 = _class.constructorId(
    r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;Lio/flutter/plugin/platform/PlatformViewsController;[Ljava/lang/String;ZZLio/flutter/embedding/engine/FlutterEngineGroup;)V",
  );

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, io.flutter.plugin.platform.PlatformViewsController platformViewsController, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData, io.flutter.embedding.engine.FlutterEngineGroup group)
  /// The returned object must be released after use, by calling the [release] method.
  factory FlutterEngine.new8(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    PlatformViewsController platformViewsController,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
    bool waitForRestorationData,
    jni.JObject group,
  ) {
    return FlutterEngine.fromReference(_id_new8(_class, referenceType, [
      context.reference.pointer,
      flutterLoader.reference.pointer,
      flutterJNI.reference.pointer,
      platformViewsController.reference.pointer,
      dartVmArgs.reference.pointer,
      automaticallyRegisterPlugins ? 1 : 0,
      waitForRestorationData ? 1 : 0,
      group.reference.pointer
    ]));
  }

  static final _id_destroy = _class.instanceMethodId(
    r"destroy",
    r"()V",
  );

  /// from: public void destroy()
  ///
  /// Cleans up all components within this {@code FlutterEngine} and destroys the associated Dart
  /// Isolate. All state held by the Dart Isolate, such as the Flutter Elements tree, is lost.
  ///
  /// This {@code FlutterEngine} instance should be discarded after invoking this method.
  void destroy() {
    _id_destroy(this, const jni.jvoidType(), []);
  }

  static final _id_addEngineLifecycleListener = _class.instanceMethodId(
    r"addEngineLifecycleListener",
    r"(Lio/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener;)V",
  );

  /// from: public void addEngineLifecycleListener(io.flutter.embedding.engine.FlutterEngine.EngineLifecycleListener listener)
  ///
  /// Adds a {@code listener} to be notified of Flutter engine lifecycle events, e.g., {@code
  /// onPreEngineStart()}.
  void addEngineLifecycleListener(
    FlutterEngine_EngineLifecycleListener listener,
  ) {
    _id_addEngineLifecycleListener(
        this, const jni.jvoidType(), [listener.reference.pointer]);
  }

  static final _id_removeEngineLifecycleListener = _class.instanceMethodId(
    r"removeEngineLifecycleListener",
    r"(Lio/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener;)V",
  );

  /// from: public void removeEngineLifecycleListener(io.flutter.embedding.engine.FlutterEngine.EngineLifecycleListener listener)
  ///
  /// Removes a {@code listener} that was previously added with \#addEngineLifecycleListener(EngineLifecycleListener).
  void removeEngineLifecycleListener(
    FlutterEngine_EngineLifecycleListener listener,
  ) {
    _id_removeEngineLifecycleListener(
        this, const jni.jvoidType(), [listener.reference.pointer]);
  }

  static final _id_getDartExecutor = _class.instanceMethodId(
    r"getDartExecutor",
    r"()Lio/flutter/embedding/engine/dart/DartExecutor;",
  );

  /// from: public io.flutter.embedding.engine.dart.DartExecutor getDartExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The Dart execution context associated with this {@code FlutterEngine}.
  ///
  /// The DartExecutor can be used to start executing Dart code from a given entrypoint.
  /// See DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint).
  ///
  /// Use the DartExecutor to connect any desired message channels and method channels to
  /// facilitate communication between Android and Dart/Flutter.
  jni.JObject getDartExecutor() {
    return _id_getDartExecutor(this, const jni.JObjectType(), []);
  }

  static final _id_getRenderer = _class.instanceMethodId(
    r"getRenderer",
    r"()Lio/flutter/embedding/engine/renderer/FlutterRenderer;",
  );

  /// from: public io.flutter.embedding.engine.renderer.FlutterRenderer getRenderer()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The rendering system associated with this {@code FlutterEngine}.
  ///
  /// To render a Flutter UI that is produced by this {@code FlutterEngine}'s Dart code, attach a
  /// RenderSurface to this FlutterRenderer.
  jni.JObject getRenderer() {
    return _id_getRenderer(this, const jni.JObjectType(), []);
  }

  static final _id_getAccessibilityChannel = _class.instanceMethodId(
    r"getAccessibilityChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/AccessibilityChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.AccessibilityChannel getAccessibilityChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends accessibility requests and events from Flutter to Android.
  jni.JObject getAccessibilityChannel() {
    return _id_getAccessibilityChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getLifecycleChannel = _class.instanceMethodId(
    r"getLifecycleChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/LifecycleChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.LifecycleChannel getLifecycleChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends Android lifecycle events to Flutter.
  jni.JObject getLifecycleChannel() {
    return _id_getLifecycleChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getLocalizationChannel = _class.instanceMethodId(
    r"getLocalizationChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/LocalizationChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.LocalizationChannel getLocalizationChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends locale data from Android to Flutter.
  jni.JObject getLocalizationChannel() {
    return _id_getLocalizationChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getNavigationChannel = _class.instanceMethodId(
    r"getNavigationChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/NavigationChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.NavigationChannel getNavigationChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends Flutter navigation commands from Android to Flutter.
  jni.JObject getNavigationChannel() {
    return _id_getNavigationChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getPlatformChannel = _class.instanceMethodId(
    r"getPlatformChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/PlatformChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.PlatformChannel getPlatformChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends platform-oriented requests and information to Flutter, e.g., requests
  /// to play sounds, requests for haptics, system chrome settings, etc.
  jni.JObject getPlatformChannel() {
    return _id_getPlatformChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getProcessTextChannel = _class.instanceMethodId(
    r"getProcessTextChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/ProcessTextChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.ProcessTextChannel getProcessTextChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends text processing requests from Flutter to Android.
  jni.JObject getProcessTextChannel() {
    return _id_getProcessTextChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getRestorationChannel = _class.instanceMethodId(
    r"getRestorationChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/RestorationChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.RestorationChannel getRestorationChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel to exchange restoration data between framework and engine.
  ///
  /// The engine can obtain the current restoration data from the framework via this channel to
  /// store it on disk and - when the app is relaunched - provide the stored data back to the
  /// framework to recreate the original state of the app.
  jni.JObject getRestorationChannel() {
    return _id_getRestorationChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getSettingsChannel = _class.instanceMethodId(
    r"getSettingsChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/SettingsChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.SettingsChannel getSettingsChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends platform/user settings from Android to Flutter, e.g., time format,
  /// scale factor, etc.
  jni.JObject getSettingsChannel() {
    return _id_getSettingsChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getDeferredComponentChannel = _class.instanceMethodId(
    r"getDeferredComponentChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/DeferredComponentChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.DeferredComponentChannel getDeferredComponentChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that allows manual installation and state querying of deferred components.
  jni.JObject getDeferredComponentChannel() {
    return _id_getDeferredComponentChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getSystemChannel = _class.instanceMethodId(
    r"getSystemChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/SystemChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.SystemChannel getSystemChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends memory pressure warnings from Android to Flutter.
  jni.JObject getSystemChannel() {
    return _id_getSystemChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getMouseCursorChannel = _class.instanceMethodId(
    r"getMouseCursorChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/MouseCursorChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.MouseCursorChannel getMouseCursorChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends and receives text input requests and state.
  jni.JObject getMouseCursorChannel() {
    return _id_getMouseCursorChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getTextInputChannel = _class.instanceMethodId(
    r"getTextInputChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/TextInputChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.TextInputChannel getTextInputChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends and receives text input requests and state.
  jni.JObject getTextInputChannel() {
    return _id_getTextInputChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getSpellCheckChannel = _class.instanceMethodId(
    r"getSpellCheckChannel",
    r"()Lio/flutter/embedding/engine/systemchannels/SpellCheckChannel;",
  );

  /// from: public io.flutter.embedding.engine.systemchannels.SpellCheckChannel getSpellCheckChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends and receives spell check requests and results.
  jni.JObject getSpellCheckChannel() {
    return _id_getSpellCheckChannel(this, const jni.JObjectType(), []);
  }

  static final _id_getPlugins = _class.instanceMethodId(
    r"getPlugins",
    r"()Lio/flutter/embedding/engine/plugins/PluginRegistry;",
  );

  /// from: public io.flutter.embedding.engine.plugins.PluginRegistry getPlugins()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Plugin registry, which registers plugins that want to be applied to this {@code FlutterEngine}.
  jni.JObject getPlugins() {
    return _id_getPlugins(this, const jni.JObjectType(), []);
  }

  static final _id_getLocalizationPlugin = _class.instanceMethodId(
    r"getLocalizationPlugin",
    r"()Lio/flutter/plugin/localization/LocalizationPlugin;",
  );

  /// from: public io.flutter.plugin.localization.LocalizationPlugin getLocalizationPlugin()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The LocalizationPlugin this FlutterEngine created.
  jni.JObject getLocalizationPlugin() {
    return _id_getLocalizationPlugin(this, const jni.JObjectType(), []);
  }

  static final _id_getPlatformViewsController = _class.instanceMethodId(
    r"getPlatformViewsController",
    r"()Lio/flutter/plugin/platform/PlatformViewsController;",
  );

  /// from: public io.flutter.plugin.platform.PlatformViewsController getPlatformViewsController()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// {@code PlatformViewsController}, which controls all platform views running within this {@code
  /// FlutterEngine}.
  PlatformViewsController getPlatformViewsController() {
    return _id_getPlatformViewsController(
        this, const $PlatformViewsControllerType(), []);
  }

  static final _id_getActivityControlSurface = _class.instanceMethodId(
    r"getActivityControlSurface",
    r"()Lio/flutter/embedding/engine/plugins/activity/ActivityControlSurface;",
  );

  /// from: public io.flutter.embedding.engine.plugins.activity.ActivityControlSurface getActivityControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getActivityControlSurface() {
    return _id_getActivityControlSurface(this, const jni.JObjectType(), []);
  }

  static final _id_getServiceControlSurface = _class.instanceMethodId(
    r"getServiceControlSurface",
    r"()Lio/flutter/embedding/engine/plugins/service/ServiceControlSurface;",
  );

  /// from: public io.flutter.embedding.engine.plugins.service.ServiceControlSurface getServiceControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getServiceControlSurface() {
    return _id_getServiceControlSurface(this, const jni.JObjectType(), []);
  }

  static final _id_getBroadcastReceiverControlSurface = _class.instanceMethodId(
    r"getBroadcastReceiverControlSurface",
    r"()Lio/flutter/embedding/engine/plugins/broadcastreceiver/BroadcastReceiverControlSurface;",
  );

  /// from: public io.flutter.embedding.engine.plugins.broadcastreceiver.BroadcastReceiverControlSurface getBroadcastReceiverControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBroadcastReceiverControlSurface() {
    return _id_getBroadcastReceiverControlSurface(
        this, const jni.JObjectType(), []);
  }

  static final _id_getContentProviderControlSurface = _class.instanceMethodId(
    r"getContentProviderControlSurface",
    r"()Lio/flutter/embedding/engine/plugins/contentprovider/ContentProviderControlSurface;",
  );

  /// from: public io.flutter.embedding.engine.plugins.contentprovider.ContentProviderControlSurface getContentProviderControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentProviderControlSurface() {
    return _id_getContentProviderControlSurface(
        this, const jni.JObjectType(), []);
  }

  static final _id_updateDisplayMetrics = _class.instanceMethodId(
    r"updateDisplayMetrics",
    r"(FFF)V",
  );

  /// from: public void updateDisplayMetrics(float width, float height, float density)
  void updateDisplayMetrics(
    double width,
    double height,
    double density,
  ) {
    _id_updateDisplayMetrics(this, const jni.jvoidType(), [
      jni.JValueFloat(width),
      jni.JValueFloat(height),
      jni.JValueFloat(density)
    ]);
  }
}

final class $FlutterEngineType extends jni.JObjType<FlutterEngine> {
  const $FlutterEngineType();

  @override
  String get signature => r"Lio/flutter/embedding/engine/FlutterEngine;";

  @override
  FlutterEngine fromReference(jni.JReference reference) =>
      FlutterEngine.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterEngineType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterEngineType) &&
        other is $FlutterEngineType;
  }
}

/// from: io.flutter.plugin.platform.PlatformViewsController
///
/// Manages platform views.
///
/// Each io.flutter.embedding.engine.FlutterEngine or io.flutter.app.FlutterPluginRegistry has a single platform views controller. A platform views
/// controller can be attached to at most one Flutter view.
class PlatformViewsController extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsController> $type = type;

  PlatformViewsController.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"io/flutter/plugin/platform/PlatformViewsController");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsControllerType();
  static final _id_createPlatformView = _class.instanceMethodId(
    r"createPlatformView",
    r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;Z)Lio/flutter/plugin/platform/PlatformView;",
  );

  /// from: public io.flutter.plugin.platform.PlatformView createPlatformView(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request, boolean wrapContext)
  /// The returned object must be released after use, by calling the [release] method.
  PlatformView createPlatformView(
    PlatformViewsChannel_PlatformViewCreationRequest request,
    bool wrapContext,
  ) {
    return _id_createPlatformView(this, const $PlatformViewType(),
        [request.reference.pointer, wrapContext ? 1 : 0]);
  }

  static final _id_configureForTextureLayerComposition =
      _class.instanceMethodId(
    r"configureForTextureLayerComposition",
    r"(Lio/flutter/plugin/platform/PlatformView;Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)J",
  );

  /// from: public long configureForTextureLayerComposition(io.flutter.plugin.platform.PlatformView platformView, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request)
  int configureForTextureLayerComposition(
    PlatformView platformView,
    PlatformViewsChannel_PlatformViewCreationRequest request,
  ) {
    return _id_configureForTextureLayerComposition(this, const jni.jlongType(),
        [platformView.reference.pointer, request.reference.pointer]);
  }

  static final _id_toMotionEvent = _class.instanceMethodId(
    r"toMotionEvent",
    r"(FLio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;Z)Landroid/view/MotionEvent;",
  );

  /// from: public android.view.MotionEvent toMotionEvent(float density, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewTouch touch, boolean usingVirtualDiplay)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toMotionEvent(
    double density,
    PlatformViewsChannel_PlatformViewTouch touch,
    bool usingVirtualDiplay,
  ) {
    return _id_toMotionEvent(this, const jni.JObjectType(), [
      jni.JValueFloat(density),
      touch.reference.pointer,
      usingVirtualDiplay ? 1 : 0
    ]);
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsController() {
    return PlatformViewsController.fromReference(
        _id_new0(_class, referenceType, []));
  }

  static final _id_attach = _class.instanceMethodId(
    r"attach",
    r"(Landroid/content/Context;Lio/flutter/view/TextureRegistry;Lio/flutter/embedding/engine/dart/DartExecutor;)V",
  );

  /// from: public void attach(android.content.Context context, io.flutter.view.TextureRegistry textureRegistry, io.flutter.embedding.engine.dart.DartExecutor dartExecutor)
  ///
  /// Attaches this platform views controller to its input and output channels.
  ///@param context The base context that will be passed to embedded views created by this
  ///     controller. This should be the context of the Activity hosting the Flutter application.
  ///@param textureRegistry The texture registry which provides the output textures into which the
  ///     embedded views will be rendered.
  ///@param dartExecutor The dart execution context, which is used to set up a system channel.
  void attach(
    jni.JObject context,
    jni.JObject textureRegistry,
    jni.JObject dartExecutor,
  ) {
    _id_attach(this, const jni.jvoidType(), [
      context.reference.pointer,
      textureRegistry.reference.pointer,
      dartExecutor.reference.pointer
    ]);
  }

  static final _id_setSoftwareRendering = _class.instanceMethodId(
    r"setSoftwareRendering",
    r"(Z)V",
  );

  /// from: public void setSoftwareRendering(boolean useSoftwareRendering)
  ///
  /// Sets whether Flutter uses software rendering.
  ///
  /// When software rendering is used, no GL context is available on the raster thread. When this
  /// is set to true, there's no Flutter composition of Android views and Flutter widgets since GL
  /// textures cannot be used.
  ///
  /// Software rendering is only used for testing in emulators, and it should never be set to true
  /// in a production environment.
  ///@param useSoftwareRendering Whether software rendering is used.
  void setSoftwareRendering(
    bool useSoftwareRendering,
  ) {
    _id_setSoftwareRendering(
        this, const jni.jvoidType(), [useSoftwareRendering ? 1 : 0]);
  }

  static final _id_detach = _class.instanceMethodId(
    r"detach",
    r"()V",
  );

  /// from: public void detach()
  ///
  /// Detaches this platform views controller.
  ///
  /// This is typically called when a Flutter applications moves to run in the background, or is
  /// destroyed. After calling this the platform views controller will no longer listen to it's
  /// previous messenger, and will not maintain references to the texture registry, context, and
  /// messenger passed to the previous attach call.
  void detach() {
    _id_detach(this, const jni.jvoidType(), []);
  }

  static final _id_attachToView = _class.instanceMethodId(
    r"attachToView",
    r"(Lio/flutter/embedding/android/FlutterView;)V",
  );

  /// from: public void attachToView(io.flutter.embedding.android.FlutterView newFlutterView)
  ///
  /// Attaches the controller to a FlutterView.
  ///
  /// When io.flutter.embedding.android.FlutterFragment is used, this method is called
  /// after the device rotates since the FlutterView is recreated after a rotation.
  void attachToView(
    jni.JObject newFlutterView,
  ) {
    _id_attachToView(
        this, const jni.jvoidType(), [newFlutterView.reference.pointer]);
  }

  static final _id_detachFromView = _class.instanceMethodId(
    r"detachFromView",
    r"()V",
  );

  /// from: public void detachFromView()
  ///
  /// Detaches the controller from FlutterView.
  ///
  /// When io.flutter.embedding.android.FlutterFragment is used, this method is called
  /// when the device rotates since the FlutterView is detached from the fragment. The next time the
  /// fragment needs to be displayed, a new Flutter view is created, so attachToView is called again.
  void detachFromView() {
    _id_detachFromView(this, const jni.jvoidType(), []);
  }

  static final _id_attachAccessibilityBridge = _class.instanceMethodId(
    r"attachAccessibilityBridge",
    r"(Lio/flutter/view/AccessibilityBridge;)V",
  );

  /// from: public void attachAccessibilityBridge(io.flutter.view.AccessibilityBridge accessibilityBridge)
  void attachAccessibilityBridge(
    jni.JObject accessibilityBridge,
  ) {
    _id_attachAccessibilityBridge(
        this, const jni.jvoidType(), [accessibilityBridge.reference.pointer]);
  }

  static final _id_detachAccessibilityBridge = _class.instanceMethodId(
    r"detachAccessibilityBridge",
    r"()V",
  );

  /// from: public void detachAccessibilityBridge()
  void detachAccessibilityBridge() {
    _id_detachAccessibilityBridge(this, const jni.jvoidType(), []);
  }

  static final _id_attachTextInputPlugin = _class.instanceMethodId(
    r"attachTextInputPlugin",
    r"(Lio/flutter/plugin/editing/TextInputPlugin;)V",
  );

  /// from: public void attachTextInputPlugin(io.flutter.plugin.editing.TextInputPlugin textInputPlugin)
  ///
  /// Attaches this controller to a text input plugin.
  ///
  /// While a text input plugin is available, the platform views controller interacts with it to
  /// facilitate delegation of text input connections to platform views.
  ///
  /// A platform views controller should be attached to a text input plugin whenever it is
  /// possible for the Flutter framework to receive text input.
  void attachTextInputPlugin(
    jni.JObject textInputPlugin,
  ) {
    _id_attachTextInputPlugin(
        this, const jni.jvoidType(), [textInputPlugin.reference.pointer]);
  }

  static final _id_detachTextInputPlugin = _class.instanceMethodId(
    r"detachTextInputPlugin",
    r"()V",
  );

  /// from: public void detachTextInputPlugin()
  ///
  /// Detaches this controller from the currently attached text input plugin.
  void detachTextInputPlugin() {
    _id_detachTextInputPlugin(this, const jni.jvoidType(), []);
  }

  static final _id_checkInputConnectionProxy = _class.instanceMethodId(
    r"checkInputConnectionProxy",
    r"(Landroid/view/View;)Z",
  );

  /// from: public boolean checkInputConnectionProxy(android.view.View view)
  ///
  /// Returns true if Flutter should perform input connection proxying for the view.
  ///
  /// If the view is a platform view managed by this platform views controller returns true. Else
  /// if the view was created in a platform view's VD, delegates the decision to the platform view's
  /// View\#checkInputConnectionProxy(View) method. Else returns false.
  bool checkInputConnectionProxy(
    View view,
  ) {
    return _id_checkInputConnectionProxy(
        this, const jni.jbooleanType(), [view.reference.pointer]);
  }

  static final _id_getRegistry = _class.instanceMethodId(
    r"getRegistry",
    r"()Lio/flutter/plugin/platform/PlatformViewRegistry;",
  );

  /// from: public io.flutter.plugin.platform.PlatformViewRegistry getRegistry()
  /// The returned object must be released after use, by calling the [release] method.
  PlatformViewRegistry getRegistry() {
    return _id_getRegistry(this, const $PlatformViewRegistryType(), []);
  }

  static final _id_onAttachedToJNI = _class.instanceMethodId(
    r"onAttachedToJNI",
    r"()V",
  );

  /// from: public void onAttachedToJNI()
  ///
  /// Invoked when the io.flutter.embedding.engine.FlutterEngine that owns this PlatformViewsController attaches to JNI.
  void onAttachedToJNI() {
    _id_onAttachedToJNI(this, const jni.jvoidType(), []);
  }

  static final _id_onDetachedFromJNI = _class.instanceMethodId(
    r"onDetachedFromJNI",
    r"()V",
  );

  /// from: public void onDetachedFromJNI()
  ///
  /// Invoked when the io.flutter.embedding.engine.FlutterEngine that owns this PlatformViewsController detaches from JNI.
  void onDetachedFromJNI() {
    _id_onDetachedFromJNI(this, const jni.jvoidType(), []);
  }

  static final _id_onPreEngineRestart = _class.instanceMethodId(
    r"onPreEngineRestart",
    r"()V",
  );

  /// from: public void onPreEngineRestart()
  void onPreEngineRestart() {
    _id_onPreEngineRestart(this, const jni.jvoidType(), []);
  }

  static final _id_getPlatformViewById = _class.instanceMethodId(
    r"getPlatformViewById",
    r"(I)Landroid/view/View;",
  );

  /// from: public android.view.View getPlatformViewById(int viewId)
  /// The returned object must be released after use, by calling the [release] method.
  View getPlatformViewById(
    int viewId,
  ) {
    return _id_getPlatformViewById(
        this, const $ViewType(), [jni.JValueInt(viewId)]);
  }

  static final _id_usesVirtualDisplay = _class.instanceMethodId(
    r"usesVirtualDisplay",
    r"(I)Z",
  );

  /// from: public boolean usesVirtualDisplay(int id)
  bool usesVirtualDisplay(
    int id,
  ) {
    return _id_usesVirtualDisplay(
        this, const jni.jbooleanType(), [jni.JValueInt(id)]);
  }

  static final _id_disposePlatformView = _class.instanceMethodId(
    r"disposePlatformView",
    r"(I)V",
  );

  /// from: public void disposePlatformView(int viewId)
  ///
  /// Disposes a single
  ///@param viewId the PlatformView ID.
  void disposePlatformView(
    int viewId,
  ) {
    _id_disposePlatformView(
        this, const jni.jvoidType(), [jni.JValueInt(viewId)]);
  }

  static final _id_attachToFlutterRenderer = _class.instanceMethodId(
    r"attachToFlutterRenderer",
    r"(Lio/flutter/embedding/engine/renderer/FlutterRenderer;)V",
  );

  /// from: public void attachToFlutterRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer flutterRenderer)
  void attachToFlutterRenderer(
    jni.JObject flutterRenderer,
  ) {
    _id_attachToFlutterRenderer(
        this, const jni.jvoidType(), [flutterRenderer.reference.pointer]);
  }

  static final _id_onDisplayPlatformView = _class.instanceMethodId(
    r"onDisplayPlatformView",
    r"(IIIIIIILio/flutter/embedding/engine/mutatorsstack/FlutterMutatorsStack;)V",
  );

  /// from: public void onDisplayPlatformView(int viewId, int x, int y, int width, int height, int viewWidth, int viewHeight, io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack mutatorsStack)
  ///
  /// Called when a platform view id displayed in the current frame.
  ///@param viewId The ID of the platform view.
  ///@param x The left position relative to {@code FlutterView}.
  ///@param y The top position relative to {@code FlutterView}.
  ///@param width The width of the platform view.
  ///@param height The height of the platform view.
  ///@param viewWidth The original width of the platform view before applying the mutator stack.
  ///@param viewHeight The original height of the platform view before applying the mutator stack.
  ///@param mutatorsStack The mutator stack. This member is not intended for public use, and is only
  ///     visible for testing.
  void onDisplayPlatformView(
    int viewId,
    int x,
    int y,
    int width,
    int height,
    int viewWidth,
    int viewHeight,
    jni.JObject mutatorsStack,
  ) {
    _id_onDisplayPlatformView(this, const jni.jvoidType(), [
      jni.JValueInt(viewId),
      jni.JValueInt(x),
      jni.JValueInt(y),
      jni.JValueInt(width),
      jni.JValueInt(height),
      jni.JValueInt(viewWidth),
      jni.JValueInt(viewHeight),
      mutatorsStack.reference.pointer
    ]);
  }

  static final _id_onDisplayOverlaySurface = _class.instanceMethodId(
    r"onDisplayOverlaySurface",
    r"(IIIII)V",
  );

  /// from: public void onDisplayOverlaySurface(int id, int x, int y, int width, int height)
  ///
  /// Called when an overlay surface is displayed in the current frame.
  ///@param id The ID of the surface.
  ///@param x The left position relative to {@code FlutterView}.
  ///@param y The top position relative to {@code FlutterView}.
  ///@param width The width of the surface.
  ///@param height The height of the surface. This member is not intended for public use, and is
  ///     only visible for testing.
  void onDisplayOverlaySurface(
    int id,
    int x,
    int y,
    int width,
    int height,
  ) {
    _id_onDisplayOverlaySurface(this, const jni.jvoidType(), [
      jni.JValueInt(id),
      jni.JValueInt(x),
      jni.JValueInt(y),
      jni.JValueInt(width),
      jni.JValueInt(height)
    ]);
  }

  static final _id_onBeginFrame = _class.instanceMethodId(
    r"onBeginFrame",
    r"()V",
  );

  /// from: public void onBeginFrame()
  void onBeginFrame() {
    _id_onBeginFrame(this, const jni.jvoidType(), []);
  }

  static final _id_onEndFrame = _class.instanceMethodId(
    r"onEndFrame",
    r"()V",
  );

  /// from: public void onEndFrame()
  ///
  /// Called by {@code FlutterJNI} when the Flutter frame was submitted.
  ///
  /// This member is not intended for public use, and is only visible for testing.
  void onEndFrame() {
    _id_onEndFrame(this, const jni.jvoidType(), []);
  }

  static final _id_createOverlaySurface = _class.instanceMethodId(
    r"createOverlaySurface",
    r"(Lio/flutter/plugin/platform/PlatformOverlayView;)Lio/flutter/embedding/engine/FlutterOverlaySurface;",
  );

  /// from: public io.flutter.embedding.engine.FlutterOverlaySurface createOverlaySurface(io.flutter.plugin.platform.PlatformOverlayView imageView)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates and tracks the overlay surface.
  ///@param imageView The surface that displays the overlay.
  ///@return Wrapper object that provides the layer id and the surface. This member is not intended
  ///     for public use, and is only visible for testing.
  jni.JObject createOverlaySurface(
    jni.JObject imageView,
  ) {
    return _id_createOverlaySurface(
        this, const jni.JObjectType(), [imageView.reference.pointer]);
  }

  static final _id_createOverlaySurface1 = _class.instanceMethodId(
    r"createOverlaySurface",
    r"()Lio/flutter/embedding/engine/FlutterOverlaySurface;",
  );

  /// from: public io.flutter.embedding.engine.FlutterOverlaySurface createOverlaySurface()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates an overlay surface while the Flutter view is rendered by {@code PlatformOverlayView}.
  ///
  /// This method is invoked by {@code FlutterJNI} only.
  ///
  /// This member is not intended for public use, and is only visible for testing.
  jni.JObject createOverlaySurface1() {
    return _id_createOverlaySurface1(this, const jni.JObjectType(), []);
  }

  static final _id_destroyOverlaySurfaces = _class.instanceMethodId(
    r"destroyOverlaySurfaces",
    r"()V",
  );

  /// from: public void destroyOverlaySurfaces()
  ///
  /// Destroys the overlay surfaces and removes them from the view hierarchy.
  ///
  /// This method is used only internally by {@code FlutterJNI}.
  void destroyOverlaySurfaces() {
    _id_destroyOverlaySurfaces(this, const jni.jvoidType(), []);
  }

  static final _id_getOverlayLayerViews = _class.instanceMethodId(
    r"getOverlayLayerViews",
    r"()Landroid/util/SparseArray;",
  );

  /// from: public android.util.SparseArray<io.flutter.plugin.platform.PlatformOverlayView> getOverlayLayerViews()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOverlayLayerViews() {
    return _id_getOverlayLayerViews(this, const jni.JObjectType(), []);
  }
}

final class $PlatformViewsControllerType
    extends jni.JObjType<PlatformViewsController> {
  const $PlatformViewsControllerType();

  @override
  String get signature =>
      r"Lio/flutter/plugin/platform/PlatformViewsController;";

  @override
  PlatformViewsController fromReference(jni.JReference reference) =>
      PlatformViewsController.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewsControllerType) &&
        other is $PlatformViewsControllerType;
  }
}

/// from: io.flutter.plugin.platform.PlatformViewRegistry
///
/// Registry for platform view factories.
///
/// Plugins can register factories for specific view types.
class PlatformViewRegistry extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewRegistry> $type = type;

  PlatformViewRegistry.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"io/flutter/plugin/platform/PlatformViewRegistry");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewRegistryType();
  static final _id_registerViewFactory = _class.instanceMethodId(
    r"registerViewFactory",
    r"(Ljava/lang/String;Lio/flutter/plugin/platform/PlatformViewFactory;)Z",
  );

  /// from: public abstract boolean registerViewFactory(java.lang.String viewTypeId, io.flutter.plugin.platform.PlatformViewFactory factory)
  ///
  /// Registers a factory for a platform view.
  ///@param viewTypeId unique identifier for the platform view's type.
  ///@param factory factory for creating platform views of the specified type.
  ///@return true if succeeded, false if a factory is already registered for viewTypeId.
  bool registerViewFactory(
    jni.JString viewTypeId,
    jni.JObject factory0,
  ) {
    return _id_registerViewFactory(this, const jni.jbooleanType(),
        [viewTypeId.reference.pointer, factory0.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewRegistryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"registerViewFactory(Ljava/lang/String;Lio/flutter/plugin/platform/PlatformViewFactory;)Z") {
        final $r = _$impls[$p]!.registerViewFactory(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformViewRegistry.implement(
    $PlatformViewRegistryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformViewRegistry.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.plugin.platform.PlatformViewRegistry",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $PlatformViewRegistryImpl {
  factory $PlatformViewRegistryImpl({
    required bool Function(jni.JString viewTypeId, jni.JObject factory0)
        registerViewFactory,
  }) = _$PlatformViewRegistryImpl;

  bool registerViewFactory(jni.JString viewTypeId, jni.JObject factory0);
}

class _$PlatformViewRegistryImpl implements $PlatformViewRegistryImpl {
  _$PlatformViewRegistryImpl({
    required bool Function(jni.JString viewTypeId, jni.JObject factory0)
        registerViewFactory,
  }) : _registerViewFactory = registerViewFactory;

  final bool Function(jni.JString viewTypeId, jni.JObject factory0)
      _registerViewFactory;

  bool registerViewFactory(jni.JString viewTypeId, jni.JObject factory0) {
    return _registerViewFactory(viewTypeId, factory0);
  }
}

final class $PlatformViewRegistryType
    extends jni.JObjType<PlatformViewRegistry> {
  const $PlatformViewRegistryType();

  @override
  String get signature => r"Lio/flutter/plugin/platform/PlatformViewRegistry;";

  @override
  PlatformViewRegistry fromReference(jni.JReference reference) =>
      PlatformViewRegistry.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewRegistryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewRegistryType) &&
        other is $PlatformViewRegistryType;
  }
}

/// from: android.view.View$AccessibilityDelegate
class View_AccessibilityDelegate extends jni.JObject {
  @override
  late final jni.JObjType<View_AccessibilityDelegate> $type = type;

  View_AccessibilityDelegate.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$AccessibilityDelegate");

  /// The type which includes information such as the signature of this class.
  static const type = $View_AccessibilityDelegateType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory View_AccessibilityDelegate() {
    return View_AccessibilityDelegate.fromReference(
        _id_new0(_class, referenceType, []));
  }

  static final _id_sendAccessibilityEvent = _class.instanceMethodId(
    r"sendAccessibilityEvent",
    r"(Landroid/view/View;I)V",
  );

  /// from: public void sendAccessibilityEvent(android.view.View view, int i)
  void sendAccessibilityEvent(
    View view,
    int i,
  ) {
    _id_sendAccessibilityEvent(this, const jni.jvoidType(),
        [view.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_performAccessibilityAction = _class.instanceMethodId(
    r"performAccessibilityAction",
    r"(Landroid/view/View;ILandroid/os/Bundle;)Z",
  );

  /// from: public boolean performAccessibilityAction(android.view.View view, int i, android.os.Bundle bundle)
  bool performAccessibilityAction(
    View view,
    int i,
    jni.JObject bundle,
  ) {
    return _id_performAccessibilityAction(this, const jni.jbooleanType(),
        [view.reference.pointer, jni.JValueInt(i), bundle.reference.pointer]);
  }

  static final _id_sendAccessibilityEventUnchecked = _class.instanceMethodId(
    r"sendAccessibilityEventUnchecked",
    r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V",
  );

  /// from: public void sendAccessibilityEventUnchecked(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void sendAccessibilityEventUnchecked(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    _id_sendAccessibilityEventUnchecked(this, const jni.jvoidType(),
        [view.reference.pointer, accessibilityEvent.reference.pointer]);
  }

  static final _id_dispatchPopulateAccessibilityEvent = _class.instanceMethodId(
    r"dispatchPopulateAccessibilityEvent",
    r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z",
  );

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool dispatchPopulateAccessibilityEvent(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return _id_dispatchPopulateAccessibilityEvent(
        this,
        const jni.jbooleanType(),
        [view.reference.pointer, accessibilityEvent.reference.pointer]);
  }

  static final _id_onPopulateAccessibilityEvent = _class.instanceMethodId(
    r"onPopulateAccessibilityEvent",
    r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V",
  );

  /// from: public void onPopulateAccessibilityEvent(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onPopulateAccessibilityEvent(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    _id_onPopulateAccessibilityEvent(this, const jni.jvoidType(),
        [view.reference.pointer, accessibilityEvent.reference.pointer]);
  }

  static final _id_onInitializeAccessibilityEvent = _class.instanceMethodId(
    r"onInitializeAccessibilityEvent",
    r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V",
  );

  /// from: public void onInitializeAccessibilityEvent(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onInitializeAccessibilityEvent(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    _id_onInitializeAccessibilityEvent(this, const jni.jvoidType(),
        [view.reference.pointer, accessibilityEvent.reference.pointer]);
  }

  static final _id_onInitializeAccessibilityNodeInfo = _class.instanceMethodId(
    r"onInitializeAccessibilityNodeInfo",
    r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;)V",
  );

  /// from: public void onInitializeAccessibilityNodeInfo(android.view.View view, android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo)
  void onInitializeAccessibilityNodeInfo(
    View view,
    jni.JObject accessibilityNodeInfo,
  ) {
    _id_onInitializeAccessibilityNodeInfo(this, const jni.jvoidType(),
        [view.reference.pointer, accessibilityNodeInfo.reference.pointer]);
  }

  static final _id_addExtraDataToAccessibilityNodeInfo =
      _class.instanceMethodId(
    r"addExtraDataToAccessibilityNodeInfo",
    r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V",
  );

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.View view, android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo, java.lang.String string, android.os.Bundle bundle)
  void addExtraDataToAccessibilityNodeInfo(
    View view,
    jni.JObject accessibilityNodeInfo,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _id_addExtraDataToAccessibilityNodeInfo(this, const jni.jvoidType(), [
      view.reference.pointer,
      accessibilityNodeInfo.reference.pointer,
      string.reference.pointer,
      bundle.reference.pointer
    ]);
  }

  static final _id_onRequestSendAccessibilityEvent = _class.instanceMethodId(
    r"onRequestSendAccessibilityEvent",
    r"(Landroid/view/ViewGroup;Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z",
  );

  /// from: public boolean onRequestSendAccessibilityEvent(android.view.ViewGroup viewGroup, android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool onRequestSendAccessibilityEvent(
    jni.JObject viewGroup,
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return _id_onRequestSendAccessibilityEvent(this, const jni.jbooleanType(), [
      viewGroup.reference.pointer,
      view.reference.pointer,
      accessibilityEvent.reference.pointer
    ]);
  }

  static final _id_getAccessibilityNodeProvider = _class.instanceMethodId(
    r"getAccessibilityNodeProvider",
    r"(Landroid/view/View;)Landroid/view/accessibility/AccessibilityNodeProvider;",
  );

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider(android.view.View view)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityNodeProvider(
    View view,
  ) {
    return _id_getAccessibilityNodeProvider(
        this, const jni.JObjectType(), [view.reference.pointer]);
  }
}

final class $View_AccessibilityDelegateType
    extends jni.JObjType<View_AccessibilityDelegate> {
  const $View_AccessibilityDelegateType();

  @override
  String get signature => r"Landroid/view/View$AccessibilityDelegate;";

  @override
  View_AccessibilityDelegate fromReference(jni.JReference reference) =>
      View_AccessibilityDelegate.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_AccessibilityDelegateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_AccessibilityDelegateType) &&
        other is $View_AccessibilityDelegateType;
  }
}

/// from: android.view.View$BaseSavedState
class View_BaseSavedState extends jni.JObject {
  @override
  late final jni.JObjType<View_BaseSavedState> $type = type;

  View_BaseSavedState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"android/view/View$BaseSavedState");

  /// The type which includes information such as the signature of this class.
  static const type = $View_BaseSavedStateType();
  static final _id_CREATOR = _class.staticFieldId(
    r"CREATOR",
    r"Landroid/os/Parcelable$Creator;",
  );

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_new0 = _class.constructorId(
    r"(Landroid/os/Parcel;)V",
  );

  /// from: public void <init>(android.os.Parcel parcel)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_BaseSavedState(
    jni.JObject parcel,
  ) {
    return View_BaseSavedState.fromReference(
        _id_new0(_class, referenceType, [parcel.reference.pointer]));
  }

  static final _id_new1 = _class.constructorId(
    r"(Landroid/os/Parcel;Ljava/lang/ClassLoader;)V",
  );

  /// from: public void <init>(android.os.Parcel parcel, java.lang.ClassLoader classLoader)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_BaseSavedState.new1(
    jni.JObject parcel,
    jni.JObject classLoader,
  ) {
    return View_BaseSavedState.fromReference(_id_new1(_class, referenceType,
        [parcel.reference.pointer, classLoader.reference.pointer]));
  }

  static final _id_new2 = _class.constructorId(
    r"(Landroid/os/Parcelable;)V",
  );

  /// from: public void <init>(android.os.Parcelable parcelable)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_BaseSavedState.new2(
    jni.JObject parcelable,
  ) {
    return View_BaseSavedState.fromReference(
        _id_new2(_class, referenceType, [parcelable.reference.pointer]));
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r"writeToParcel",
    r"(Landroid/os/Parcel;I)V",
  );

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _id_writeToParcel(this, const jni.jvoidType(),
        [parcel.reference.pointer, jni.JValueInt(i)]);
  }
}

final class $View_BaseSavedStateType extends jni.JObjType<View_BaseSavedState> {
  const $View_BaseSavedStateType();

  @override
  String get signature => r"Landroid/view/View$BaseSavedState;";

  @override
  View_BaseSavedState fromReference(jni.JReference reference) =>
      View_BaseSavedState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_BaseSavedStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_BaseSavedStateType) &&
        other is $View_BaseSavedStateType;
  }
}

/// from: android.view.View$DragShadowBuilder
class View_DragShadowBuilder extends jni.JObject {
  @override
  late final jni.JObjType<View_DragShadowBuilder> $type = type;

  View_DragShadowBuilder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$DragShadowBuilder");

  /// The type which includes information such as the signature of this class.
  static const type = $View_DragShadowBuilderType();
  static final _id_new0 = _class.constructorId(
    r"(Landroid/view/View;)V",
  );

  /// from: public void <init>(android.view.View view)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_DragShadowBuilder(
    View view,
  ) {
    return View_DragShadowBuilder.fromReference(
        _id_new0(_class, referenceType, [view.reference.pointer]));
  }

  static final _id_new1 = _class.constructorId(
    r"()V",
  );

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory View_DragShadowBuilder.new1() {
    return View_DragShadowBuilder.fromReference(
        _id_new1(_class, referenceType, []));
  }

  static final _id_getView = _class.instanceMethodId(
    r"getView",
    r"()Landroid/view/View;",
  );

  /// from: public final android.view.View getView()
  /// The returned object must be released after use, by calling the [release] method.
  View getView() {
    return _id_getView(this, const $ViewType(), []);
  }

  static final _id_onProvideShadowMetrics = _class.instanceMethodId(
    r"onProvideShadowMetrics",
    r"(Landroid/graphics/Point;Landroid/graphics/Point;)V",
  );

  /// from: public void onProvideShadowMetrics(android.graphics.Point point, android.graphics.Point point1)
  void onProvideShadowMetrics(
    jni.JObject point,
    jni.JObject point1,
  ) {
    _id_onProvideShadowMetrics(this, const jni.jvoidType(),
        [point.reference.pointer, point1.reference.pointer]);
  }

  static final _id_onDrawShadow = _class.instanceMethodId(
    r"onDrawShadow",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: public void onDrawShadow(android.graphics.Canvas canvas)
  void onDrawShadow(
    jni.JObject canvas,
  ) {
    _id_onDrawShadow(this, const jni.jvoidType(), [canvas.reference.pointer]);
  }
}

final class $View_DragShadowBuilderType
    extends jni.JObjType<View_DragShadowBuilder> {
  const $View_DragShadowBuilderType();

  @override
  String get signature => r"Landroid/view/View$DragShadowBuilder;";

  @override
  View_DragShadowBuilder fromReference(jni.JReference reference) =>
      View_DragShadowBuilder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_DragShadowBuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_DragShadowBuilderType) &&
        other is $View_DragShadowBuilderType;
  }
}

/// from: android.view.View$MeasureSpec
class View_MeasureSpec extends jni.JObject {
  @override
  late final jni.JObjType<View_MeasureSpec> $type = type;

  View_MeasureSpec.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"android/view/View$MeasureSpec");

  /// The type which includes information such as the signature of this class.
  static const type = $View_MeasureSpecType();

  /// from: static public final int AT_MOST
  static const AT_MOST = -2147483648;

  /// from: static public final int EXACTLY
  static const EXACTLY = 1073741824;

  /// from: static public final int UNSPECIFIED
  static const UNSPECIFIED = 0;
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory View_MeasureSpec() {
    return View_MeasureSpec.fromReference(_id_new0(_class, referenceType, []));
  }

  static final _id_makeMeasureSpec = _class.staticMethodId(
    r"makeMeasureSpec",
    r"(II)I",
  );

  /// from: static public int makeMeasureSpec(int i, int i1)
  static int makeMeasureSpec(
    int i,
    int i1,
  ) {
    return _id_makeMeasureSpec(
        _class, const jni.jintType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_getMode = _class.staticMethodId(
    r"getMode",
    r"(I)I",
  );

  /// from: static public int getMode(int i)
  static int getMode(
    int i,
  ) {
    return _id_getMode(_class, const jni.jintType(), [jni.JValueInt(i)]);
  }

  static final _id_getSize = _class.staticMethodId(
    r"getSize",
    r"(I)I",
  );

  /// from: static public int getSize(int i)
  static int getSize(
    int i,
  ) {
    return _id_getSize(_class, const jni.jintType(), [jni.JValueInt(i)]);
  }

  static final _id_toString1 = _class.staticMethodId(
    r"toString",
    r"(I)Ljava/lang/String;",
  );

  /// from: static public java.lang.String toString(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString toString1(
    int i,
  ) {
    return _id_toString1(_class, const jni.JStringType(), [jni.JValueInt(i)]);
  }
}

final class $View_MeasureSpecType extends jni.JObjType<View_MeasureSpec> {
  const $View_MeasureSpecType();

  @override
  String get signature => r"Landroid/view/View$MeasureSpec;";

  @override
  View_MeasureSpec fromReference(jni.JReference reference) =>
      View_MeasureSpec.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_MeasureSpecType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_MeasureSpecType) &&
        other is $View_MeasureSpecType;
  }
}

/// from: android.view.View$OnApplyWindowInsetsListener
class View_OnApplyWindowInsetsListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnApplyWindowInsetsListener> $type = type;

  View_OnApplyWindowInsetsListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnApplyWindowInsetsListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnApplyWindowInsetsListenerType();
  static final _id_onApplyWindowInsets = _class.instanceMethodId(
    r"onApplyWindowInsets",
    r"(Landroid/view/View;Landroid/view/WindowInsets;)Landroid/view/WindowInsets;",
  );

  /// from: public abstract android.view.WindowInsets onApplyWindowInsets(android.view.View view, android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onApplyWindowInsets(
    View view,
    jni.JObject windowInsets,
  ) {
    return _id_onApplyWindowInsets(this, const jni.JObjectType(),
        [view.reference.pointer, windowInsets.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnApplyWindowInsetsListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onApplyWindowInsets(Landroid/view/View;Landroid/view/WindowInsets;)Landroid/view/WindowInsets;") {
        final $r = _$impls[$p]!.onApplyWindowInsets(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnApplyWindowInsetsListener.implement(
    $View_OnApplyWindowInsetsListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnApplyWindowInsetsListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnApplyWindowInsetsListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnApplyWindowInsetsListenerImpl {
  factory $View_OnApplyWindowInsetsListenerImpl({
    required jni.JObject Function(View view, jni.JObject windowInsets)
        onApplyWindowInsets,
  }) = _$View_OnApplyWindowInsetsListenerImpl;

  jni.JObject onApplyWindowInsets(View view, jni.JObject windowInsets);
}

class _$View_OnApplyWindowInsetsListenerImpl
    implements $View_OnApplyWindowInsetsListenerImpl {
  _$View_OnApplyWindowInsetsListenerImpl({
    required jni.JObject Function(View view, jni.JObject windowInsets)
        onApplyWindowInsets,
  }) : _onApplyWindowInsets = onApplyWindowInsets;

  final jni.JObject Function(View view, jni.JObject windowInsets)
      _onApplyWindowInsets;

  jni.JObject onApplyWindowInsets(View view, jni.JObject windowInsets) {
    return _onApplyWindowInsets(view, windowInsets);
  }
}

final class $View_OnApplyWindowInsetsListenerType
    extends jni.JObjType<View_OnApplyWindowInsetsListener> {
  const $View_OnApplyWindowInsetsListenerType();

  @override
  String get signature => r"Landroid/view/View$OnApplyWindowInsetsListener;";

  @override
  View_OnApplyWindowInsetsListener fromReference(jni.JReference reference) =>
      View_OnApplyWindowInsetsListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnApplyWindowInsetsListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnApplyWindowInsetsListenerType) &&
        other is $View_OnApplyWindowInsetsListenerType;
  }
}

/// from: android.view.View$OnAttachStateChangeListener
class View_OnAttachStateChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnAttachStateChangeListener> $type = type;

  View_OnAttachStateChangeListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnAttachStateChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnAttachStateChangeListenerType();
  static final _id_onViewAttachedToWindow = _class.instanceMethodId(
    r"onViewAttachedToWindow",
    r"(Landroid/view/View;)V",
  );

  /// from: public abstract void onViewAttachedToWindow(android.view.View view)
  void onViewAttachedToWindow(
    View view,
  ) {
    _id_onViewAttachedToWindow(
        this, const jni.jvoidType(), [view.reference.pointer]);
  }

  static final _id_onViewDetachedFromWindow = _class.instanceMethodId(
    r"onViewDetachedFromWindow",
    r"(Landroid/view/View;)V",
  );

  /// from: public abstract void onViewDetachedFromWindow(android.view.View view)
  void onViewDetachedFromWindow(
    View view,
  ) {
    _id_onViewDetachedFromWindow(
        this, const jni.jvoidType(), [view.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnAttachStateChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onViewAttachedToWindow(Landroid/view/View;)V") {
        _$impls[$p]!.onViewAttachedToWindow(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onViewDetachedFromWindow(Landroid/view/View;)V") {
        _$impls[$p]!.onViewDetachedFromWindow(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnAttachStateChangeListener.implement(
    $View_OnAttachStateChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnAttachStateChangeListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnAttachStateChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnAttachStateChangeListenerImpl {
  factory $View_OnAttachStateChangeListenerImpl({
    required void Function(View view) onViewAttachedToWindow,
    required void Function(View view) onViewDetachedFromWindow,
  }) = _$View_OnAttachStateChangeListenerImpl;

  void onViewAttachedToWindow(View view);
  void onViewDetachedFromWindow(View view);
}

class _$View_OnAttachStateChangeListenerImpl
    implements $View_OnAttachStateChangeListenerImpl {
  _$View_OnAttachStateChangeListenerImpl({
    required void Function(View view) onViewAttachedToWindow,
    required void Function(View view) onViewDetachedFromWindow,
  })  : _onViewAttachedToWindow = onViewAttachedToWindow,
        _onViewDetachedFromWindow = onViewDetachedFromWindow;

  final void Function(View view) _onViewAttachedToWindow;
  final void Function(View view) _onViewDetachedFromWindow;

  void onViewAttachedToWindow(View view) {
    return _onViewAttachedToWindow(view);
  }

  void onViewDetachedFromWindow(View view) {
    return _onViewDetachedFromWindow(view);
  }
}

final class $View_OnAttachStateChangeListenerType
    extends jni.JObjType<View_OnAttachStateChangeListener> {
  const $View_OnAttachStateChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnAttachStateChangeListener;";

  @override
  View_OnAttachStateChangeListener fromReference(jni.JReference reference) =>
      View_OnAttachStateChangeListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnAttachStateChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnAttachStateChangeListenerType) &&
        other is $View_OnAttachStateChangeListenerType;
  }
}

/// from: android.view.View$OnCapturedPointerListener
class View_OnCapturedPointerListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnCapturedPointerListener> $type = type;

  View_OnCapturedPointerListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnCapturedPointerListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnCapturedPointerListenerType();
  static final _id_onCapturedPointer = _class.instanceMethodId(
    r"onCapturedPointer",
    r"(Landroid/view/View;Landroid/view/MotionEvent;)Z",
  );

  /// from: public abstract boolean onCapturedPointer(android.view.View view, android.view.MotionEvent motionEvent)
  bool onCapturedPointer(
    View view,
    jni.JObject motionEvent,
  ) {
    return _id_onCapturedPointer(this, const jni.jbooleanType(),
        [view.reference.pointer, motionEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnCapturedPointerListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onCapturedPointer(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onCapturedPointer(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnCapturedPointerListener.implement(
    $View_OnCapturedPointerListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnCapturedPointerListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnCapturedPointerListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnCapturedPointerListenerImpl {
  factory $View_OnCapturedPointerListenerImpl({
    required bool Function(View view, jni.JObject motionEvent)
        onCapturedPointer,
  }) = _$View_OnCapturedPointerListenerImpl;

  bool onCapturedPointer(View view, jni.JObject motionEvent);
}

class _$View_OnCapturedPointerListenerImpl
    implements $View_OnCapturedPointerListenerImpl {
  _$View_OnCapturedPointerListenerImpl({
    required bool Function(View view, jni.JObject motionEvent)
        onCapturedPointer,
  }) : _onCapturedPointer = onCapturedPointer;

  final bool Function(View view, jni.JObject motionEvent) _onCapturedPointer;

  bool onCapturedPointer(View view, jni.JObject motionEvent) {
    return _onCapturedPointer(view, motionEvent);
  }
}

final class $View_OnCapturedPointerListenerType
    extends jni.JObjType<View_OnCapturedPointerListener> {
  const $View_OnCapturedPointerListenerType();

  @override
  String get signature => r"Landroid/view/View$OnCapturedPointerListener;";

  @override
  View_OnCapturedPointerListener fromReference(jni.JReference reference) =>
      View_OnCapturedPointerListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnCapturedPointerListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnCapturedPointerListenerType) &&
        other is $View_OnCapturedPointerListenerType;
  }
}

/// from: android.view.View$OnClickListener
class View_OnClickListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnClickListener> $type = type;

  View_OnClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnClickListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnClickListenerType();
  static final _id_onClick = _class.instanceMethodId(
    r"onClick",
    r"(Landroid/view/View;)V",
  );

  /// from: public abstract void onClick(android.view.View view)
  void onClick(
    View view,
  ) {
    _id_onClick(this, const jni.jvoidType(), [view.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onClick(Landroid/view/View;)V") {
        _$impls[$p]!.onClick(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnClickListener.implement(
    $View_OnClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnClickListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnClickListenerImpl {
  factory $View_OnClickListenerImpl({
    required void Function(View view) onClick,
  }) = _$View_OnClickListenerImpl;

  void onClick(View view);
}

class _$View_OnClickListenerImpl implements $View_OnClickListenerImpl {
  _$View_OnClickListenerImpl({
    required void Function(View view) onClick,
  }) : _onClick = onClick;

  final void Function(View view) _onClick;

  void onClick(View view) {
    return _onClick(view);
  }
}

final class $View_OnClickListenerType
    extends jni.JObjType<View_OnClickListener> {
  const $View_OnClickListenerType();

  @override
  String get signature => r"Landroid/view/View$OnClickListener;";

  @override
  View_OnClickListener fromReference(jni.JReference reference) =>
      View_OnClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnClickListenerType) &&
        other is $View_OnClickListenerType;
  }
}

/// from: android.view.View$OnContextClickListener
class View_OnContextClickListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnContextClickListener> $type = type;

  View_OnContextClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnContextClickListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnContextClickListenerType();
  static final _id_onContextClick = _class.instanceMethodId(
    r"onContextClick",
    r"(Landroid/view/View;)Z",
  );

  /// from: public abstract boolean onContextClick(android.view.View view)
  bool onContextClick(
    View view,
  ) {
    return _id_onContextClick(
        this, const jni.jbooleanType(), [view.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnContextClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onContextClick(Landroid/view/View;)Z") {
        final $r = _$impls[$p]!.onContextClick(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnContextClickListener.implement(
    $View_OnContextClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnContextClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnContextClickListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnContextClickListenerImpl {
  factory $View_OnContextClickListenerImpl({
    required bool Function(View view) onContextClick,
  }) = _$View_OnContextClickListenerImpl;

  bool onContextClick(View view);
}

class _$View_OnContextClickListenerImpl
    implements $View_OnContextClickListenerImpl {
  _$View_OnContextClickListenerImpl({
    required bool Function(View view) onContextClick,
  }) : _onContextClick = onContextClick;

  final bool Function(View view) _onContextClick;

  bool onContextClick(View view) {
    return _onContextClick(view);
  }
}

final class $View_OnContextClickListenerType
    extends jni.JObjType<View_OnContextClickListener> {
  const $View_OnContextClickListenerType();

  @override
  String get signature => r"Landroid/view/View$OnContextClickListener;";

  @override
  View_OnContextClickListener fromReference(jni.JReference reference) =>
      View_OnContextClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnContextClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnContextClickListenerType) &&
        other is $View_OnContextClickListenerType;
  }
}

/// from: android.view.View$OnCreateContextMenuListener
class View_OnCreateContextMenuListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnCreateContextMenuListener> $type = type;

  View_OnCreateContextMenuListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnCreateContextMenuListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnCreateContextMenuListenerType();
  static final _id_onCreateContextMenu = _class.instanceMethodId(
    r"onCreateContextMenu",
    r"(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu$ContextMenuInfo;)V",
  );

  /// from: public abstract void onCreateContextMenu(android.view.ContextMenu contextMenu, android.view.View view, android.view.ContextMenu$ContextMenuInfo contextMenuInfo)
  void onCreateContextMenu(
    jni.JObject contextMenu,
    View view,
    jni.JObject contextMenuInfo,
  ) {
    _id_onCreateContextMenu(this, const jni.jvoidType(), [
      contextMenu.reference.pointer,
      view.reference.pointer,
      contextMenuInfo.reference.pointer
    ]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnCreateContextMenuListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onCreateContextMenu(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu$ContextMenuInfo;)V") {
        _$impls[$p]!.onCreateContextMenu(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
          $a[1].castTo(const $ViewType(), releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnCreateContextMenuListener.implement(
    $View_OnCreateContextMenuListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnCreateContextMenuListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnCreateContextMenuListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnCreateContextMenuListenerImpl {
  factory $View_OnCreateContextMenuListenerImpl({
    required void Function(
            jni.JObject contextMenu, View view, jni.JObject contextMenuInfo)
        onCreateContextMenu,
  }) = _$View_OnCreateContextMenuListenerImpl;

  void onCreateContextMenu(
      jni.JObject contextMenu, View view, jni.JObject contextMenuInfo);
}

class _$View_OnCreateContextMenuListenerImpl
    implements $View_OnCreateContextMenuListenerImpl {
  _$View_OnCreateContextMenuListenerImpl({
    required void Function(
            jni.JObject contextMenu, View view, jni.JObject contextMenuInfo)
        onCreateContextMenu,
  }) : _onCreateContextMenu = onCreateContextMenu;

  final void Function(
          jni.JObject contextMenu, View view, jni.JObject contextMenuInfo)
      _onCreateContextMenu;

  void onCreateContextMenu(
      jni.JObject contextMenu, View view, jni.JObject contextMenuInfo) {
    return _onCreateContextMenu(contextMenu, view, contextMenuInfo);
  }
}

final class $View_OnCreateContextMenuListenerType
    extends jni.JObjType<View_OnCreateContextMenuListener> {
  const $View_OnCreateContextMenuListenerType();

  @override
  String get signature => r"Landroid/view/View$OnCreateContextMenuListener;";

  @override
  View_OnCreateContextMenuListener fromReference(jni.JReference reference) =>
      View_OnCreateContextMenuListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnCreateContextMenuListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnCreateContextMenuListenerType) &&
        other is $View_OnCreateContextMenuListenerType;
  }
}

/// from: android.view.View$OnDragListener
class View_OnDragListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnDragListener> $type = type;

  View_OnDragListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"android/view/View$OnDragListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnDragListenerType();
  static final _id_onDrag = _class.instanceMethodId(
    r"onDrag",
    r"(Landroid/view/View;Landroid/view/DragEvent;)Z",
  );

  /// from: public abstract boolean onDrag(android.view.View view, android.view.DragEvent dragEvent)
  bool onDrag(
    View view,
    jni.JObject dragEvent,
  ) {
    return _id_onDrag(this, const jni.jbooleanType(),
        [view.reference.pointer, dragEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnDragListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onDrag(Landroid/view/View;Landroid/view/DragEvent;)Z") {
        final $r = _$impls[$p]!.onDrag(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnDragListener.implement(
    $View_OnDragListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnDragListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnDragListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnDragListenerImpl {
  factory $View_OnDragListenerImpl({
    required bool Function(View view, jni.JObject dragEvent) onDrag,
  }) = _$View_OnDragListenerImpl;

  bool onDrag(View view, jni.JObject dragEvent);
}

class _$View_OnDragListenerImpl implements $View_OnDragListenerImpl {
  _$View_OnDragListenerImpl({
    required bool Function(View view, jni.JObject dragEvent) onDrag,
  }) : _onDrag = onDrag;

  final bool Function(View view, jni.JObject dragEvent) _onDrag;

  bool onDrag(View view, jni.JObject dragEvent) {
    return _onDrag(view, dragEvent);
  }
}

final class $View_OnDragListenerType extends jni.JObjType<View_OnDragListener> {
  const $View_OnDragListenerType();

  @override
  String get signature => r"Landroid/view/View$OnDragListener;";

  @override
  View_OnDragListener fromReference(jni.JReference reference) =>
      View_OnDragListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnDragListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnDragListenerType) &&
        other is $View_OnDragListenerType;
  }
}

/// from: android.view.View$OnFocusChangeListener
class View_OnFocusChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnFocusChangeListener> $type = type;

  View_OnFocusChangeListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnFocusChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnFocusChangeListenerType();
  static final _id_onFocusChange = _class.instanceMethodId(
    r"onFocusChange",
    r"(Landroid/view/View;Z)V",
  );

  /// from: public abstract void onFocusChange(android.view.View view, boolean z)
  void onFocusChange(
    View view,
    bool z,
  ) {
    _id_onFocusChange(
        this, const jni.jvoidType(), [view.reference.pointer, z ? 1 : 0]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnFocusChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFocusChange(Landroid/view/View;Z)V") {
        _$impls[$p]!.onFocusChange(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnFocusChangeListener.implement(
    $View_OnFocusChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnFocusChangeListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnFocusChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnFocusChangeListenerImpl {
  factory $View_OnFocusChangeListenerImpl({
    required void Function(View view, bool z) onFocusChange,
  }) = _$View_OnFocusChangeListenerImpl;

  void onFocusChange(View view, bool z);
}

class _$View_OnFocusChangeListenerImpl
    implements $View_OnFocusChangeListenerImpl {
  _$View_OnFocusChangeListenerImpl({
    required void Function(View view, bool z) onFocusChange,
  }) : _onFocusChange = onFocusChange;

  final void Function(View view, bool z) _onFocusChange;

  void onFocusChange(View view, bool z) {
    return _onFocusChange(view, z);
  }
}

final class $View_OnFocusChangeListenerType
    extends jni.JObjType<View_OnFocusChangeListener> {
  const $View_OnFocusChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnFocusChangeListener;";

  @override
  View_OnFocusChangeListener fromReference(jni.JReference reference) =>
      View_OnFocusChangeListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnFocusChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnFocusChangeListenerType) &&
        other is $View_OnFocusChangeListenerType;
  }
}

/// from: android.view.View$OnGenericMotionListener
class View_OnGenericMotionListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnGenericMotionListener> $type = type;

  View_OnGenericMotionListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnGenericMotionListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnGenericMotionListenerType();
  static final _id_onGenericMotion = _class.instanceMethodId(
    r"onGenericMotion",
    r"(Landroid/view/View;Landroid/view/MotionEvent;)Z",
  );

  /// from: public abstract boolean onGenericMotion(android.view.View view, android.view.MotionEvent motionEvent)
  bool onGenericMotion(
    View view,
    jni.JObject motionEvent,
  ) {
    return _id_onGenericMotion(this, const jni.jbooleanType(),
        [view.reference.pointer, motionEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnGenericMotionListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onGenericMotion(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onGenericMotion(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnGenericMotionListener.implement(
    $View_OnGenericMotionListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnGenericMotionListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnGenericMotionListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnGenericMotionListenerImpl {
  factory $View_OnGenericMotionListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onGenericMotion,
  }) = _$View_OnGenericMotionListenerImpl;

  bool onGenericMotion(View view, jni.JObject motionEvent);
}

class _$View_OnGenericMotionListenerImpl
    implements $View_OnGenericMotionListenerImpl {
  _$View_OnGenericMotionListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onGenericMotion,
  }) : _onGenericMotion = onGenericMotion;

  final bool Function(View view, jni.JObject motionEvent) _onGenericMotion;

  bool onGenericMotion(View view, jni.JObject motionEvent) {
    return _onGenericMotion(view, motionEvent);
  }
}

final class $View_OnGenericMotionListenerType
    extends jni.JObjType<View_OnGenericMotionListener> {
  const $View_OnGenericMotionListenerType();

  @override
  String get signature => r"Landroid/view/View$OnGenericMotionListener;";

  @override
  View_OnGenericMotionListener fromReference(jni.JReference reference) =>
      View_OnGenericMotionListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnGenericMotionListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnGenericMotionListenerType) &&
        other is $View_OnGenericMotionListenerType;
  }
}

/// from: android.view.View$OnHoverListener
class View_OnHoverListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnHoverListener> $type = type;

  View_OnHoverListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnHoverListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnHoverListenerType();
  static final _id_onHover = _class.instanceMethodId(
    r"onHover",
    r"(Landroid/view/View;Landroid/view/MotionEvent;)Z",
  );

  /// from: public abstract boolean onHover(android.view.View view, android.view.MotionEvent motionEvent)
  bool onHover(
    View view,
    jni.JObject motionEvent,
  ) {
    return _id_onHover(this, const jni.jbooleanType(),
        [view.reference.pointer, motionEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnHoverListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onHover(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onHover(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnHoverListener.implement(
    $View_OnHoverListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnHoverListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnHoverListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnHoverListenerImpl {
  factory $View_OnHoverListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onHover,
  }) = _$View_OnHoverListenerImpl;

  bool onHover(View view, jni.JObject motionEvent);
}

class _$View_OnHoverListenerImpl implements $View_OnHoverListenerImpl {
  _$View_OnHoverListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onHover,
  }) : _onHover = onHover;

  final bool Function(View view, jni.JObject motionEvent) _onHover;

  bool onHover(View view, jni.JObject motionEvent) {
    return _onHover(view, motionEvent);
  }
}

final class $View_OnHoverListenerType
    extends jni.JObjType<View_OnHoverListener> {
  const $View_OnHoverListenerType();

  @override
  String get signature => r"Landroid/view/View$OnHoverListener;";

  @override
  View_OnHoverListener fromReference(jni.JReference reference) =>
      View_OnHoverListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnHoverListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnHoverListenerType) &&
        other is $View_OnHoverListenerType;
  }
}

/// from: android.view.View$OnKeyListener
class View_OnKeyListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnKeyListener> $type = type;

  View_OnKeyListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"android/view/View$OnKeyListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnKeyListenerType();
  static final _id_onKey = _class.instanceMethodId(
    r"onKey",
    r"(Landroid/view/View;ILandroid/view/KeyEvent;)Z",
  );

  /// from: public abstract boolean onKey(android.view.View view, int i, android.view.KeyEvent keyEvent)
  bool onKey(
    View view,
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKey(this, const jni.jbooleanType(),
        [view.reference.pointer, jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnKeyListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onKey(Landroid/view/View;ILandroid/view/KeyEvent;)Z") {
        final $r = _$impls[$p]!.onKey(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnKeyListener.implement(
    $View_OnKeyListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnKeyListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnKeyListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnKeyListenerImpl {
  factory $View_OnKeyListenerImpl({
    required bool Function(View view, int i, jni.JObject keyEvent) onKey,
  }) = _$View_OnKeyListenerImpl;

  bool onKey(View view, int i, jni.JObject keyEvent);
}

class _$View_OnKeyListenerImpl implements $View_OnKeyListenerImpl {
  _$View_OnKeyListenerImpl({
    required bool Function(View view, int i, jni.JObject keyEvent) onKey,
  }) : _onKey = onKey;

  final bool Function(View view, int i, jni.JObject keyEvent) _onKey;

  bool onKey(View view, int i, jni.JObject keyEvent) {
    return _onKey(view, i, keyEvent);
  }
}

final class $View_OnKeyListenerType extends jni.JObjType<View_OnKeyListener> {
  const $View_OnKeyListenerType();

  @override
  String get signature => r"Landroid/view/View$OnKeyListener;";

  @override
  View_OnKeyListener fromReference(jni.JReference reference) =>
      View_OnKeyListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnKeyListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnKeyListenerType) &&
        other is $View_OnKeyListenerType;
  }
}

/// from: android.view.View$OnLayoutChangeListener
class View_OnLayoutChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnLayoutChangeListener> $type = type;

  View_OnLayoutChangeListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnLayoutChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnLayoutChangeListenerType();
  static final _id_onLayoutChange = _class.instanceMethodId(
    r"onLayoutChange",
    r"(Landroid/view/View;IIIIIIII)V",
  );

  /// from: public abstract void onLayoutChange(android.view.View view, int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
  void onLayoutChange(
    View view,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
  ) {
    _id_onLayoutChange(this, const jni.jvoidType(), [
      view.reference.pointer,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3),
      jni.JValueInt(i4),
      jni.JValueInt(i5),
      jni.JValueInt(i6),
      jni.JValueInt(i7)
    ]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnLayoutChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onLayoutChange(Landroid/view/View;IIIIIIII)V") {
        _$impls[$p]!.onLayoutChange(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[8]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnLayoutChangeListener.implement(
    $View_OnLayoutChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnLayoutChangeListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnLayoutChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnLayoutChangeListenerImpl {
  factory $View_OnLayoutChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3, int i4,
            int i5, int i6, int i7)
        onLayoutChange,
  }) = _$View_OnLayoutChangeListenerImpl;

  void onLayoutChange(
      View view, int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7);
}

class _$View_OnLayoutChangeListenerImpl
    implements $View_OnLayoutChangeListenerImpl {
  _$View_OnLayoutChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3, int i4,
            int i5, int i6, int i7)
        onLayoutChange,
  }) : _onLayoutChange = onLayoutChange;

  final void Function(View view, int i, int i1, int i2, int i3, int i4, int i5,
      int i6, int i7) _onLayoutChange;

  void onLayoutChange(View view, int i, int i1, int i2, int i3, int i4, int i5,
      int i6, int i7) {
    return _onLayoutChange(view, i, i1, i2, i3, i4, i5, i6, i7);
  }
}

final class $View_OnLayoutChangeListenerType
    extends jni.JObjType<View_OnLayoutChangeListener> {
  const $View_OnLayoutChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnLayoutChangeListener;";

  @override
  View_OnLayoutChangeListener fromReference(jni.JReference reference) =>
      View_OnLayoutChangeListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnLayoutChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnLayoutChangeListenerType) &&
        other is $View_OnLayoutChangeListenerType;
  }
}

/// from: android.view.View$OnLongClickListener
class View_OnLongClickListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnLongClickListener> $type = type;

  View_OnLongClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnLongClickListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnLongClickListenerType();
  static final _id_onLongClick = _class.instanceMethodId(
    r"onLongClick",
    r"(Landroid/view/View;)Z",
  );

  /// from: public abstract boolean onLongClick(android.view.View view)
  bool onLongClick(
    View view,
  ) {
    return _id_onLongClick(
        this, const jni.jbooleanType(), [view.reference.pointer]);
  }

  static final _id_onLongClickUseDefaultHapticFeedback =
      _class.instanceMethodId(
    r"onLongClickUseDefaultHapticFeedback",
    r"(Landroid/view/View;)Z",
  );

  /// from: public boolean onLongClickUseDefaultHapticFeedback(android.view.View view)
  bool onLongClickUseDefaultHapticFeedback(
    View view,
  ) {
    return _id_onLongClickUseDefaultHapticFeedback(
        this, const jni.jbooleanType(), [view.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnLongClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onLongClick(Landroid/view/View;)Z") {
        final $r = _$impls[$p]!.onLongClick(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"onLongClickUseDefaultHapticFeedback(Landroid/view/View;)Z") {
        final $r = _$impls[$p]!.onLongClickUseDefaultHapticFeedback(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnLongClickListener.implement(
    $View_OnLongClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnLongClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnLongClickListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnLongClickListenerImpl {
  factory $View_OnLongClickListenerImpl({
    required bool Function(View view) onLongClick,
    required bool Function(View view) onLongClickUseDefaultHapticFeedback,
  }) = _$View_OnLongClickListenerImpl;

  bool onLongClick(View view);
  bool onLongClickUseDefaultHapticFeedback(View view);
}

class _$View_OnLongClickListenerImpl implements $View_OnLongClickListenerImpl {
  _$View_OnLongClickListenerImpl({
    required bool Function(View view) onLongClick,
    required bool Function(View view) onLongClickUseDefaultHapticFeedback,
  })  : _onLongClick = onLongClick,
        _onLongClickUseDefaultHapticFeedback =
            onLongClickUseDefaultHapticFeedback;

  final bool Function(View view) _onLongClick;
  final bool Function(View view) _onLongClickUseDefaultHapticFeedback;

  bool onLongClick(View view) {
    return _onLongClick(view);
  }

  bool onLongClickUseDefaultHapticFeedback(View view) {
    return _onLongClickUseDefaultHapticFeedback(view);
  }
}

final class $View_OnLongClickListenerType
    extends jni.JObjType<View_OnLongClickListener> {
  const $View_OnLongClickListenerType();

  @override
  String get signature => r"Landroid/view/View$OnLongClickListener;";

  @override
  View_OnLongClickListener fromReference(jni.JReference reference) =>
      View_OnLongClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnLongClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnLongClickListenerType) &&
        other is $View_OnLongClickListenerType;
  }
}

/// from: android.view.View$OnScrollChangeListener
class View_OnScrollChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnScrollChangeListener> $type = type;

  View_OnScrollChangeListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnScrollChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnScrollChangeListenerType();
  static final _id_onScrollChange = _class.instanceMethodId(
    r"onScrollChange",
    r"(Landroid/view/View;IIII)V",
  );

  /// from: public abstract void onScrollChange(android.view.View view, int i, int i1, int i2, int i3)
  void onScrollChange(
    View view,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_onScrollChange(this, const jni.jvoidType(), [
      view.reference.pointer,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnScrollChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onScrollChange(Landroid/view/View;IIII)V") {
        _$impls[$p]!.onScrollChange(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnScrollChangeListener.implement(
    $View_OnScrollChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnScrollChangeListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnScrollChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnScrollChangeListenerImpl {
  factory $View_OnScrollChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3)
        onScrollChange,
  }) = _$View_OnScrollChangeListenerImpl;

  void onScrollChange(View view, int i, int i1, int i2, int i3);
}

class _$View_OnScrollChangeListenerImpl
    implements $View_OnScrollChangeListenerImpl {
  _$View_OnScrollChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3)
        onScrollChange,
  }) : _onScrollChange = onScrollChange;

  final void Function(View view, int i, int i1, int i2, int i3) _onScrollChange;

  void onScrollChange(View view, int i, int i1, int i2, int i3) {
    return _onScrollChange(view, i, i1, i2, i3);
  }
}

final class $View_OnScrollChangeListenerType
    extends jni.JObjType<View_OnScrollChangeListener> {
  const $View_OnScrollChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnScrollChangeListener;";

  @override
  View_OnScrollChangeListener fromReference(jni.JReference reference) =>
      View_OnScrollChangeListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnScrollChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnScrollChangeListenerType) &&
        other is $View_OnScrollChangeListenerType;
  }
}

/// from: android.view.View$OnSystemUiVisibilityChangeListener
class View_OnSystemUiVisibilityChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnSystemUiVisibilityChangeListener> $type = type;

  View_OnSystemUiVisibilityChangeListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"android/view/View$OnSystemUiVisibilityChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnSystemUiVisibilityChangeListenerType();
  static final _id_onSystemUiVisibilityChange = _class.instanceMethodId(
    r"onSystemUiVisibilityChange",
    r"(I)V",
  );

  /// from: public abstract void onSystemUiVisibilityChange(int i)
  void onSystemUiVisibilityChange(
    int i,
  ) {
    _id_onSystemUiVisibilityChange(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnSystemUiVisibilityChangeListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onSystemUiVisibilityChange(I)V") {
        _$impls[$p]!.onSystemUiVisibilityChange(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnSystemUiVisibilityChangeListener.implement(
    $View_OnSystemUiVisibilityChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnSystemUiVisibilityChangeListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnSystemUiVisibilityChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnSystemUiVisibilityChangeListenerImpl {
  factory $View_OnSystemUiVisibilityChangeListenerImpl({
    required void Function(int i) onSystemUiVisibilityChange,
  }) = _$View_OnSystemUiVisibilityChangeListenerImpl;

  void onSystemUiVisibilityChange(int i);
}

class _$View_OnSystemUiVisibilityChangeListenerImpl
    implements $View_OnSystemUiVisibilityChangeListenerImpl {
  _$View_OnSystemUiVisibilityChangeListenerImpl({
    required void Function(int i) onSystemUiVisibilityChange,
  }) : _onSystemUiVisibilityChange = onSystemUiVisibilityChange;

  final void Function(int i) _onSystemUiVisibilityChange;

  void onSystemUiVisibilityChange(int i) {
    return _onSystemUiVisibilityChange(i);
  }
}

final class $View_OnSystemUiVisibilityChangeListenerType
    extends jni.JObjType<View_OnSystemUiVisibilityChangeListener> {
  const $View_OnSystemUiVisibilityChangeListenerType();

  @override
  String get signature =>
      r"Landroid/view/View$OnSystemUiVisibilityChangeListener;";

  @override
  View_OnSystemUiVisibilityChangeListener fromReference(
          jni.JReference reference) =>
      View_OnSystemUiVisibilityChangeListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnSystemUiVisibilityChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($View_OnSystemUiVisibilityChangeListenerType) &&
        other is $View_OnSystemUiVisibilityChangeListenerType;
  }
}

/// from: android.view.View$OnTouchListener
class View_OnTouchListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnTouchListener> $type = type;

  View_OnTouchListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnTouchListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnTouchListenerType();
  static final _id_onTouch = _class.instanceMethodId(
    r"onTouch",
    r"(Landroid/view/View;Landroid/view/MotionEvent;)Z",
  );

  /// from: public abstract boolean onTouch(android.view.View view, android.view.MotionEvent motionEvent)
  bool onTouch(
    View view,
    jni.JObject motionEvent,
  ) {
    return _id_onTouch(this, const jni.jbooleanType(),
        [view.reference.pointer, motionEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnTouchListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onTouch(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onTouch(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnTouchListener.implement(
    $View_OnTouchListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnTouchListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnTouchListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnTouchListenerImpl {
  factory $View_OnTouchListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onTouch,
  }) = _$View_OnTouchListenerImpl;

  bool onTouch(View view, jni.JObject motionEvent);
}

class _$View_OnTouchListenerImpl implements $View_OnTouchListenerImpl {
  _$View_OnTouchListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onTouch,
  }) : _onTouch = onTouch;

  final bool Function(View view, jni.JObject motionEvent) _onTouch;

  bool onTouch(View view, jni.JObject motionEvent) {
    return _onTouch(view, motionEvent);
  }
}

final class $View_OnTouchListenerType
    extends jni.JObjType<View_OnTouchListener> {
  const $View_OnTouchListenerType();

  @override
  String get signature => r"Landroid/view/View$OnTouchListener;";

  @override
  View_OnTouchListener fromReference(jni.JReference reference) =>
      View_OnTouchListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnTouchListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnTouchListenerType) &&
        other is $View_OnTouchListenerType;
  }
}

/// from: android.view.View$OnUnhandledKeyEventListener
class View_OnUnhandledKeyEventListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnUnhandledKeyEventListener> $type = type;

  View_OnUnhandledKeyEventListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/view/View$OnUnhandledKeyEventListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnUnhandledKeyEventListenerType();
  static final _id_onUnhandledKeyEvent = _class.instanceMethodId(
    r"onUnhandledKeyEvent",
    r"(Landroid/view/View;Landroid/view/KeyEvent;)Z",
  );

  /// from: public abstract boolean onUnhandledKeyEvent(android.view.View view, android.view.KeyEvent keyEvent)
  bool onUnhandledKeyEvent(
    View view,
    jni.JObject keyEvent,
  ) {
    return _id_onUnhandledKeyEvent(this, const jni.jbooleanType(),
        [view.reference.pointer, keyEvent.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnUnhandledKeyEventListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onUnhandledKeyEvent(Landroid/view/View;Landroid/view/KeyEvent;)Z") {
        final $r = _$impls[$p]!.onUnhandledKeyEvent(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnUnhandledKeyEventListener.implement(
    $View_OnUnhandledKeyEventListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnUnhandledKeyEventListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnUnhandledKeyEventListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $View_OnUnhandledKeyEventListenerImpl {
  factory $View_OnUnhandledKeyEventListenerImpl({
    required bool Function(View view, jni.JObject keyEvent) onUnhandledKeyEvent,
  }) = _$View_OnUnhandledKeyEventListenerImpl;

  bool onUnhandledKeyEvent(View view, jni.JObject keyEvent);
}

class _$View_OnUnhandledKeyEventListenerImpl
    implements $View_OnUnhandledKeyEventListenerImpl {
  _$View_OnUnhandledKeyEventListenerImpl({
    required bool Function(View view, jni.JObject keyEvent) onUnhandledKeyEvent,
  }) : _onUnhandledKeyEvent = onUnhandledKeyEvent;

  final bool Function(View view, jni.JObject keyEvent) _onUnhandledKeyEvent;

  bool onUnhandledKeyEvent(View view, jni.JObject keyEvent) {
    return _onUnhandledKeyEvent(view, keyEvent);
  }
}

final class $View_OnUnhandledKeyEventListenerType
    extends jni.JObjType<View_OnUnhandledKeyEventListener> {
  const $View_OnUnhandledKeyEventListenerType();

  @override
  String get signature => r"Landroid/view/View$OnUnhandledKeyEventListener;";

  @override
  View_OnUnhandledKeyEventListener fromReference(jni.JReference reference) =>
      View_OnUnhandledKeyEventListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnUnhandledKeyEventListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnUnhandledKeyEventListenerType) &&
        other is $View_OnUnhandledKeyEventListenerType;
  }
}

/// from: android.view.View
class View extends jni.JObject {
  @override
  late final jni.JObjType<View> $type = type;

  View.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"android/view/View");

  /// The type which includes information such as the signature of this class.
  static const type = $ViewType();

  /// from: static public final int ACCESSIBILITY_DATA_SENSITIVE_AUTO
  static const ACCESSIBILITY_DATA_SENSITIVE_AUTO = 0;

  /// from: static public final int ACCESSIBILITY_DATA_SENSITIVE_NO
  static const ACCESSIBILITY_DATA_SENSITIVE_NO = 2;

  /// from: static public final int ACCESSIBILITY_DATA_SENSITIVE_YES
  static const ACCESSIBILITY_DATA_SENSITIVE_YES = 1;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_ASSERTIVE
  static const ACCESSIBILITY_LIVE_REGION_ASSERTIVE = 2;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_NONE
  static const ACCESSIBILITY_LIVE_REGION_NONE = 0;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_POLITE
  static const ACCESSIBILITY_LIVE_REGION_POLITE = 1;
  static final _id_ALPHA = _class.staticFieldId(
    r"ALPHA",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ALPHA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ALPHA =>
      _id_ALPHA.get(_class, const jni.JObjectType());

  /// from: static public final int AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  static const AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS = 1;
  static final _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE =
      _class.staticFieldId(
    r"AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE =>
      _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE.get(
          _class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY =
      _class.staticFieldId(
    r"AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY =>
      _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY.get(
          _class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH =
      _class.staticFieldId(
    r"AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH =>
      _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH.get(
          _class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR =
      _class.staticFieldId(
    r"AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR =>
      _id_AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR.get(
          _class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_CREDIT_CARD_NUMBER = _class.staticFieldId(
    r"AUTOFILL_HINT_CREDIT_CARD_NUMBER",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_NUMBER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_CREDIT_CARD_NUMBER =>
      _id_AUTOFILL_HINT_CREDIT_CARD_NUMBER.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE =
      _class.staticFieldId(
    r"AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE =>
      _id_AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE.get(
          _class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_EMAIL_ADDRESS = _class.staticFieldId(
    r"AUTOFILL_HINT_EMAIL_ADDRESS",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_EMAIL_ADDRESS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_EMAIL_ADDRESS =>
      _id_AUTOFILL_HINT_EMAIL_ADDRESS.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_NAME = _class.staticFieldId(
    r"AUTOFILL_HINT_NAME",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_NAME =>
      _id_AUTOFILL_HINT_NAME.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_PASSWORD = _class.staticFieldId(
    r"AUTOFILL_HINT_PASSWORD",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_PASSWORD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_PASSWORD =>
      _id_AUTOFILL_HINT_PASSWORD.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_PHONE = _class.staticFieldId(
    r"AUTOFILL_HINT_PHONE",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_PHONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_PHONE =>
      _id_AUTOFILL_HINT_PHONE.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_POSTAL_ADDRESS = _class.staticFieldId(
    r"AUTOFILL_HINT_POSTAL_ADDRESS",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_POSTAL_ADDRESS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_POSTAL_ADDRESS =>
      _id_AUTOFILL_HINT_POSTAL_ADDRESS.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_POSTAL_CODE = _class.staticFieldId(
    r"AUTOFILL_HINT_POSTAL_CODE",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_POSTAL_CODE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_POSTAL_CODE =>
      _id_AUTOFILL_HINT_POSTAL_CODE.get(_class, const jni.JStringType());

  static final _id_AUTOFILL_HINT_USERNAME = _class.staticFieldId(
    r"AUTOFILL_HINT_USERNAME",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String AUTOFILL_HINT_USERNAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTOFILL_HINT_USERNAME =>
      _id_AUTOFILL_HINT_USERNAME.get(_class, const jni.JStringType());

  /// from: static public final int AUTOFILL_TYPE_DATE
  static const AUTOFILL_TYPE_DATE = 4;

  /// from: static public final int AUTOFILL_TYPE_LIST
  static const AUTOFILL_TYPE_LIST = 3;

  /// from: static public final int AUTOFILL_TYPE_NONE
  static const AUTOFILL_TYPE_NONE = 0;

  /// from: static public final int AUTOFILL_TYPE_TEXT
  static const AUTOFILL_TYPE_TEXT = 1;

  /// from: static public final int AUTOFILL_TYPE_TOGGLE
  static const AUTOFILL_TYPE_TOGGLE = 2;

  /// from: static public final int DRAG_FLAG_ACCESSIBILITY_ACTION
  static const DRAG_FLAG_ACCESSIBILITY_ACTION = 1024;

  /// from: static public final int DRAG_FLAG_GLOBAL
  static const DRAG_FLAG_GLOBAL = 256;

  /// from: static public final int DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION = 64;

  /// from: static public final int DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION = 128;

  /// from: static public final int DRAG_FLAG_GLOBAL_URI_READ
  static const DRAG_FLAG_GLOBAL_URI_READ = 1;

  /// from: static public final int DRAG_FLAG_GLOBAL_URI_WRITE
  static const DRAG_FLAG_GLOBAL_URI_WRITE = 2;

  /// from: static public final int DRAG_FLAG_OPAQUE
  static const DRAG_FLAG_OPAQUE = 512;

  /// from: static public final int DRAWING_CACHE_QUALITY_AUTO
  static const DRAWING_CACHE_QUALITY_AUTO = 0;

  /// from: static public final int DRAWING_CACHE_QUALITY_HIGH
  static const DRAWING_CACHE_QUALITY_HIGH = 1048576;

  /// from: static public final int DRAWING_CACHE_QUALITY_LOW
  static const DRAWING_CACHE_QUALITY_LOW = 524288;
  static final _id_EMPTY_STATE_SET = _class.staticFieldId(
    r"EMPTY_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] EMPTY_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get EMPTY_STATE_SET =>
      _id_EMPTY_STATE_SET.get(_class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_FOCUSED_SELECTED_STATE_SET = _class.staticFieldId(
    r"ENABLED_FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_FOCUSED_SELECTED_STATE_SET =>
      _id_ENABLED_FOCUSED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          _id_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
              _class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_FOCUSED_STATE_SET = _class.staticFieldId(
    r"ENABLED_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_FOCUSED_STATE_SET =>
      _id_ENABLED_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      _id_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_SELECTED_STATE_SET = _class.staticFieldId(
    r"ENABLED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_SELECTED_STATE_SET =>
      _id_ENABLED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      _id_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_STATE_SET = _class.staticFieldId(
    r"ENABLED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_STATE_SET =>
      _id_ENABLED_STATE_SET.get(_class, const jni.JArrayType(jni.jintType()));

  static final _id_ENABLED_WINDOW_FOCUSED_STATE_SET = _class.staticFieldId(
    r"ENABLED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_WINDOW_FOCUSED_STATE_SET =>
      _id_ENABLED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  /// from: static public final int FIND_VIEWS_WITH_CONTENT_DESCRIPTION
  static const FIND_VIEWS_WITH_CONTENT_DESCRIPTION = 2;

  /// from: static public final int FIND_VIEWS_WITH_TEXT
  static const FIND_VIEWS_WITH_TEXT = 1;

  /// from: static public final int FOCUSABLE
  static const FOCUSABLE = 1;

  /// from: static public final int FOCUSABLES_ALL
  static const FOCUSABLES_ALL = 0;

  /// from: static public final int FOCUSABLES_TOUCH_MODE
  static const FOCUSABLES_TOUCH_MODE = 1;

  /// from: static public final int FOCUSABLE_AUTO
  static const FOCUSABLE_AUTO = 16;
  static final _id_FOCUSED_SELECTED_STATE_SET = _class.staticFieldId(
    r"FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_SELECTED_STATE_SET =>
      _id_FOCUSED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      _id_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_FOCUSED_STATE_SET = _class.staticFieldId(
    r"FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_STATE_SET =>
      _id_FOCUSED_STATE_SET.get(_class, const jni.JArrayType(jni.jintType()));

  static final _id_FOCUSED_WINDOW_FOCUSED_STATE_SET = _class.staticFieldId(
    r"FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      _id_FOCUSED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  /// from: static public final int FOCUS_BACKWARD
  static const FOCUS_BACKWARD = 1;

  /// from: static public final int FOCUS_DOWN
  static const FOCUS_DOWN = 130;

  /// from: static public final int FOCUS_FORWARD
  static const FOCUS_FORWARD = 2;

  /// from: static public final int FOCUS_LEFT
  static const FOCUS_LEFT = 17;

  /// from: static public final int FOCUS_RIGHT
  static const FOCUS_RIGHT = 66;

  /// from: static public final int FOCUS_UP
  static const FOCUS_UP = 33;

  /// from: static public final int GONE
  static const GONE = 8;

  /// from: static public final int HAPTIC_FEEDBACK_ENABLED
  static const HAPTIC_FEEDBACK_ENABLED = 268435456;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_AUTO
  static const IMPORTANT_FOR_ACCESSIBILITY_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_NO
  static const IMPORTANT_FOR_ACCESSIBILITY_NO = 2;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
  static const IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS = 4;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_YES
  static const IMPORTANT_FOR_ACCESSIBILITY_YES = 1;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_AUTO
  static const IMPORTANT_FOR_AUTOFILL_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_NO
  static const IMPORTANT_FOR_AUTOFILL_NO = 2;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS = 8;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_YES
  static const IMPORTANT_FOR_AUTOFILL_YES = 1;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_AUTO
  static const IMPORTANT_FOR_CONTENT_CAPTURE_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_NO
  static const IMPORTANT_FOR_CONTENT_CAPTURE_NO = 2;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_NO_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_CONTENT_CAPTURE_NO_EXCLUDE_DESCENDANTS = 8;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_YES
  static const IMPORTANT_FOR_CONTENT_CAPTURE_YES = 1;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_YES_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_CONTENT_CAPTURE_YES_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int INVISIBLE
  static const INVISIBLE = 4;

  /// from: static public final int KEEP_SCREEN_ON
  static const KEEP_SCREEN_ON = 67108864;

  /// from: static public final int LAYER_TYPE_HARDWARE
  static const LAYER_TYPE_HARDWARE = 2;

  /// from: static public final int LAYER_TYPE_NONE
  static const LAYER_TYPE_NONE = 0;

  /// from: static public final int LAYER_TYPE_SOFTWARE
  static const LAYER_TYPE_SOFTWARE = 1;

  /// from: static public final int LAYOUT_DIRECTION_INHERIT
  static const LAYOUT_DIRECTION_INHERIT = 2;

  /// from: static public final int LAYOUT_DIRECTION_LOCALE
  static const LAYOUT_DIRECTION_LOCALE = 3;

  /// from: static public final int LAYOUT_DIRECTION_LTR
  static const LAYOUT_DIRECTION_LTR = 0;

  /// from: static public final int LAYOUT_DIRECTION_RTL
  static const LAYOUT_DIRECTION_RTL = 1;

  /// from: static public final int MEASURED_HEIGHT_STATE_SHIFT
  static const MEASURED_HEIGHT_STATE_SHIFT = 16;

  /// from: static public final int MEASURED_SIZE_MASK
  static const MEASURED_SIZE_MASK = 16777215;

  /// from: static public final int MEASURED_STATE_MASK
  static const MEASURED_STATE_MASK = -16777216;

  /// from: static public final int MEASURED_STATE_TOO_SMALL
  static const MEASURED_STATE_TOO_SMALL = 16777216;

  /// from: static public final int NOT_FOCUSABLE
  static const NOT_FOCUSABLE = 0;

  /// from: static public final int NO_ID
  static const NO_ID = -1;

  /// from: static public final int OVER_SCROLL_ALWAYS
  static const OVER_SCROLL_ALWAYS = 0;

  /// from: static public final int OVER_SCROLL_IF_CONTENT_SCROLLS
  static const OVER_SCROLL_IF_CONTENT_SCROLLS = 1;

  /// from: static public final int OVER_SCROLL_NEVER
  static const OVER_SCROLL_NEVER = 2;
  static final _id_PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET =>
      _id_PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          _id_PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
              _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_FOCUSED_STATE_SET = _class.staticFieldId(
    r"PRESSED_ENABLED_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_FOCUSED_STATE_SET =>
      _id_PRESSED_ENABLED_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
          _id_PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET.get(
              _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_SELECTED_STATE_SET = _class.staticFieldId(
    r"PRESSED_ENABLED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_SELECTED_STATE_SET =>
      _id_PRESSED_ENABLED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          _id_PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
              _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_STATE_SET = _class.staticFieldId(
    r"PRESSED_ENABLED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_STATE_SET =>
      _id_PRESSED_ENABLED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET =>
      _id_PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_FOCUSED_SELECTED_STATE_SET = _class.staticFieldId(
    r"PRESSED_FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_FOCUSED_SELECTED_STATE_SET =>
      _id_PRESSED_FOCUSED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          _id_PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
              _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_FOCUSED_STATE_SET = _class.staticFieldId(
    r"PRESSED_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_FOCUSED_STATE_SET =>
      _id_PRESSED_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      _id_PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_SELECTED_STATE_SET = _class.staticFieldId(
    r"PRESSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_SELECTED_STATE_SET =>
      _id_PRESSED_SELECTED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      _class.staticFieldId(
    r"PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      _id_PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_STATE_SET = _class.staticFieldId(
    r"PRESSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_STATE_SET =>
      _id_PRESSED_STATE_SET.get(_class, const jni.JArrayType(jni.jintType()));

  static final _id_PRESSED_WINDOW_FOCUSED_STATE_SET = _class.staticFieldId(
    r"PRESSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_WINDOW_FOCUSED_STATE_SET =>
      _id_PRESSED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_ROTATION = _class.staticFieldId(
    r"ROTATION",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ROTATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ROTATION =>
      _id_ROTATION.get(_class, const jni.JObjectType());

  static final _id_ROTATION_X = _class.staticFieldId(
    r"ROTATION_X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ROTATION_X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ROTATION_X =>
      _id_ROTATION_X.get(_class, const jni.JObjectType());

  static final _id_ROTATION_Y = _class.staticFieldId(
    r"ROTATION_Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ROTATION_Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ROTATION_Y =>
      _id_ROTATION_Y.get(_class, const jni.JObjectType());

  static final _id_SCALE_X = _class.staticFieldId(
    r"SCALE_X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property SCALE_X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get SCALE_X =>
      _id_SCALE_X.get(_class, const jni.JObjectType());

  static final _id_SCALE_Y = _class.staticFieldId(
    r"SCALE_Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property SCALE_Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get SCALE_Y =>
      _id_SCALE_Y.get(_class, const jni.JObjectType());

  /// from: static public final int SCREEN_STATE_OFF
  static const SCREEN_STATE_OFF = 0;

  /// from: static public final int SCREEN_STATE_ON
  static const SCREEN_STATE_ON = 1;

  /// from: static public final int SCROLLBARS_INSIDE_INSET
  static const SCROLLBARS_INSIDE_INSET = 16777216;

  /// from: static public final int SCROLLBARS_INSIDE_OVERLAY
  static const SCROLLBARS_INSIDE_OVERLAY = 0;

  /// from: static public final int SCROLLBARS_OUTSIDE_INSET
  static const SCROLLBARS_OUTSIDE_INSET = 50331648;

  /// from: static public final int SCROLLBARS_OUTSIDE_OVERLAY
  static const SCROLLBARS_OUTSIDE_OVERLAY = 33554432;

  /// from: static public final int SCROLLBAR_POSITION_DEFAULT
  static const SCROLLBAR_POSITION_DEFAULT = 0;

  /// from: static public final int SCROLLBAR_POSITION_LEFT
  static const SCROLLBAR_POSITION_LEFT = 1;

  /// from: static public final int SCROLLBAR_POSITION_RIGHT
  static const SCROLLBAR_POSITION_RIGHT = 2;

  /// from: static public final int SCROLL_AXIS_HORIZONTAL
  static const SCROLL_AXIS_HORIZONTAL = 1;

  /// from: static public final int SCROLL_AXIS_NONE
  static const SCROLL_AXIS_NONE = 0;

  /// from: static public final int SCROLL_AXIS_VERTICAL
  static const SCROLL_AXIS_VERTICAL = 2;

  /// from: static public final int SCROLL_CAPTURE_HINT_AUTO
  static const SCROLL_CAPTURE_HINT_AUTO = 0;

  /// from: static public final int SCROLL_CAPTURE_HINT_EXCLUDE
  static const SCROLL_CAPTURE_HINT_EXCLUDE = 1;

  /// from: static public final int SCROLL_CAPTURE_HINT_EXCLUDE_DESCENDANTS
  static const SCROLL_CAPTURE_HINT_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int SCROLL_CAPTURE_HINT_INCLUDE
  static const SCROLL_CAPTURE_HINT_INCLUDE = 2;

  /// from: static public final int SCROLL_INDICATOR_BOTTOM
  static const SCROLL_INDICATOR_BOTTOM = 2;

  /// from: static public final int SCROLL_INDICATOR_END
  static const SCROLL_INDICATOR_END = 32;

  /// from: static public final int SCROLL_INDICATOR_LEFT
  static const SCROLL_INDICATOR_LEFT = 4;

  /// from: static public final int SCROLL_INDICATOR_RIGHT
  static const SCROLL_INDICATOR_RIGHT = 8;

  /// from: static public final int SCROLL_INDICATOR_START
  static const SCROLL_INDICATOR_START = 16;

  /// from: static public final int SCROLL_INDICATOR_TOP
  static const SCROLL_INDICATOR_TOP = 1;
  static final _id_SELECTED_STATE_SET = _class.staticFieldId(
    r"SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get SELECTED_STATE_SET =>
      _id_SELECTED_STATE_SET.get(_class, const jni.JArrayType(jni.jintType()));

  static final _id_SELECTED_WINDOW_FOCUSED_STATE_SET = _class.staticFieldId(
    r"SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get SELECTED_WINDOW_FOCUSED_STATE_SET =>
      _id_SELECTED_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  /// from: static public final int SOUND_EFFECTS_ENABLED
  static const SOUND_EFFECTS_ENABLED = 134217728;

  /// from: static public final int STATUS_BAR_HIDDEN
  static const STATUS_BAR_HIDDEN = 1;

  /// from: static public final int STATUS_BAR_VISIBLE
  static const STATUS_BAR_VISIBLE = 0;

  /// from: static public final int SYSTEM_UI_FLAG_FULLSCREEN
  static const SYSTEM_UI_FLAG_FULLSCREEN = 4;

  /// from: static public final int SYSTEM_UI_FLAG_HIDE_NAVIGATION
  static const SYSTEM_UI_FLAG_HIDE_NAVIGATION = 2;

  /// from: static public final int SYSTEM_UI_FLAG_IMMERSIVE
  static const SYSTEM_UI_FLAG_IMMERSIVE = 2048;

  /// from: static public final int SYSTEM_UI_FLAG_IMMERSIVE_STICKY
  static const SYSTEM_UI_FLAG_IMMERSIVE_STICKY = 4096;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
  static const SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN = 1024;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
  static const SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION = 512;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_STABLE
  static const SYSTEM_UI_FLAG_LAYOUT_STABLE = 256;

  /// from: static public final int SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR
  static const SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR = 16;

  /// from: static public final int SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
  static const SYSTEM_UI_FLAG_LIGHT_STATUS_BAR = 8192;

  /// from: static public final int SYSTEM_UI_FLAG_LOW_PROFILE
  static const SYSTEM_UI_FLAG_LOW_PROFILE = 1;

  /// from: static public final int SYSTEM_UI_FLAG_VISIBLE
  static const SYSTEM_UI_FLAG_VISIBLE = 0;

  /// from: static public final int SYSTEM_UI_LAYOUT_FLAGS
  static const SYSTEM_UI_LAYOUT_FLAGS = 1536;

  /// from: static public final int TEXT_ALIGNMENT_CENTER
  static const TEXT_ALIGNMENT_CENTER = 4;

  /// from: static public final int TEXT_ALIGNMENT_GRAVITY
  static const TEXT_ALIGNMENT_GRAVITY = 1;

  /// from: static public final int TEXT_ALIGNMENT_INHERIT
  static const TEXT_ALIGNMENT_INHERIT = 0;

  /// from: static public final int TEXT_ALIGNMENT_TEXT_END
  static const TEXT_ALIGNMENT_TEXT_END = 3;

  /// from: static public final int TEXT_ALIGNMENT_TEXT_START
  static const TEXT_ALIGNMENT_TEXT_START = 2;

  /// from: static public final int TEXT_ALIGNMENT_VIEW_END
  static const TEXT_ALIGNMENT_VIEW_END = 6;

  /// from: static public final int TEXT_ALIGNMENT_VIEW_START
  static const TEXT_ALIGNMENT_VIEW_START = 5;

  /// from: static public final int TEXT_DIRECTION_ANY_RTL
  static const TEXT_DIRECTION_ANY_RTL = 2;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG
  static const TEXT_DIRECTION_FIRST_STRONG = 1;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG_LTR
  static const TEXT_DIRECTION_FIRST_STRONG_LTR = 6;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG_RTL
  static const TEXT_DIRECTION_FIRST_STRONG_RTL = 7;

  /// from: static public final int TEXT_DIRECTION_INHERIT
  static const TEXT_DIRECTION_INHERIT = 0;

  /// from: static public final int TEXT_DIRECTION_LOCALE
  static const TEXT_DIRECTION_LOCALE = 5;

  /// from: static public final int TEXT_DIRECTION_LTR
  static const TEXT_DIRECTION_LTR = 3;

  /// from: static public final int TEXT_DIRECTION_RTL
  static const TEXT_DIRECTION_RTL = 4;
  static final _id_TRANSLATION_X = _class.staticFieldId(
    r"TRANSLATION_X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property TRANSLATION_X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get TRANSLATION_X =>
      _id_TRANSLATION_X.get(_class, const jni.JObjectType());

  static final _id_TRANSLATION_Y = _class.staticFieldId(
    r"TRANSLATION_Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property TRANSLATION_Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get TRANSLATION_Y =>
      _id_TRANSLATION_Y.get(_class, const jni.JObjectType());

  static final _id_TRANSLATION_Z = _class.staticFieldId(
    r"TRANSLATION_Z",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property TRANSLATION_Z
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get TRANSLATION_Z =>
      _id_TRANSLATION_Z.get(_class, const jni.JObjectType());

  static final _id_VIEW_LOG_TAG = _class.staticFieldId(
    r"VIEW_LOG_TAG",
    r"Ljava/lang/String;",
  );

  /// from: static protected final java.lang.String VIEW_LOG_TAG
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VIEW_LOG_TAG =>
      _id_VIEW_LOG_TAG.get(_class, const jni.JStringType());

  /// from: static public final int VISIBLE
  static const VISIBLE = 0;
  static final _id_WINDOW_FOCUSED_STATE_SET = _class.staticFieldId(
    r"WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get WINDOW_FOCUSED_STATE_SET =>
      _id_WINDOW_FOCUSED_STATE_SET.get(
          _class, const jni.JArrayType(jni.jintType()));

  static final _id_X = _class.staticFieldId(
    r"X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get X => _id_X.get(_class, const jni.JObjectType());

  static final _id_Y = _class.staticFieldId(
    r"Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get Y => _id_Y.get(_class, const jni.JObjectType());

  static final _id_Z = _class.staticFieldId(
    r"Z",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property Z
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get Z => _id_Z.get(_class, const jni.JObjectType());

  static final _id_new0 = _class.constructorId(
    r"(Landroid/content/Context;)V",
  );

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory View(
    jni.JObject context,
  ) {
    return View.fromReference(
        _id_new0(_class, referenceType, [context.reference.pointer]));
  }

  static final _id_new1 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  factory View.new1(
    jni.JObject context,
    jni.JObject attributeSet,
  ) {
    return View.fromReference(_id_new1(_class, referenceType,
        [context.reference.pointer, attributeSet.reference.pointer]));
  }

  static final _id_new2 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;I)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory View.new2(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
  ) {
    return View.fromReference(_id_new2(_class, referenceType, [
      context.reference.pointer,
      attributeSet.reference.pointer,
      jni.JValueInt(i)
    ]));
  }

  static final _id_new3 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;II)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory View.new3(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    int i1,
  ) {
    return View.fromReference(_id_new3(_class, referenceType, [
      context.reference.pointer,
      attributeSet.reference.pointer,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]));
  }

  static final _id_getAttributeResolutionStack = _class.instanceMethodId(
    r"getAttributeResolutionStack",
    r"(I)[I",
  );

  /// from: public int[] getAttributeResolutionStack(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getAttributeResolutionStack(
    int i,
  ) {
    return _id_getAttributeResolutionStack(
        this, const jni.JArrayType(jni.jintType()), [jni.JValueInt(i)]);
  }

  static final _id_getAttributeSourceResourceMap = _class.instanceMethodId(
    r"getAttributeSourceResourceMap",
    r"()Ljava/util/Map;",
  );

  /// from: public java.util.Map getAttributeSourceResourceMap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JInteger, jni.JInteger> getAttributeSourceResourceMap() {
    return _id_getAttributeSourceResourceMap(
        this, const jni.JMapType(jni.JIntegerType(), jni.JIntegerType()), []);
  }

  static final _id_getExplicitStyle = _class.instanceMethodId(
    r"getExplicitStyle",
    r"()I",
  );

  /// from: public int getExplicitStyle()
  int getExplicitStyle() {
    return _id_getExplicitStyle(this, const jni.jintType(), []);
  }

  static final _id_isShowingLayoutBounds = _class.instanceMethodId(
    r"isShowingLayoutBounds",
    r"()Z",
  );

  /// from: public final boolean isShowingLayoutBounds()
  bool isShowingLayoutBounds() {
    return _id_isShowingLayoutBounds(this, const jni.jbooleanType(), []);
  }

  static final _id_saveAttributeDataForStyleable = _class.instanceMethodId(
    r"saveAttributeDataForStyleable",
    r"(Landroid/content/Context;[ILandroid/util/AttributeSet;Landroid/content/res/TypedArray;II)V",
  );

  /// from: public final void saveAttributeDataForStyleable(android.content.Context context, int[] is, android.util.AttributeSet attributeSet, android.content.res.TypedArray typedArray, int i, int i1)
  void saveAttributeDataForStyleable(
    jni.JObject context,
    jni.JArray<jni.jint> is0,
    jni.JObject attributeSet,
    jni.JObject typedArray,
    int i,
    int i1,
  ) {
    _id_saveAttributeDataForStyleable(this, const jni.jvoidType(), [
      context.reference.pointer,
      is0.reference.pointer,
      attributeSet.reference.pointer,
      typedArray.reference.pointer,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]);
  }

  static final _id_toString1 = _class.instanceMethodId(
    r"toString",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _id_toString1(this, const jni.JStringType(), []);
  }

  static final _id_getVerticalFadingEdgeLength = _class.instanceMethodId(
    r"getVerticalFadingEdgeLength",
    r"()I",
  );

  /// from: public int getVerticalFadingEdgeLength()
  int getVerticalFadingEdgeLength() {
    return _id_getVerticalFadingEdgeLength(this, const jni.jintType(), []);
  }

  static final _id_setFadingEdgeLength = _class.instanceMethodId(
    r"setFadingEdgeLength",
    r"(I)V",
  );

  /// from: public void setFadingEdgeLength(int i)
  void setFadingEdgeLength(
    int i,
  ) {
    _id_setFadingEdgeLength(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getHorizontalFadingEdgeLength = _class.instanceMethodId(
    r"getHorizontalFadingEdgeLength",
    r"()I",
  );

  /// from: public int getHorizontalFadingEdgeLength()
  int getHorizontalFadingEdgeLength() {
    return _id_getHorizontalFadingEdgeLength(this, const jni.jintType(), []);
  }

  static final _id_getVerticalScrollbarWidth = _class.instanceMethodId(
    r"getVerticalScrollbarWidth",
    r"()I",
  );

  /// from: public int getVerticalScrollbarWidth()
  int getVerticalScrollbarWidth() {
    return _id_getVerticalScrollbarWidth(this, const jni.jintType(), []);
  }

  static final _id_getHorizontalScrollbarHeight = _class.instanceMethodId(
    r"getHorizontalScrollbarHeight",
    r"()I",
  );

  /// from: protected int getHorizontalScrollbarHeight()
  int getHorizontalScrollbarHeight() {
    return _id_getHorizontalScrollbarHeight(this, const jni.jintType(), []);
  }

  static final _id_setVerticalScrollbarThumbDrawable = _class.instanceMethodId(
    r"setVerticalScrollbarThumbDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setVerticalScrollbarThumbDrawable(android.graphics.drawable.Drawable drawable)
  void setVerticalScrollbarThumbDrawable(
    jni.JObject drawable,
  ) {
    _id_setVerticalScrollbarThumbDrawable(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_setVerticalScrollbarTrackDrawable = _class.instanceMethodId(
    r"setVerticalScrollbarTrackDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setVerticalScrollbarTrackDrawable(android.graphics.drawable.Drawable drawable)
  void setVerticalScrollbarTrackDrawable(
    jni.JObject drawable,
  ) {
    _id_setVerticalScrollbarTrackDrawable(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_setHorizontalScrollbarThumbDrawable =
      _class.instanceMethodId(
    r"setHorizontalScrollbarThumbDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setHorizontalScrollbarThumbDrawable(android.graphics.drawable.Drawable drawable)
  void setHorizontalScrollbarThumbDrawable(
    jni.JObject drawable,
  ) {
    _id_setHorizontalScrollbarThumbDrawable(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_setHorizontalScrollbarTrackDrawable =
      _class.instanceMethodId(
    r"setHorizontalScrollbarTrackDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setHorizontalScrollbarTrackDrawable(android.graphics.drawable.Drawable drawable)
  void setHorizontalScrollbarTrackDrawable(
    jni.JObject drawable,
  ) {
    _id_setHorizontalScrollbarTrackDrawable(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_getVerticalScrollbarThumbDrawable = _class.instanceMethodId(
    r"getVerticalScrollbarThumbDrawable",
    r"()Landroid/graphics/drawable/Drawable;",
  );

  /// from: public android.graphics.drawable.Drawable getVerticalScrollbarThumbDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVerticalScrollbarThumbDrawable() {
    return _id_getVerticalScrollbarThumbDrawable(
        this, const jni.JObjectType(), []);
  }

  static final _id_getVerticalScrollbarTrackDrawable = _class.instanceMethodId(
    r"getVerticalScrollbarTrackDrawable",
    r"()Landroid/graphics/drawable/Drawable;",
  );

  /// from: public android.graphics.drawable.Drawable getVerticalScrollbarTrackDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVerticalScrollbarTrackDrawable() {
    return _id_getVerticalScrollbarTrackDrawable(
        this, const jni.JObjectType(), []);
  }

  static final _id_getHorizontalScrollbarThumbDrawable =
      _class.instanceMethodId(
    r"getHorizontalScrollbarThumbDrawable",
    r"()Landroid/graphics/drawable/Drawable;",
  );

  /// from: public android.graphics.drawable.Drawable getHorizontalScrollbarThumbDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHorizontalScrollbarThumbDrawable() {
    return _id_getHorizontalScrollbarThumbDrawable(
        this, const jni.JObjectType(), []);
  }

  static final _id_getHorizontalScrollbarTrackDrawable =
      _class.instanceMethodId(
    r"getHorizontalScrollbarTrackDrawable",
    r"()Landroid/graphics/drawable/Drawable;",
  );

  /// from: public android.graphics.drawable.Drawable getHorizontalScrollbarTrackDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHorizontalScrollbarTrackDrawable() {
    return _id_getHorizontalScrollbarTrackDrawable(
        this, const jni.JObjectType(), []);
  }

  static final _id_setVerticalScrollbarPosition = _class.instanceMethodId(
    r"setVerticalScrollbarPosition",
    r"(I)V",
  );

  /// from: public void setVerticalScrollbarPosition(int i)
  void setVerticalScrollbarPosition(
    int i,
  ) {
    _id_setVerticalScrollbarPosition(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getVerticalScrollbarPosition = _class.instanceMethodId(
    r"getVerticalScrollbarPosition",
    r"()I",
  );

  /// from: public int getVerticalScrollbarPosition()
  int getVerticalScrollbarPosition() {
    return _id_getVerticalScrollbarPosition(this, const jni.jintType(), []);
  }

  static final _id_setScrollIndicators = _class.instanceMethodId(
    r"setScrollIndicators",
    r"(I)V",
  );

  /// from: public void setScrollIndicators(int i)
  void setScrollIndicators(
    int i,
  ) {
    _id_setScrollIndicators(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setScrollIndicators1 = _class.instanceMethodId(
    r"setScrollIndicators",
    r"(II)V",
  );

  /// from: public void setScrollIndicators(int i, int i1)
  void setScrollIndicators1(
    int i,
    int i1,
  ) {
    _id_setScrollIndicators1(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_getScrollIndicators = _class.instanceMethodId(
    r"getScrollIndicators",
    r"()I",
  );

  /// from: public int getScrollIndicators()
  int getScrollIndicators() {
    return _id_getScrollIndicators(this, const jni.jintType(), []);
  }

  static final _id_setOnScrollChangeListener = _class.instanceMethodId(
    r"setOnScrollChangeListener",
    r"(Landroid/view/View$OnScrollChangeListener;)V",
  );

  /// from: public void setOnScrollChangeListener(android.view.View$OnScrollChangeListener onScrollChangeListener)
  void setOnScrollChangeListener(
    View_OnScrollChangeListener onScrollChangeListener,
  ) {
    _id_setOnScrollChangeListener(this, const jni.jvoidType(),
        [onScrollChangeListener.reference.pointer]);
  }

  static final _id_setOnFocusChangeListener = _class.instanceMethodId(
    r"setOnFocusChangeListener",
    r"(Landroid/view/View$OnFocusChangeListener;)V",
  );

  /// from: public void setOnFocusChangeListener(android.view.View$OnFocusChangeListener onFocusChangeListener)
  void setOnFocusChangeListener(
    View_OnFocusChangeListener onFocusChangeListener,
  ) {
    _id_setOnFocusChangeListener(
        this, const jni.jvoidType(), [onFocusChangeListener.reference.pointer]);
  }

  static final _id_addOnLayoutChangeListener = _class.instanceMethodId(
    r"addOnLayoutChangeListener",
    r"(Landroid/view/View$OnLayoutChangeListener;)V",
  );

  /// from: public void addOnLayoutChangeListener(android.view.View$OnLayoutChangeListener onLayoutChangeListener)
  void addOnLayoutChangeListener(
    View_OnLayoutChangeListener onLayoutChangeListener,
  ) {
    _id_addOnLayoutChangeListener(this, const jni.jvoidType(),
        [onLayoutChangeListener.reference.pointer]);
  }

  static final _id_removeOnLayoutChangeListener = _class.instanceMethodId(
    r"removeOnLayoutChangeListener",
    r"(Landroid/view/View$OnLayoutChangeListener;)V",
  );

  /// from: public void removeOnLayoutChangeListener(android.view.View$OnLayoutChangeListener onLayoutChangeListener)
  void removeOnLayoutChangeListener(
    View_OnLayoutChangeListener onLayoutChangeListener,
  ) {
    _id_removeOnLayoutChangeListener(this, const jni.jvoidType(),
        [onLayoutChangeListener.reference.pointer]);
  }

  static final _id_addOnAttachStateChangeListener = _class.instanceMethodId(
    r"addOnAttachStateChangeListener",
    r"(Landroid/view/View$OnAttachStateChangeListener;)V",
  );

  /// from: public void addOnAttachStateChangeListener(android.view.View$OnAttachStateChangeListener onAttachStateChangeListener)
  void addOnAttachStateChangeListener(
    View_OnAttachStateChangeListener onAttachStateChangeListener,
  ) {
    _id_addOnAttachStateChangeListener(this, const jni.jvoidType(),
        [onAttachStateChangeListener.reference.pointer]);
  }

  static final _id_removeOnAttachStateChangeListener = _class.instanceMethodId(
    r"removeOnAttachStateChangeListener",
    r"(Landroid/view/View$OnAttachStateChangeListener;)V",
  );

  /// from: public void removeOnAttachStateChangeListener(android.view.View$OnAttachStateChangeListener onAttachStateChangeListener)
  void removeOnAttachStateChangeListener(
    View_OnAttachStateChangeListener onAttachStateChangeListener,
  ) {
    _id_removeOnAttachStateChangeListener(this, const jni.jvoidType(),
        [onAttachStateChangeListener.reference.pointer]);
  }

  static final _id_getOnFocusChangeListener = _class.instanceMethodId(
    r"getOnFocusChangeListener",
    r"()Landroid/view/View$OnFocusChangeListener;",
  );

  /// from: public android.view.View$OnFocusChangeListener getOnFocusChangeListener()
  /// The returned object must be released after use, by calling the [release] method.
  View_OnFocusChangeListener getOnFocusChangeListener() {
    return _id_getOnFocusChangeListener(
        this, const $View_OnFocusChangeListenerType(), []);
  }

  static final _id_setOnClickListener = _class.instanceMethodId(
    r"setOnClickListener",
    r"(Landroid/view/View$OnClickListener;)V",
  );

  /// from: public void setOnClickListener(android.view.View$OnClickListener onClickListener)
  void setOnClickListener(
    View_OnClickListener onClickListener,
  ) {
    _id_setOnClickListener(
        this, const jni.jvoidType(), [onClickListener.reference.pointer]);
  }

  static final _id_hasOnClickListeners = _class.instanceMethodId(
    r"hasOnClickListeners",
    r"()Z",
  );

  /// from: public boolean hasOnClickListeners()
  bool hasOnClickListeners() {
    return _id_hasOnClickListeners(this, const jni.jbooleanType(), []);
  }

  static final _id_setOnLongClickListener = _class.instanceMethodId(
    r"setOnLongClickListener",
    r"(Landroid/view/View$OnLongClickListener;)V",
  );

  /// from: public void setOnLongClickListener(android.view.View$OnLongClickListener onLongClickListener)
  void setOnLongClickListener(
    View_OnLongClickListener onLongClickListener,
  ) {
    _id_setOnLongClickListener(
        this, const jni.jvoidType(), [onLongClickListener.reference.pointer]);
  }

  static final _id_hasOnLongClickListeners = _class.instanceMethodId(
    r"hasOnLongClickListeners",
    r"()Z",
  );

  /// from: public boolean hasOnLongClickListeners()
  bool hasOnLongClickListeners() {
    return _id_hasOnLongClickListeners(this, const jni.jbooleanType(), []);
  }

  static final _id_setOnContextClickListener = _class.instanceMethodId(
    r"setOnContextClickListener",
    r"(Landroid/view/View$OnContextClickListener;)V",
  );

  /// from: public void setOnContextClickListener(android.view.View$OnContextClickListener onContextClickListener)
  void setOnContextClickListener(
    View_OnContextClickListener onContextClickListener,
  ) {
    _id_setOnContextClickListener(this, const jni.jvoidType(),
        [onContextClickListener.reference.pointer]);
  }

  static final _id_setOnCreateContextMenuListener = _class.instanceMethodId(
    r"setOnCreateContextMenuListener",
    r"(Landroid/view/View$OnCreateContextMenuListener;)V",
  );

  /// from: public void setOnCreateContextMenuListener(android.view.View$OnCreateContextMenuListener onCreateContextMenuListener)
  void setOnCreateContextMenuListener(
    View_OnCreateContextMenuListener onCreateContextMenuListener,
  ) {
    _id_setOnCreateContextMenuListener(this, const jni.jvoidType(),
        [onCreateContextMenuListener.reference.pointer]);
  }

  static final _id_performClick = _class.instanceMethodId(
    r"performClick",
    r"()Z",
  );

  /// from: public boolean performClick()
  bool performClick() {
    return _id_performClick(this, const jni.jbooleanType(), []);
  }

  static final _id_callOnClick = _class.instanceMethodId(
    r"callOnClick",
    r"()Z",
  );

  /// from: public boolean callOnClick()
  bool callOnClick() {
    return _id_callOnClick(this, const jni.jbooleanType(), []);
  }

  static final _id_performLongClick = _class.instanceMethodId(
    r"performLongClick",
    r"()Z",
  );

  /// from: public boolean performLongClick()
  bool performLongClick() {
    return _id_performLongClick(this, const jni.jbooleanType(), []);
  }

  static final _id_performLongClick1 = _class.instanceMethodId(
    r"performLongClick",
    r"(FF)Z",
  );

  /// from: public boolean performLongClick(float f, float f1)
  bool performLongClick1(
    double f,
    double f1,
  ) {
    return _id_performLongClick1(this, const jni.jbooleanType(),
        [jni.JValueFloat(f), jni.JValueFloat(f1)]);
  }

  static final _id_performContextClick = _class.instanceMethodId(
    r"performContextClick",
    r"(FF)Z",
  );

  /// from: public boolean performContextClick(float f, float f1)
  bool performContextClick(
    double f,
    double f1,
  ) {
    return _id_performContextClick(this, const jni.jbooleanType(),
        [jni.JValueFloat(f), jni.JValueFloat(f1)]);
  }

  static final _id_performContextClick1 = _class.instanceMethodId(
    r"performContextClick",
    r"()Z",
  );

  /// from: public boolean performContextClick()
  bool performContextClick1() {
    return _id_performContextClick1(this, const jni.jbooleanType(), []);
  }

  static final _id_showContextMenu = _class.instanceMethodId(
    r"showContextMenu",
    r"()Z",
  );

  /// from: public boolean showContextMenu()
  bool showContextMenu() {
    return _id_showContextMenu(this, const jni.jbooleanType(), []);
  }

  static final _id_showContextMenu1 = _class.instanceMethodId(
    r"showContextMenu",
    r"(FF)Z",
  );

  /// from: public boolean showContextMenu(float f, float f1)
  bool showContextMenu1(
    double f,
    double f1,
  ) {
    return _id_showContextMenu1(this, const jni.jbooleanType(),
        [jni.JValueFloat(f), jni.JValueFloat(f1)]);
  }

  static final _id_startActionMode = _class.instanceMethodId(
    r"startActionMode",
    r"(Landroid/view/ActionMode$Callback;)Landroid/view/ActionMode;",
  );

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode$Callback callback)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startActionMode(
    jni.JObject callback,
  ) {
    return _id_startActionMode(
        this, const jni.JObjectType(), [callback.reference.pointer]);
  }

  static final _id_startActionMode1 = _class.instanceMethodId(
    r"startActionMode",
    r"(Landroid/view/ActionMode$Callback;I)Landroid/view/ActionMode;",
  );

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode$Callback callback, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startActionMode1(
    jni.JObject callback,
    int i,
  ) {
    return _id_startActionMode1(this, const jni.JObjectType(),
        [callback.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_setOnKeyListener = _class.instanceMethodId(
    r"setOnKeyListener",
    r"(Landroid/view/View$OnKeyListener;)V",
  );

  /// from: public void setOnKeyListener(android.view.View$OnKeyListener onKeyListener)
  void setOnKeyListener(
    View_OnKeyListener onKeyListener,
  ) {
    _id_setOnKeyListener(
        this, const jni.jvoidType(), [onKeyListener.reference.pointer]);
  }

  static final _id_setOnTouchListener = _class.instanceMethodId(
    r"setOnTouchListener",
    r"(Landroid/view/View$OnTouchListener;)V",
  );

  /// from: public void setOnTouchListener(android.view.View$OnTouchListener onTouchListener)
  void setOnTouchListener(
    View_OnTouchListener onTouchListener,
  ) {
    _id_setOnTouchListener(
        this, const jni.jvoidType(), [onTouchListener.reference.pointer]);
  }

  static final _id_setOnGenericMotionListener = _class.instanceMethodId(
    r"setOnGenericMotionListener",
    r"(Landroid/view/View$OnGenericMotionListener;)V",
  );

  /// from: public void setOnGenericMotionListener(android.view.View$OnGenericMotionListener onGenericMotionListener)
  void setOnGenericMotionListener(
    View_OnGenericMotionListener onGenericMotionListener,
  ) {
    _id_setOnGenericMotionListener(this, const jni.jvoidType(),
        [onGenericMotionListener.reference.pointer]);
  }

  static final _id_setOnHoverListener = _class.instanceMethodId(
    r"setOnHoverListener",
    r"(Landroid/view/View$OnHoverListener;)V",
  );

  /// from: public void setOnHoverListener(android.view.View$OnHoverListener onHoverListener)
  void setOnHoverListener(
    View_OnHoverListener onHoverListener,
  ) {
    _id_setOnHoverListener(
        this, const jni.jvoidType(), [onHoverListener.reference.pointer]);
  }

  static final _id_setOnDragListener = _class.instanceMethodId(
    r"setOnDragListener",
    r"(Landroid/view/View$OnDragListener;)V",
  );

  /// from: public void setOnDragListener(android.view.View$OnDragListener onDragListener)
  void setOnDragListener(
    View_OnDragListener onDragListener,
  ) {
    _id_setOnDragListener(
        this, const jni.jvoidType(), [onDragListener.reference.pointer]);
  }

  static final _id_setRevealOnFocusHint = _class.instanceMethodId(
    r"setRevealOnFocusHint",
    r"(Z)V",
  );

  /// from: public final void setRevealOnFocusHint(boolean z)
  void setRevealOnFocusHint(
    bool z,
  ) {
    _id_setRevealOnFocusHint(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getRevealOnFocusHint = _class.instanceMethodId(
    r"getRevealOnFocusHint",
    r"()Z",
  );

  /// from: public final boolean getRevealOnFocusHint()
  bool getRevealOnFocusHint() {
    return _id_getRevealOnFocusHint(this, const jni.jbooleanType(), []);
  }

  static final _id_requestRectangleOnScreen = _class.instanceMethodId(
    r"requestRectangleOnScreen",
    r"(Landroid/graphics/Rect;)Z",
  );

  /// from: public boolean requestRectangleOnScreen(android.graphics.Rect rect)
  bool requestRectangleOnScreen(
    jni.JObject rect,
  ) {
    return _id_requestRectangleOnScreen(
        this, const jni.jbooleanType(), [rect.reference.pointer]);
  }

  static final _id_requestRectangleOnScreen1 = _class.instanceMethodId(
    r"requestRectangleOnScreen",
    r"(Landroid/graphics/Rect;Z)Z",
  );

  /// from: public boolean requestRectangleOnScreen(android.graphics.Rect rect, boolean z)
  bool requestRectangleOnScreen1(
    jni.JObject rect,
    bool z,
  ) {
    return _id_requestRectangleOnScreen1(
        this, const jni.jbooleanType(), [rect.reference.pointer, z ? 1 : 0]);
  }

  static final _id_clearFocus = _class.instanceMethodId(
    r"clearFocus",
    r"()V",
  );

  /// from: public void clearFocus()
  void clearFocus() {
    _id_clearFocus(this, const jni.jvoidType(), []);
  }

  static final _id_hasFocus = _class.instanceMethodId(
    r"hasFocus",
    r"()Z",
  );

  /// from: public boolean hasFocus()
  bool hasFocus() {
    return _id_hasFocus(this, const jni.jbooleanType(), []);
  }

  static final _id_hasFocusable = _class.instanceMethodId(
    r"hasFocusable",
    r"()Z",
  );

  /// from: public boolean hasFocusable()
  bool hasFocusable() {
    return _id_hasFocusable(this, const jni.jbooleanType(), []);
  }

  static final _id_hasExplicitFocusable = _class.instanceMethodId(
    r"hasExplicitFocusable",
    r"()Z",
  );

  /// from: public boolean hasExplicitFocusable()
  bool hasExplicitFocusable() {
    return _id_hasExplicitFocusable(this, const jni.jbooleanType(), []);
  }

  static final _id_onFocusChanged = _class.instanceMethodId(
    r"onFocusChanged",
    r"(ZILandroid/graphics/Rect;)V",
  );

  /// from: protected void onFocusChanged(boolean z, int i, android.graphics.Rect rect)
  void onFocusChanged(
    bool z,
    int i,
    jni.JObject rect,
  ) {
    _id_onFocusChanged(this, const jni.jvoidType(),
        [z ? 1 : 0, jni.JValueInt(i), rect.reference.pointer]);
  }

  static final _id_setAccessibilityPaneTitle = _class.instanceMethodId(
    r"setAccessibilityPaneTitle",
    r"(Ljava/lang/CharSequence;)V",
  );

  /// from: public void setAccessibilityPaneTitle(java.lang.CharSequence charSequence)
  void setAccessibilityPaneTitle(
    jni.JObject charSequence,
  ) {
    _id_setAccessibilityPaneTitle(
        this, const jni.jvoidType(), [charSequence.reference.pointer]);
  }

  static final _id_getAccessibilityPaneTitle = _class.instanceMethodId(
    r"getAccessibilityPaneTitle",
    r"()Ljava/lang/CharSequence;",
  );

  /// from: public java.lang.CharSequence getAccessibilityPaneTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityPaneTitle() {
    return _id_getAccessibilityPaneTitle(this, const jni.JObjectType(), []);
  }

  static final _id_sendAccessibilityEvent = _class.instanceMethodId(
    r"sendAccessibilityEvent",
    r"(I)V",
  );

  /// from: public void sendAccessibilityEvent(int i)
  void sendAccessibilityEvent(
    int i,
  ) {
    _id_sendAccessibilityEvent(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_announceForAccessibility = _class.instanceMethodId(
    r"announceForAccessibility",
    r"(Ljava/lang/CharSequence;)V",
  );

  /// from: public void announceForAccessibility(java.lang.CharSequence charSequence)
  void announceForAccessibility(
    jni.JObject charSequence,
  ) {
    _id_announceForAccessibility(
        this, const jni.jvoidType(), [charSequence.reference.pointer]);
  }

  static final _id_sendAccessibilityEventUnchecked = _class.instanceMethodId(
    r"sendAccessibilityEventUnchecked",
    r"(Landroid/view/accessibility/AccessibilityEvent;)V",
  );

  /// from: public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void sendAccessibilityEventUnchecked(
    jni.JObject accessibilityEvent,
  ) {
    _id_sendAccessibilityEventUnchecked(
        this, const jni.jvoidType(), [accessibilityEvent.reference.pointer]);
  }

  static final _id_dispatchPopulateAccessibilityEvent = _class.instanceMethodId(
    r"dispatchPopulateAccessibilityEvent",
    r"(Landroid/view/accessibility/AccessibilityEvent;)Z",
  );

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool dispatchPopulateAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    return _id_dispatchPopulateAccessibilityEvent(
        this, const jni.jbooleanType(), [accessibilityEvent.reference.pointer]);
  }

  static final _id_onPopulateAccessibilityEvent = _class.instanceMethodId(
    r"onPopulateAccessibilityEvent",
    r"(Landroid/view/accessibility/AccessibilityEvent;)V",
  );

  /// from: public void onPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onPopulateAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    _id_onPopulateAccessibilityEvent(
        this, const jni.jvoidType(), [accessibilityEvent.reference.pointer]);
  }

  static final _id_onInitializeAccessibilityEvent = _class.instanceMethodId(
    r"onInitializeAccessibilityEvent",
    r"(Landroid/view/accessibility/AccessibilityEvent;)V",
  );

  /// from: public void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onInitializeAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    _id_onInitializeAccessibilityEvent(
        this, const jni.jvoidType(), [accessibilityEvent.reference.pointer]);
  }

  static final _id_createAccessibilityNodeInfo = _class.instanceMethodId(
    r"createAccessibilityNodeInfo",
    r"()Landroid/view/accessibility/AccessibilityNodeInfo;",
  );

  /// from: public android.view.accessibility.AccessibilityNodeInfo createAccessibilityNodeInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createAccessibilityNodeInfo() {
    return _id_createAccessibilityNodeInfo(this, const jni.JObjectType(), []);
  }

  static final _id_onInitializeAccessibilityNodeInfo = _class.instanceMethodId(
    r"onInitializeAccessibilityNodeInfo",
    r"(Landroid/view/accessibility/AccessibilityNodeInfo;)V",
  );

  /// from: public void onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo)
  void onInitializeAccessibilityNodeInfo(
    jni.JObject accessibilityNodeInfo,
  ) {
    _id_onInitializeAccessibilityNodeInfo(
        this, const jni.jvoidType(), [accessibilityNodeInfo.reference.pointer]);
  }

  static final _id_getAccessibilityClassName = _class.instanceMethodId(
    r"getAccessibilityClassName",
    r"()Ljava/lang/CharSequence;",
  );

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityClassName() {
    return _id_getAccessibilityClassName(this, const jni.JObjectType(), []);
  }

  static final _id_onProvideStructure = _class.instanceMethodId(
    r"onProvideStructure",
    r"(Landroid/view/ViewStructure;)V",
  );

  /// from: public void onProvideStructure(android.view.ViewStructure viewStructure)
  void onProvideStructure(
    jni.JObject viewStructure,
  ) {
    _id_onProvideStructure(
        this, const jni.jvoidType(), [viewStructure.reference.pointer]);
  }

  static final _id_onProvideAutofillStructure = _class.instanceMethodId(
    r"onProvideAutofillStructure",
    r"(Landroid/view/ViewStructure;I)V",
  );

  /// from: public void onProvideAutofillStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideAutofillStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    _id_onProvideAutofillStructure(this, const jni.jvoidType(),
        [viewStructure.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_onProvideContentCaptureStructure = _class.instanceMethodId(
    r"onProvideContentCaptureStructure",
    r"(Landroid/view/ViewStructure;I)V",
  );

  /// from: public void onProvideContentCaptureStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideContentCaptureStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    _id_onProvideContentCaptureStructure(this, const jni.jvoidType(),
        [viewStructure.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_onProvideVirtualStructure = _class.instanceMethodId(
    r"onProvideVirtualStructure",
    r"(Landroid/view/ViewStructure;)V",
  );

  /// from: public void onProvideVirtualStructure(android.view.ViewStructure viewStructure)
  void onProvideVirtualStructure(
    jni.JObject viewStructure,
  ) {
    _id_onProvideVirtualStructure(
        this, const jni.jvoidType(), [viewStructure.reference.pointer]);
  }

  static final _id_onProvideAutofillVirtualStructure = _class.instanceMethodId(
    r"onProvideAutofillVirtualStructure",
    r"(Landroid/view/ViewStructure;I)V",
  );

  /// from: public void onProvideAutofillVirtualStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideAutofillVirtualStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    _id_onProvideAutofillVirtualStructure(this, const jni.jvoidType(),
        [viewStructure.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_setOnReceiveContentListener = _class.instanceMethodId(
    r"setOnReceiveContentListener",
    r"([Ljava/lang/String;Landroid/view/OnReceiveContentListener;)V",
  );

  /// from: public void setOnReceiveContentListener(java.lang.String[] strings, android.view.OnReceiveContentListener onReceiveContentListener)
  void setOnReceiveContentListener(
    jni.JArray<jni.JString> strings,
    jni.JObject onReceiveContentListener,
  ) {
    _id_setOnReceiveContentListener(this, const jni.jvoidType(), [
      strings.reference.pointer,
      onReceiveContentListener.reference.pointer
    ]);
  }

  static final _id_performReceiveContent = _class.instanceMethodId(
    r"performReceiveContent",
    r"(Landroid/view/ContentInfo;)Landroid/view/ContentInfo;",
  );

  /// from: public android.view.ContentInfo performReceiveContent(android.view.ContentInfo contentInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject performReceiveContent(
    jni.JObject contentInfo,
  ) {
    return _id_performReceiveContent(
        this, const jni.JObjectType(), [contentInfo.reference.pointer]);
  }

  static final _id_onReceiveContent = _class.instanceMethodId(
    r"onReceiveContent",
    r"(Landroid/view/ContentInfo;)Landroid/view/ContentInfo;",
  );

  /// from: public android.view.ContentInfo onReceiveContent(android.view.ContentInfo contentInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onReceiveContent(
    jni.JObject contentInfo,
  ) {
    return _id_onReceiveContent(
        this, const jni.JObjectType(), [contentInfo.reference.pointer]);
  }

  static final _id_getReceiveContentMimeTypes = _class.instanceMethodId(
    r"getReceiveContentMimeTypes",
    r"()[Ljava/lang/String;",
  );

  /// from: public java.lang.String[] getReceiveContentMimeTypes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getReceiveContentMimeTypes() {
    return _id_getReceiveContentMimeTypes(
        this, const jni.JArrayType(jni.JStringType()), []);
  }

  static final _id_autofill = _class.instanceMethodId(
    r"autofill",
    r"(Landroid/view/autofill/AutofillValue;)V",
  );

  /// from: public void autofill(android.view.autofill.AutofillValue autofillValue)
  void autofill(
    jni.JObject autofillValue,
  ) {
    _id_autofill(
        this, const jni.jvoidType(), [autofillValue.reference.pointer]);
  }

  static final _id_autofill1 = _class.instanceMethodId(
    r"autofill",
    r"(Landroid/util/SparseArray;)V",
  );

  /// from: public void autofill(android.util.SparseArray sparseArray)
  void autofill1(
    jni.JObject sparseArray,
  ) {
    _id_autofill1(this, const jni.jvoidType(), [sparseArray.reference.pointer]);
  }

  static final _id_getAutofillId = _class.instanceMethodId(
    r"getAutofillId",
    r"()Landroid/view/autofill/AutofillId;",
  );

  /// from: public final android.view.autofill.AutofillId getAutofillId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAutofillId() {
    return _id_getAutofillId(this, const jni.JObjectType(), []);
  }

  static final _id_setAutofillId = _class.instanceMethodId(
    r"setAutofillId",
    r"(Landroid/view/autofill/AutofillId;)V",
  );

  /// from: public void setAutofillId(android.view.autofill.AutofillId autofillId)
  void setAutofillId(
    jni.JObject autofillId,
  ) {
    _id_setAutofillId(
        this, const jni.jvoidType(), [autofillId.reference.pointer]);
  }

  static final _id_getAutofillType = _class.instanceMethodId(
    r"getAutofillType",
    r"()I",
  );

  /// from: public int getAutofillType()
  int getAutofillType() {
    return _id_getAutofillType(this, const jni.jintType(), []);
  }

  static final _id_getAutofillHints = _class.instanceMethodId(
    r"getAutofillHints",
    r"()[Ljava/lang/String;",
  );

  /// from: public java.lang.String[] getAutofillHints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getAutofillHints() {
    return _id_getAutofillHints(
        this, const jni.JArrayType(jni.JStringType()), []);
  }

  static final _id_getAutofillValue = _class.instanceMethodId(
    r"getAutofillValue",
    r"()Landroid/view/autofill/AutofillValue;",
  );

  /// from: public android.view.autofill.AutofillValue getAutofillValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAutofillValue() {
    return _id_getAutofillValue(this, const jni.JObjectType(), []);
  }

  static final _id_getImportantForAutofill = _class.instanceMethodId(
    r"getImportantForAutofill",
    r"()I",
  );

  /// from: public int getImportantForAutofill()
  int getImportantForAutofill() {
    return _id_getImportantForAutofill(this, const jni.jintType(), []);
  }

  static final _id_setImportantForAutofill = _class.instanceMethodId(
    r"setImportantForAutofill",
    r"(I)V",
  );

  /// from: public void setImportantForAutofill(int i)
  void setImportantForAutofill(
    int i,
  ) {
    _id_setImportantForAutofill(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isImportantForAutofill = _class.instanceMethodId(
    r"isImportantForAutofill",
    r"()Z",
  );

  /// from: public final boolean isImportantForAutofill()
  bool isImportantForAutofill() {
    return _id_isImportantForAutofill(this, const jni.jbooleanType(), []);
  }

  static final _id_getImportantForContentCapture = _class.instanceMethodId(
    r"getImportantForContentCapture",
    r"()I",
  );

  /// from: public int getImportantForContentCapture()
  int getImportantForContentCapture() {
    return _id_getImportantForContentCapture(this, const jni.jintType(), []);
  }

  static final _id_setImportantForContentCapture = _class.instanceMethodId(
    r"setImportantForContentCapture",
    r"(I)V",
  );

  /// from: public void setImportantForContentCapture(int i)
  void setImportantForContentCapture(
    int i,
  ) {
    _id_setImportantForContentCapture(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isImportantForContentCapture = _class.instanceMethodId(
    r"isImportantForContentCapture",
    r"()Z",
  );

  /// from: public final boolean isImportantForContentCapture()
  bool isImportantForContentCapture() {
    return _id_isImportantForContentCapture(this, const jni.jbooleanType(), []);
  }

  static final _id_setContentCaptureSession = _class.instanceMethodId(
    r"setContentCaptureSession",
    r"(Landroid/view/contentcapture/ContentCaptureSession;)V",
  );

  /// from: public void setContentCaptureSession(android.view.contentcapture.ContentCaptureSession contentCaptureSession)
  void setContentCaptureSession(
    jni.JObject contentCaptureSession,
  ) {
    _id_setContentCaptureSession(
        this, const jni.jvoidType(), [contentCaptureSession.reference.pointer]);
  }

  static final _id_getContentCaptureSession = _class.instanceMethodId(
    r"getContentCaptureSession",
    r"()Landroid/view/contentcapture/ContentCaptureSession;",
  );

  /// from: public final android.view.contentcapture.ContentCaptureSession getContentCaptureSession()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentCaptureSession() {
    return _id_getContentCaptureSession(this, const jni.JObjectType(), []);
  }

  static final _id_dispatchProvideStructure = _class.instanceMethodId(
    r"dispatchProvideStructure",
    r"(Landroid/view/ViewStructure;)V",
  );

  /// from: public void dispatchProvideStructure(android.view.ViewStructure viewStructure)
  void dispatchProvideStructure(
    jni.JObject viewStructure,
  ) {
    _id_dispatchProvideStructure(
        this, const jni.jvoidType(), [viewStructure.reference.pointer]);
  }

  static final _id_dispatchProvideAutofillStructure = _class.instanceMethodId(
    r"dispatchProvideAutofillStructure",
    r"(Landroid/view/ViewStructure;I)V",
  );

  /// from: public void dispatchProvideAutofillStructure(android.view.ViewStructure viewStructure, int i)
  void dispatchProvideAutofillStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    _id_dispatchProvideAutofillStructure(this, const jni.jvoidType(),
        [viewStructure.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_addExtraDataToAccessibilityNodeInfo =
      _class.instanceMethodId(
    r"addExtraDataToAccessibilityNodeInfo",
    r"(Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V",
  );

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo, java.lang.String string, android.os.Bundle bundle)
  void addExtraDataToAccessibilityNodeInfo(
    jni.JObject accessibilityNodeInfo,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _id_addExtraDataToAccessibilityNodeInfo(this, const jni.jvoidType(), [
      accessibilityNodeInfo.reference.pointer,
      string.reference.pointer,
      bundle.reference.pointer
    ]);
  }

  static final _id_isVisibleToUserForAutofill = _class.instanceMethodId(
    r"isVisibleToUserForAutofill",
    r"(I)Z",
  );

  /// from: public boolean isVisibleToUserForAutofill(int i)
  bool isVisibleToUserForAutofill(
    int i,
  ) {
    return _id_isVisibleToUserForAutofill(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_getAccessibilityDelegate = _class.instanceMethodId(
    r"getAccessibilityDelegate",
    r"()Landroid/view/View$AccessibilityDelegate;",
  );

  /// from: public android.view.View$AccessibilityDelegate getAccessibilityDelegate()
  /// The returned object must be released after use, by calling the [release] method.
  View_AccessibilityDelegate getAccessibilityDelegate() {
    return _id_getAccessibilityDelegate(
        this, const $View_AccessibilityDelegateType(), []);
  }

  static final _id_setAccessibilityDelegate = _class.instanceMethodId(
    r"setAccessibilityDelegate",
    r"(Landroid/view/View$AccessibilityDelegate;)V",
  );

  /// from: public void setAccessibilityDelegate(android.view.View$AccessibilityDelegate accessibilityDelegate)
  void setAccessibilityDelegate(
    View_AccessibilityDelegate accessibilityDelegate,
  ) {
    _id_setAccessibilityDelegate(
        this, const jni.jvoidType(), [accessibilityDelegate.reference.pointer]);
  }

  static final _id_getAccessibilityNodeProvider = _class.instanceMethodId(
    r"getAccessibilityNodeProvider",
    r"()Landroid/view/accessibility/AccessibilityNodeProvider;",
  );

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityNodeProvider() {
    return _id_getAccessibilityNodeProvider(this, const jni.JObjectType(), []);
  }

  static final _id_getStateDescription = _class.instanceMethodId(
    r"getStateDescription",
    r"()Ljava/lang/CharSequence;",
  );

  /// from: public final java.lang.CharSequence getStateDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getStateDescription() {
    return _id_getStateDescription(this, const jni.JObjectType(), []);
  }

  static final _id_getContentDescription = _class.instanceMethodId(
    r"getContentDescription",
    r"()Ljava/lang/CharSequence;",
  );

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentDescription() {
    return _id_getContentDescription(this, const jni.JObjectType(), []);
  }

  static final _id_setStateDescription = _class.instanceMethodId(
    r"setStateDescription",
    r"(Ljava/lang/CharSequence;)V",
  );

  /// from: public void setStateDescription(java.lang.CharSequence charSequence)
  void setStateDescription(
    jni.JObject charSequence,
  ) {
    _id_setStateDescription(
        this, const jni.jvoidType(), [charSequence.reference.pointer]);
  }

  static final _id_setContentDescription = _class.instanceMethodId(
    r"setContentDescription",
    r"(Ljava/lang/CharSequence;)V",
  );

  /// from: public void setContentDescription(java.lang.CharSequence charSequence)
  void setContentDescription(
    jni.JObject charSequence,
  ) {
    _id_setContentDescription(
        this, const jni.jvoidType(), [charSequence.reference.pointer]);
  }

  static final _id_setAccessibilityTraversalBefore = _class.instanceMethodId(
    r"setAccessibilityTraversalBefore",
    r"(I)V",
  );

  /// from: public void setAccessibilityTraversalBefore(int i)
  void setAccessibilityTraversalBefore(
    int i,
  ) {
    _id_setAccessibilityTraversalBefore(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getAccessibilityTraversalBefore = _class.instanceMethodId(
    r"getAccessibilityTraversalBefore",
    r"()I",
  );

  /// from: public int getAccessibilityTraversalBefore()
  int getAccessibilityTraversalBefore() {
    return _id_getAccessibilityTraversalBefore(this, const jni.jintType(), []);
  }

  static final _id_setAccessibilityTraversalAfter = _class.instanceMethodId(
    r"setAccessibilityTraversalAfter",
    r"(I)V",
  );

  /// from: public void setAccessibilityTraversalAfter(int i)
  void setAccessibilityTraversalAfter(
    int i,
  ) {
    _id_setAccessibilityTraversalAfter(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getAccessibilityTraversalAfter = _class.instanceMethodId(
    r"getAccessibilityTraversalAfter",
    r"()I",
  );

  /// from: public int getAccessibilityTraversalAfter()
  int getAccessibilityTraversalAfter() {
    return _id_getAccessibilityTraversalAfter(this, const jni.jintType(), []);
  }

  static final _id_getLabelFor = _class.instanceMethodId(
    r"getLabelFor",
    r"()I",
  );

  /// from: public int getLabelFor()
  int getLabelFor() {
    return _id_getLabelFor(this, const jni.jintType(), []);
  }

  static final _id_setLabelFor = _class.instanceMethodId(
    r"setLabelFor",
    r"(I)V",
  );

  /// from: public void setLabelFor(int i)
  void setLabelFor(
    int i,
  ) {
    _id_setLabelFor(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isFocused = _class.instanceMethodId(
    r"isFocused",
    r"()Z",
  );

  /// from: public boolean isFocused()
  bool isFocused() {
    return _id_isFocused(this, const jni.jbooleanType(), []);
  }

  static final _id_findFocus = _class.instanceMethodId(
    r"findFocus",
    r"()Landroid/view/View;",
  );

  /// from: public android.view.View findFocus()
  /// The returned object must be released after use, by calling the [release] method.
  View findFocus() {
    return _id_findFocus(this, const $ViewType(), []);
  }

  static final _id_isScrollContainer = _class.instanceMethodId(
    r"isScrollContainer",
    r"()Z",
  );

  /// from: public boolean isScrollContainer()
  bool isScrollContainer() {
    return _id_isScrollContainer(this, const jni.jbooleanType(), []);
  }

  static final _id_setScrollContainer = _class.instanceMethodId(
    r"setScrollContainer",
    r"(Z)V",
  );

  /// from: public void setScrollContainer(boolean z)
  void setScrollContainer(
    bool z,
  ) {
    _id_setScrollContainer(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getDrawingCacheQuality = _class.instanceMethodId(
    r"getDrawingCacheQuality",
    r"()I",
  );

  /// from: public int getDrawingCacheQuality()
  int getDrawingCacheQuality() {
    return _id_getDrawingCacheQuality(this, const jni.jintType(), []);
  }

  static final _id_setDrawingCacheQuality = _class.instanceMethodId(
    r"setDrawingCacheQuality",
    r"(I)V",
  );

  /// from: public void setDrawingCacheQuality(int i)
  void setDrawingCacheQuality(
    int i,
  ) {
    _id_setDrawingCacheQuality(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getKeepScreenOn = _class.instanceMethodId(
    r"getKeepScreenOn",
    r"()Z",
  );

  /// from: public boolean getKeepScreenOn()
  bool getKeepScreenOn() {
    return _id_getKeepScreenOn(this, const jni.jbooleanType(), []);
  }

  static final _id_setKeepScreenOn = _class.instanceMethodId(
    r"setKeepScreenOn",
    r"(Z)V",
  );

  /// from: public void setKeepScreenOn(boolean z)
  void setKeepScreenOn(
    bool z,
  ) {
    _id_setKeepScreenOn(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getNextFocusLeftId = _class.instanceMethodId(
    r"getNextFocusLeftId",
    r"()I",
  );

  /// from: public int getNextFocusLeftId()
  int getNextFocusLeftId() {
    return _id_getNextFocusLeftId(this, const jni.jintType(), []);
  }

  static final _id_setNextFocusLeftId = _class.instanceMethodId(
    r"setNextFocusLeftId",
    r"(I)V",
  );

  /// from: public void setNextFocusLeftId(int i)
  void setNextFocusLeftId(
    int i,
  ) {
    _id_setNextFocusLeftId(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getNextFocusRightId = _class.instanceMethodId(
    r"getNextFocusRightId",
    r"()I",
  );

  /// from: public int getNextFocusRightId()
  int getNextFocusRightId() {
    return _id_getNextFocusRightId(this, const jni.jintType(), []);
  }

  static final _id_setNextFocusRightId = _class.instanceMethodId(
    r"setNextFocusRightId",
    r"(I)V",
  );

  /// from: public void setNextFocusRightId(int i)
  void setNextFocusRightId(
    int i,
  ) {
    _id_setNextFocusRightId(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getNextFocusUpId = _class.instanceMethodId(
    r"getNextFocusUpId",
    r"()I",
  );

  /// from: public int getNextFocusUpId()
  int getNextFocusUpId() {
    return _id_getNextFocusUpId(this, const jni.jintType(), []);
  }

  static final _id_setNextFocusUpId = _class.instanceMethodId(
    r"setNextFocusUpId",
    r"(I)V",
  );

  /// from: public void setNextFocusUpId(int i)
  void setNextFocusUpId(
    int i,
  ) {
    _id_setNextFocusUpId(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getNextFocusDownId = _class.instanceMethodId(
    r"getNextFocusDownId",
    r"()I",
  );

  /// from: public int getNextFocusDownId()
  int getNextFocusDownId() {
    return _id_getNextFocusDownId(this, const jni.jintType(), []);
  }

  static final _id_setNextFocusDownId = _class.instanceMethodId(
    r"setNextFocusDownId",
    r"(I)V",
  );

  /// from: public void setNextFocusDownId(int i)
  void setNextFocusDownId(
    int i,
  ) {
    _id_setNextFocusDownId(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getNextFocusForwardId = _class.instanceMethodId(
    r"getNextFocusForwardId",
    r"()I",
  );

  /// from: public int getNextFocusForwardId()
  int getNextFocusForwardId() {
    return _id_getNextFocusForwardId(this, const jni.jintType(), []);
  }

  static final _id_setNextFocusForwardId = _class.instanceMethodId(
    r"setNextFocusForwardId",
    r"(I)V",
  );

  /// from: public void setNextFocusForwardId(int i)
  void setNextFocusForwardId(
    int i,
  ) {
    _id_setNextFocusForwardId(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getNextClusterForwardId = _class.instanceMethodId(
    r"getNextClusterForwardId",
    r"()I",
  );

  /// from: public int getNextClusterForwardId()
  int getNextClusterForwardId() {
    return _id_getNextClusterForwardId(this, const jni.jintType(), []);
  }

  static final _id_setNextClusterForwardId = _class.instanceMethodId(
    r"setNextClusterForwardId",
    r"(I)V",
  );

  /// from: public void setNextClusterForwardId(int i)
  void setNextClusterForwardId(
    int i,
  ) {
    _id_setNextClusterForwardId(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isShown = _class.instanceMethodId(
    r"isShown",
    r"()Z",
  );

  /// from: public boolean isShown()
  bool isShown() {
    return _id_isShown(this, const jni.jbooleanType(), []);
  }

  static final _id_fitSystemWindows = _class.instanceMethodId(
    r"fitSystemWindows",
    r"(Landroid/graphics/Rect;)Z",
  );

  /// from: protected boolean fitSystemWindows(android.graphics.Rect rect)
  bool fitSystemWindows(
    jni.JObject rect,
  ) {
    return _id_fitSystemWindows(
        this, const jni.jbooleanType(), [rect.reference.pointer]);
  }

  static final _id_onApplyWindowInsets = _class.instanceMethodId(
    r"onApplyWindowInsets",
    r"(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;",
  );

  /// from: public android.view.WindowInsets onApplyWindowInsets(android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onApplyWindowInsets(
    jni.JObject windowInsets,
  ) {
    return _id_onApplyWindowInsets(
        this, const jni.JObjectType(), [windowInsets.reference.pointer]);
  }

  static final _id_setOnApplyWindowInsetsListener = _class.instanceMethodId(
    r"setOnApplyWindowInsetsListener",
    r"(Landroid/view/View$OnApplyWindowInsetsListener;)V",
  );

  /// from: public void setOnApplyWindowInsetsListener(android.view.View$OnApplyWindowInsetsListener onApplyWindowInsetsListener)
  void setOnApplyWindowInsetsListener(
    View_OnApplyWindowInsetsListener onApplyWindowInsetsListener,
  ) {
    _id_setOnApplyWindowInsetsListener(this, const jni.jvoidType(),
        [onApplyWindowInsetsListener.reference.pointer]);
  }

  static final _id_dispatchApplyWindowInsets = _class.instanceMethodId(
    r"dispatchApplyWindowInsets",
    r"(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;",
  );

  /// from: public android.view.WindowInsets dispatchApplyWindowInsets(android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatchApplyWindowInsets(
    jni.JObject windowInsets,
  ) {
    return _id_dispatchApplyWindowInsets(
        this, const jni.JObjectType(), [windowInsets.reference.pointer]);
  }

  static final _id_setWindowInsetsAnimationCallback = _class.instanceMethodId(
    r"setWindowInsetsAnimationCallback",
    r"(Landroid/view/WindowInsetsAnimation$Callback;)V",
  );

  /// from: public void setWindowInsetsAnimationCallback(android.view.WindowInsetsAnimation$Callback callback)
  void setWindowInsetsAnimationCallback(
    jni.JObject callback,
  ) {
    _id_setWindowInsetsAnimationCallback(
        this, const jni.jvoidType(), [callback.reference.pointer]);
  }

  static final _id_dispatchWindowInsetsAnimationPrepare =
      _class.instanceMethodId(
    r"dispatchWindowInsetsAnimationPrepare",
    r"(Landroid/view/WindowInsetsAnimation;)V",
  );

  /// from: public void dispatchWindowInsetsAnimationPrepare(android.view.WindowInsetsAnimation windowInsetsAnimation)
  void dispatchWindowInsetsAnimationPrepare(
    jni.JObject windowInsetsAnimation,
  ) {
    _id_dispatchWindowInsetsAnimationPrepare(
        this, const jni.jvoidType(), [windowInsetsAnimation.reference.pointer]);
  }

  static final _id_dispatchWindowInsetsAnimationStart = _class.instanceMethodId(
    r"dispatchWindowInsetsAnimationStart",
    r"(Landroid/view/WindowInsetsAnimation;Landroid/view/WindowInsetsAnimation$Bounds;)Landroid/view/WindowInsetsAnimation$Bounds;",
  );

  /// from: public android.view.WindowInsetsAnimation$Bounds dispatchWindowInsetsAnimationStart(android.view.WindowInsetsAnimation windowInsetsAnimation, android.view.WindowInsetsAnimation$Bounds bounds)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatchWindowInsetsAnimationStart(
    jni.JObject windowInsetsAnimation,
    jni.JObject bounds,
  ) {
    return _id_dispatchWindowInsetsAnimationStart(this, const jni.JObjectType(),
        [windowInsetsAnimation.reference.pointer, bounds.reference.pointer]);
  }

  static final _id_dispatchWindowInsetsAnimationProgress =
      _class.instanceMethodId(
    r"dispatchWindowInsetsAnimationProgress",
    r"(Landroid/view/WindowInsets;Ljava/util/List;)Landroid/view/WindowInsets;",
  );

  /// from: public android.view.WindowInsets dispatchWindowInsetsAnimationProgress(android.view.WindowInsets windowInsets, java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatchWindowInsetsAnimationProgress(
    jni.JObject windowInsets,
    jni.JList<jni.JObject> list,
  ) {
    return _id_dispatchWindowInsetsAnimationProgress(
        this,
        const jni.JObjectType(),
        [windowInsets.reference.pointer, list.reference.pointer]);
  }

  static final _id_dispatchWindowInsetsAnimationEnd = _class.instanceMethodId(
    r"dispatchWindowInsetsAnimationEnd",
    r"(Landroid/view/WindowInsetsAnimation;)V",
  );

  /// from: public void dispatchWindowInsetsAnimationEnd(android.view.WindowInsetsAnimation windowInsetsAnimation)
  void dispatchWindowInsetsAnimationEnd(
    jni.JObject windowInsetsAnimation,
  ) {
    _id_dispatchWindowInsetsAnimationEnd(
        this, const jni.jvoidType(), [windowInsetsAnimation.reference.pointer]);
  }

  static final _id_setSystemGestureExclusionRects = _class.instanceMethodId(
    r"setSystemGestureExclusionRects",
    r"(Ljava/util/List;)V",
  );

  /// from: public void setSystemGestureExclusionRects(java.util.List list)
  void setSystemGestureExclusionRects(
    jni.JList<jni.JObject> list,
  ) {
    _id_setSystemGestureExclusionRects(
        this, const jni.jvoidType(), [list.reference.pointer]);
  }

  static final _id_getSystemGestureExclusionRects = _class.instanceMethodId(
    r"getSystemGestureExclusionRects",
    r"()Ljava/util/List;",
  );

  /// from: public java.util.List getSystemGestureExclusionRects()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getSystemGestureExclusionRects() {
    return _id_getSystemGestureExclusionRects(
        this, const jni.JListType(jni.JObjectType()), []);
  }

  static final _id_setPreferKeepClear = _class.instanceMethodId(
    r"setPreferKeepClear",
    r"(Z)V",
  );

  /// from: public final void setPreferKeepClear(boolean z)
  void setPreferKeepClear(
    bool z,
  ) {
    _id_setPreferKeepClear(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isPreferKeepClear = _class.instanceMethodId(
    r"isPreferKeepClear",
    r"()Z",
  );

  /// from: public final boolean isPreferKeepClear()
  bool isPreferKeepClear() {
    return _id_isPreferKeepClear(this, const jni.jbooleanType(), []);
  }

  static final _id_setPreferKeepClearRects = _class.instanceMethodId(
    r"setPreferKeepClearRects",
    r"(Ljava/util/List;)V",
  );

  /// from: public final void setPreferKeepClearRects(java.util.List list)
  void setPreferKeepClearRects(
    jni.JList<jni.JObject> list,
  ) {
    _id_setPreferKeepClearRects(
        this, const jni.jvoidType(), [list.reference.pointer]);
  }

  static final _id_getPreferKeepClearRects = _class.instanceMethodId(
    r"getPreferKeepClearRects",
    r"()Ljava/util/List;",
  );

  /// from: public final java.util.List getPreferKeepClearRects()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getPreferKeepClearRects() {
    return _id_getPreferKeepClearRects(
        this, const jni.JListType(jni.JObjectType()), []);
  }

  static final _id_setHandwritingBoundsOffsets = _class.instanceMethodId(
    r"setHandwritingBoundsOffsets",
    r"(FFFF)V",
  );

  /// from: public void setHandwritingBoundsOffsets(float f, float f1, float f2, float f3)
  void setHandwritingBoundsOffsets(
    double f,
    double f1,
    double f2,
    double f3,
  ) {
    _id_setHandwritingBoundsOffsets(this, const jni.jvoidType(), [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3)
    ]);
  }

  static final _id_getHandwritingBoundsOffsetLeft = _class.instanceMethodId(
    r"getHandwritingBoundsOffsetLeft",
    r"()F",
  );

  /// from: public float getHandwritingBoundsOffsetLeft()
  double getHandwritingBoundsOffsetLeft() {
    return _id_getHandwritingBoundsOffsetLeft(this, const jni.jfloatType(), []);
  }

  static final _id_getHandwritingBoundsOffsetTop = _class.instanceMethodId(
    r"getHandwritingBoundsOffsetTop",
    r"()F",
  );

  /// from: public float getHandwritingBoundsOffsetTop()
  double getHandwritingBoundsOffsetTop() {
    return _id_getHandwritingBoundsOffsetTop(this, const jni.jfloatType(), []);
  }

  static final _id_getHandwritingBoundsOffsetRight = _class.instanceMethodId(
    r"getHandwritingBoundsOffsetRight",
    r"()F",
  );

  /// from: public float getHandwritingBoundsOffsetRight()
  double getHandwritingBoundsOffsetRight() {
    return _id_getHandwritingBoundsOffsetRight(
        this, const jni.jfloatType(), []);
  }

  static final _id_getHandwritingBoundsOffsetBottom = _class.instanceMethodId(
    r"getHandwritingBoundsOffsetBottom",
    r"()F",
  );

  /// from: public float getHandwritingBoundsOffsetBottom()
  double getHandwritingBoundsOffsetBottom() {
    return _id_getHandwritingBoundsOffsetBottom(
        this, const jni.jfloatType(), []);
  }

  static final _id_setHandwritingDelegatorCallback = _class.instanceMethodId(
    r"setHandwritingDelegatorCallback",
    r"(Ljava/lang/Runnable;)V",
  );

  /// from: public void setHandwritingDelegatorCallback(java.lang.Runnable runnable)
  void setHandwritingDelegatorCallback(
    jni.JObject runnable,
  ) {
    _id_setHandwritingDelegatorCallback(
        this, const jni.jvoidType(), [runnable.reference.pointer]);
  }

  static final _id_getHandwritingDelegatorCallback = _class.instanceMethodId(
    r"getHandwritingDelegatorCallback",
    r"()Ljava/lang/Runnable;",
  );

  /// from: public java.lang.Runnable getHandwritingDelegatorCallback()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHandwritingDelegatorCallback() {
    return _id_getHandwritingDelegatorCallback(
        this, const jni.JObjectType(), []);
  }

  static final _id_setAllowedHandwritingDelegatePackage =
      _class.instanceMethodId(
    r"setAllowedHandwritingDelegatePackage",
    r"(Ljava/lang/String;)V",
  );

  /// from: public void setAllowedHandwritingDelegatePackage(java.lang.String string)
  void setAllowedHandwritingDelegatePackage(
    jni.JString string,
  ) {
    _id_setAllowedHandwritingDelegatePackage(
        this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_getAllowedHandwritingDelegatePackageName =
      _class.instanceMethodId(
    r"getAllowedHandwritingDelegatePackageName",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getAllowedHandwritingDelegatePackageName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAllowedHandwritingDelegatePackageName() {
    return _id_getAllowedHandwritingDelegatePackageName(
        this, const jni.JStringType(), []);
  }

  static final _id_setIsHandwritingDelegate = _class.instanceMethodId(
    r"setIsHandwritingDelegate",
    r"(Z)V",
  );

  /// from: public void setIsHandwritingDelegate(boolean z)
  void setIsHandwritingDelegate(
    bool z,
  ) {
    _id_setIsHandwritingDelegate(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isHandwritingDelegate = _class.instanceMethodId(
    r"isHandwritingDelegate",
    r"()Z",
  );

  /// from: public boolean isHandwritingDelegate()
  bool isHandwritingDelegate() {
    return _id_isHandwritingDelegate(this, const jni.jbooleanType(), []);
  }

  static final _id_setAllowedHandwritingDelegatorPackage =
      _class.instanceMethodId(
    r"setAllowedHandwritingDelegatorPackage",
    r"(Ljava/lang/String;)V",
  );

  /// from: public void setAllowedHandwritingDelegatorPackage(java.lang.String string)
  void setAllowedHandwritingDelegatorPackage(
    jni.JString string,
  ) {
    _id_setAllowedHandwritingDelegatorPackage(
        this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_getAllowedHandwritingDelegatorPackageName =
      _class.instanceMethodId(
    r"getAllowedHandwritingDelegatorPackageName",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getAllowedHandwritingDelegatorPackageName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAllowedHandwritingDelegatorPackageName() {
    return _id_getAllowedHandwritingDelegatorPackageName(
        this, const jni.JStringType(), []);
  }

  static final _id_getLocationInSurface = _class.instanceMethodId(
    r"getLocationInSurface",
    r"([I)V",
  );

  /// from: public void getLocationInSurface(int[] is)
  void getLocationInSurface(
    jni.JArray<jni.jint> is0,
  ) {
    _id_getLocationInSurface(
        this, const jni.jvoidType(), [is0.reference.pointer]);
  }

  static final _id_getRootWindowInsets = _class.instanceMethodId(
    r"getRootWindowInsets",
    r"()Landroid/view/WindowInsets;",
  );

  /// from: public android.view.WindowInsets getRootWindowInsets()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRootWindowInsets() {
    return _id_getRootWindowInsets(this, const jni.JObjectType(), []);
  }

  static final _id_getWindowInsetsController = _class.instanceMethodId(
    r"getWindowInsetsController",
    r"()Landroid/view/WindowInsetsController;",
  );

  /// from: public android.view.WindowInsetsController getWindowInsetsController()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowInsetsController() {
    return _id_getWindowInsetsController(this, const jni.JObjectType(), []);
  }

  static final _id_findOnBackInvokedDispatcher = _class.instanceMethodId(
    r"findOnBackInvokedDispatcher",
    r"()Landroid/window/OnBackInvokedDispatcher;",
  );

  /// from: public final android.window.OnBackInvokedDispatcher findOnBackInvokedDispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject findOnBackInvokedDispatcher() {
    return _id_findOnBackInvokedDispatcher(this, const jni.JObjectType(), []);
  }

  static final _id_computeSystemWindowInsets = _class.instanceMethodId(
    r"computeSystemWindowInsets",
    r"(Landroid/view/WindowInsets;Landroid/graphics/Rect;)Landroid/view/WindowInsets;",
  );

  /// from: public android.view.WindowInsets computeSystemWindowInsets(android.view.WindowInsets windowInsets, android.graphics.Rect rect)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject computeSystemWindowInsets(
    jni.JObject windowInsets,
    jni.JObject rect,
  ) {
    return _id_computeSystemWindowInsets(this, const jni.JObjectType(),
        [windowInsets.reference.pointer, rect.reference.pointer]);
  }

  static final _id_setFitsSystemWindows = _class.instanceMethodId(
    r"setFitsSystemWindows",
    r"(Z)V",
  );

  /// from: public void setFitsSystemWindows(boolean z)
  void setFitsSystemWindows(
    bool z,
  ) {
    _id_setFitsSystemWindows(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getFitsSystemWindows = _class.instanceMethodId(
    r"getFitsSystemWindows",
    r"()Z",
  );

  /// from: public boolean getFitsSystemWindows()
  bool getFitsSystemWindows() {
    return _id_getFitsSystemWindows(this, const jni.jbooleanType(), []);
  }

  static final _id_requestFitSystemWindows = _class.instanceMethodId(
    r"requestFitSystemWindows",
    r"()V",
  );

  /// from: public void requestFitSystemWindows()
  void requestFitSystemWindows() {
    _id_requestFitSystemWindows(this, const jni.jvoidType(), []);
  }

  static final _id_requestApplyInsets = _class.instanceMethodId(
    r"requestApplyInsets",
    r"()V",
  );

  /// from: public void requestApplyInsets()
  void requestApplyInsets() {
    _id_requestApplyInsets(this, const jni.jvoidType(), []);
  }

  static final _id_getVisibility = _class.instanceMethodId(
    r"getVisibility",
    r"()I",
  );

  /// from: public int getVisibility()
  int getVisibility() {
    return _id_getVisibility(this, const jni.jintType(), []);
  }

  static final _id_setVisibility = _class.instanceMethodId(
    r"setVisibility",
    r"(I)V",
  );

  /// from: public void setVisibility(int i)
  void setVisibility(
    int i,
  ) {
    _id_setVisibility(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r"isEnabled",
    r"()Z",
  );

  /// from: public boolean isEnabled()
  bool isEnabled() {
    return _id_isEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setEnabled = _class.instanceMethodId(
    r"setEnabled",
    r"(Z)V",
  );

  /// from: public void setEnabled(boolean z)
  void setEnabled(
    bool z,
  ) {
    _id_setEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setFocusable = _class.instanceMethodId(
    r"setFocusable",
    r"(Z)V",
  );

  /// from: public void setFocusable(boolean z)
  void setFocusable(
    bool z,
  ) {
    _id_setFocusable(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setFocusable1 = _class.instanceMethodId(
    r"setFocusable",
    r"(I)V",
  );

  /// from: public void setFocusable(int i)
  void setFocusable1(
    int i,
  ) {
    _id_setFocusable1(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setFocusableInTouchMode = _class.instanceMethodId(
    r"setFocusableInTouchMode",
    r"(Z)V",
  );

  /// from: public void setFocusableInTouchMode(boolean z)
  void setFocusableInTouchMode(
    bool z,
  ) {
    _id_setFocusableInTouchMode(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setAutofillHints = _class.instanceMethodId(
    r"setAutofillHints",
    r"([Ljava/lang/String;)V",
  );

  /// from: public void setAutofillHints(java.lang.String[] strings)
  void setAutofillHints(
    jni.JArray<jni.JString> strings,
  ) {
    _id_setAutofillHints(
        this, const jni.jvoidType(), [strings.reference.pointer]);
  }

  static final _id_setSoundEffectsEnabled = _class.instanceMethodId(
    r"setSoundEffectsEnabled",
    r"(Z)V",
  );

  /// from: public void setSoundEffectsEnabled(boolean z)
  void setSoundEffectsEnabled(
    bool z,
  ) {
    _id_setSoundEffectsEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isSoundEffectsEnabled = _class.instanceMethodId(
    r"isSoundEffectsEnabled",
    r"()Z",
  );

  /// from: public boolean isSoundEffectsEnabled()
  bool isSoundEffectsEnabled() {
    return _id_isSoundEffectsEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setHapticFeedbackEnabled = _class.instanceMethodId(
    r"setHapticFeedbackEnabled",
    r"(Z)V",
  );

  /// from: public void setHapticFeedbackEnabled(boolean z)
  void setHapticFeedbackEnabled(
    bool z,
  ) {
    _id_setHapticFeedbackEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isHapticFeedbackEnabled = _class.instanceMethodId(
    r"isHapticFeedbackEnabled",
    r"()Z",
  );

  /// from: public boolean isHapticFeedbackEnabled()
  bool isHapticFeedbackEnabled() {
    return _id_isHapticFeedbackEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setLayoutDirection = _class.instanceMethodId(
    r"setLayoutDirection",
    r"(I)V",
  );

  /// from: public void setLayoutDirection(int i)
  void setLayoutDirection(
    int i,
  ) {
    _id_setLayoutDirection(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getLayoutDirection = _class.instanceMethodId(
    r"getLayoutDirection",
    r"()I",
  );

  /// from: public int getLayoutDirection()
  int getLayoutDirection() {
    return _id_getLayoutDirection(this, const jni.jintType(), []);
  }

  static final _id_hasTransientState = _class.instanceMethodId(
    r"hasTransientState",
    r"()Z",
  );

  /// from: public boolean hasTransientState()
  bool hasTransientState() {
    return _id_hasTransientState(this, const jni.jbooleanType(), []);
  }

  static final _id_setHasTransientState = _class.instanceMethodId(
    r"setHasTransientState",
    r"(Z)V",
  );

  /// from: public void setHasTransientState(boolean z)
  void setHasTransientState(
    bool z,
  ) {
    _id_setHasTransientState(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isAttachedToWindow = _class.instanceMethodId(
    r"isAttachedToWindow",
    r"()Z",
  );

  /// from: public boolean isAttachedToWindow()
  bool isAttachedToWindow() {
    return _id_isAttachedToWindow(this, const jni.jbooleanType(), []);
  }

  static final _id_isLaidOut = _class.instanceMethodId(
    r"isLaidOut",
    r"()Z",
  );

  /// from: public boolean isLaidOut()
  bool isLaidOut() {
    return _id_isLaidOut(this, const jni.jbooleanType(), []);
  }

  static final _id_setWillNotDraw = _class.instanceMethodId(
    r"setWillNotDraw",
    r"(Z)V",
  );

  /// from: public void setWillNotDraw(boolean z)
  void setWillNotDraw(
    bool z,
  ) {
    _id_setWillNotDraw(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_willNotDraw = _class.instanceMethodId(
    r"willNotDraw",
    r"()Z",
  );

  /// from: public boolean willNotDraw()
  bool willNotDraw() {
    return _id_willNotDraw(this, const jni.jbooleanType(), []);
  }

  static final _id_setWillNotCacheDrawing = _class.instanceMethodId(
    r"setWillNotCacheDrawing",
    r"(Z)V",
  );

  /// from: public void setWillNotCacheDrawing(boolean z)
  void setWillNotCacheDrawing(
    bool z,
  ) {
    _id_setWillNotCacheDrawing(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_willNotCacheDrawing = _class.instanceMethodId(
    r"willNotCacheDrawing",
    r"()Z",
  );

  /// from: public boolean willNotCacheDrawing()
  bool willNotCacheDrawing() {
    return _id_willNotCacheDrawing(this, const jni.jbooleanType(), []);
  }

  static final _id_isClickable = _class.instanceMethodId(
    r"isClickable",
    r"()Z",
  );

  /// from: public boolean isClickable()
  bool isClickable() {
    return _id_isClickable(this, const jni.jbooleanType(), []);
  }

  static final _id_setClickable = _class.instanceMethodId(
    r"setClickable",
    r"(Z)V",
  );

  /// from: public void setClickable(boolean z)
  void setClickable(
    bool z,
  ) {
    _id_setClickable(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setAllowClickWhenDisabled = _class.instanceMethodId(
    r"setAllowClickWhenDisabled",
    r"(Z)V",
  );

  /// from: public void setAllowClickWhenDisabled(boolean z)
  void setAllowClickWhenDisabled(
    bool z,
  ) {
    _id_setAllowClickWhenDisabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isLongClickable = _class.instanceMethodId(
    r"isLongClickable",
    r"()Z",
  );

  /// from: public boolean isLongClickable()
  bool isLongClickable() {
    return _id_isLongClickable(this, const jni.jbooleanType(), []);
  }

  static final _id_setLongClickable = _class.instanceMethodId(
    r"setLongClickable",
    r"(Z)V",
  );

  /// from: public void setLongClickable(boolean z)
  void setLongClickable(
    bool z,
  ) {
    _id_setLongClickable(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isContextClickable = _class.instanceMethodId(
    r"isContextClickable",
    r"()Z",
  );

  /// from: public boolean isContextClickable()
  bool isContextClickable() {
    return _id_isContextClickable(this, const jni.jbooleanType(), []);
  }

  static final _id_setContextClickable = _class.instanceMethodId(
    r"setContextClickable",
    r"(Z)V",
  );

  /// from: public void setContextClickable(boolean z)
  void setContextClickable(
    bool z,
  ) {
    _id_setContextClickable(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setPressed = _class.instanceMethodId(
    r"setPressed",
    r"(Z)V",
  );

  /// from: public void setPressed(boolean z)
  void setPressed(
    bool z,
  ) {
    _id_setPressed(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_dispatchSetPressed = _class.instanceMethodId(
    r"dispatchSetPressed",
    r"(Z)V",
  );

  /// from: protected void dispatchSetPressed(boolean z)
  void dispatchSetPressed(
    bool z,
  ) {
    _id_dispatchSetPressed(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isPressed = _class.instanceMethodId(
    r"isPressed",
    r"()Z",
  );

  /// from: public boolean isPressed()
  bool isPressed() {
    return _id_isPressed(this, const jni.jbooleanType(), []);
  }

  static final _id_isSaveEnabled = _class.instanceMethodId(
    r"isSaveEnabled",
    r"()Z",
  );

  /// from: public boolean isSaveEnabled()
  bool isSaveEnabled() {
    return _id_isSaveEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setSaveEnabled = _class.instanceMethodId(
    r"setSaveEnabled",
    r"(Z)V",
  );

  /// from: public void setSaveEnabled(boolean z)
  void setSaveEnabled(
    bool z,
  ) {
    _id_setSaveEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getFilterTouchesWhenObscured = _class.instanceMethodId(
    r"getFilterTouchesWhenObscured",
    r"()Z",
  );

  /// from: public boolean getFilterTouchesWhenObscured()
  bool getFilterTouchesWhenObscured() {
    return _id_getFilterTouchesWhenObscured(this, const jni.jbooleanType(), []);
  }

  static final _id_setFilterTouchesWhenObscured = _class.instanceMethodId(
    r"setFilterTouchesWhenObscured",
    r"(Z)V",
  );

  /// from: public void setFilterTouchesWhenObscured(boolean z)
  void setFilterTouchesWhenObscured(
    bool z,
  ) {
    _id_setFilterTouchesWhenObscured(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isSaveFromParentEnabled = _class.instanceMethodId(
    r"isSaveFromParentEnabled",
    r"()Z",
  );

  /// from: public boolean isSaveFromParentEnabled()
  bool isSaveFromParentEnabled() {
    return _id_isSaveFromParentEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setSaveFromParentEnabled = _class.instanceMethodId(
    r"setSaveFromParentEnabled",
    r"(Z)V",
  );

  /// from: public void setSaveFromParentEnabled(boolean z)
  void setSaveFromParentEnabled(
    bool z,
  ) {
    _id_setSaveFromParentEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isFocusable = _class.instanceMethodId(
    r"isFocusable",
    r"()Z",
  );

  /// from: public final boolean isFocusable()
  bool isFocusable() {
    return _id_isFocusable(this, const jni.jbooleanType(), []);
  }

  static final _id_getFocusable = _class.instanceMethodId(
    r"getFocusable",
    r"()I",
  );

  /// from: public int getFocusable()
  int getFocusable() {
    return _id_getFocusable(this, const jni.jintType(), []);
  }

  static final _id_isFocusableInTouchMode = _class.instanceMethodId(
    r"isFocusableInTouchMode",
    r"()Z",
  );

  /// from: public final boolean isFocusableInTouchMode()
  bool isFocusableInTouchMode() {
    return _id_isFocusableInTouchMode(this, const jni.jbooleanType(), []);
  }

  static final _id_isScreenReaderFocusable = _class.instanceMethodId(
    r"isScreenReaderFocusable",
    r"()Z",
  );

  /// from: public boolean isScreenReaderFocusable()
  bool isScreenReaderFocusable() {
    return _id_isScreenReaderFocusable(this, const jni.jbooleanType(), []);
  }

  static final _id_setScreenReaderFocusable = _class.instanceMethodId(
    r"setScreenReaderFocusable",
    r"(Z)V",
  );

  /// from: public void setScreenReaderFocusable(boolean z)
  void setScreenReaderFocusable(
    bool z,
  ) {
    _id_setScreenReaderFocusable(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isAccessibilityHeading = _class.instanceMethodId(
    r"isAccessibilityHeading",
    r"()Z",
  );

  /// from: public boolean isAccessibilityHeading()
  bool isAccessibilityHeading() {
    return _id_isAccessibilityHeading(this, const jni.jbooleanType(), []);
  }

  static final _id_setAccessibilityHeading = _class.instanceMethodId(
    r"setAccessibilityHeading",
    r"(Z)V",
  );

  /// from: public void setAccessibilityHeading(boolean z)
  void setAccessibilityHeading(
    bool z,
  ) {
    _id_setAccessibilityHeading(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_focusSearch = _class.instanceMethodId(
    r"focusSearch",
    r"(I)Landroid/view/View;",
  );

  /// from: public android.view.View focusSearch(int i)
  /// The returned object must be released after use, by calling the [release] method.
  View focusSearch(
    int i,
  ) {
    return _id_focusSearch(this, const $ViewType(), [jni.JValueInt(i)]);
  }

  static final _id_isKeyboardNavigationCluster = _class.instanceMethodId(
    r"isKeyboardNavigationCluster",
    r"()Z",
  );

  /// from: public final boolean isKeyboardNavigationCluster()
  bool isKeyboardNavigationCluster() {
    return _id_isKeyboardNavigationCluster(this, const jni.jbooleanType(), []);
  }

  static final _id_setKeyboardNavigationCluster = _class.instanceMethodId(
    r"setKeyboardNavigationCluster",
    r"(Z)V",
  );

  /// from: public void setKeyboardNavigationCluster(boolean z)
  void setKeyboardNavigationCluster(
    bool z,
  ) {
    _id_setKeyboardNavigationCluster(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isFocusedByDefault = _class.instanceMethodId(
    r"isFocusedByDefault",
    r"()Z",
  );

  /// from: public final boolean isFocusedByDefault()
  bool isFocusedByDefault() {
    return _id_isFocusedByDefault(this, const jni.jbooleanType(), []);
  }

  static final _id_setFocusedByDefault = _class.instanceMethodId(
    r"setFocusedByDefault",
    r"(Z)V",
  );

  /// from: public void setFocusedByDefault(boolean z)
  void setFocusedByDefault(
    bool z,
  ) {
    _id_setFocusedByDefault(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_keyboardNavigationClusterSearch = _class.instanceMethodId(
    r"keyboardNavigationClusterSearch",
    r"(Landroid/view/View;I)Landroid/view/View;",
  );

  /// from: public android.view.View keyboardNavigationClusterSearch(android.view.View view, int i)
  /// The returned object must be released after use, by calling the [release] method.
  View keyboardNavigationClusterSearch(
    View view,
    int i,
  ) {
    return _id_keyboardNavigationClusterSearch(
        this, const $ViewType(), [view.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_dispatchUnhandledMove = _class.instanceMethodId(
    r"dispatchUnhandledMove",
    r"(Landroid/view/View;I)Z",
  );

  /// from: public boolean dispatchUnhandledMove(android.view.View view, int i)
  bool dispatchUnhandledMove(
    View view,
    int i,
  ) {
    return _id_dispatchUnhandledMove(this, const jni.jbooleanType(),
        [view.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_setDefaultFocusHighlightEnabled = _class.instanceMethodId(
    r"setDefaultFocusHighlightEnabled",
    r"(Z)V",
  );

  /// from: public void setDefaultFocusHighlightEnabled(boolean z)
  void setDefaultFocusHighlightEnabled(
    bool z,
  ) {
    _id_setDefaultFocusHighlightEnabled(
        this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getDefaultFocusHighlightEnabled = _class.instanceMethodId(
    r"getDefaultFocusHighlightEnabled",
    r"()Z",
  );

  /// from: public final boolean getDefaultFocusHighlightEnabled()
  bool getDefaultFocusHighlightEnabled() {
    return _id_getDefaultFocusHighlightEnabled(
        this, const jni.jbooleanType(), []);
  }

  static final _id_getFocusables = _class.instanceMethodId(
    r"getFocusables",
    r"(I)Ljava/util/ArrayList;",
  );

  /// from: public java.util.ArrayList getFocusables(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFocusables(
    int i,
  ) {
    return _id_getFocusables(this, const jni.JObjectType(), [jni.JValueInt(i)]);
  }

  static final _id_addFocusables = _class.instanceMethodId(
    r"addFocusables",
    r"(Ljava/util/ArrayList;I)V",
  );

  /// from: public void addFocusables(java.util.ArrayList arrayList, int i)
  void addFocusables(
    jni.JObject arrayList,
    int i,
  ) {
    _id_addFocusables(this, const jni.jvoidType(),
        [arrayList.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_addFocusables1 = _class.instanceMethodId(
    r"addFocusables",
    r"(Ljava/util/ArrayList;II)V",
  );

  /// from: public void addFocusables(java.util.ArrayList arrayList, int i, int i1)
  void addFocusables1(
    jni.JObject arrayList,
    int i,
    int i1,
  ) {
    _id_addFocusables1(this, const jni.jvoidType(),
        [arrayList.reference.pointer, jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_addKeyboardNavigationClusters = _class.instanceMethodId(
    r"addKeyboardNavigationClusters",
    r"(Ljava/util/Collection;I)V",
  );

  /// from: public void addKeyboardNavigationClusters(java.util.Collection collection, int i)
  void addKeyboardNavigationClusters(
    jni.JObject collection,
    int i,
  ) {
    _id_addKeyboardNavigationClusters(this, const jni.jvoidType(),
        [collection.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_findViewsWithText = _class.instanceMethodId(
    r"findViewsWithText",
    r"(Ljava/util/ArrayList;Ljava/lang/CharSequence;I)V",
  );

  /// from: public void findViewsWithText(java.util.ArrayList arrayList, java.lang.CharSequence charSequence, int i)
  void findViewsWithText(
    jni.JObject arrayList,
    jni.JObject charSequence,
    int i,
  ) {
    _id_findViewsWithText(this, const jni.jvoidType(), [
      arrayList.reference.pointer,
      charSequence.reference.pointer,
      jni.JValueInt(i)
    ]);
  }

  static final _id_getTouchables = _class.instanceMethodId(
    r"getTouchables",
    r"()Ljava/util/ArrayList;",
  );

  /// from: public java.util.ArrayList getTouchables()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTouchables() {
    return _id_getTouchables(this, const jni.JObjectType(), []);
  }

  static final _id_addTouchables = _class.instanceMethodId(
    r"addTouchables",
    r"(Ljava/util/ArrayList;)V",
  );

  /// from: public void addTouchables(java.util.ArrayList arrayList)
  void addTouchables(
    jni.JObject arrayList,
  ) {
    _id_addTouchables(
        this, const jni.jvoidType(), [arrayList.reference.pointer]);
  }

  static final _id_isAccessibilityFocused = _class.instanceMethodId(
    r"isAccessibilityFocused",
    r"()Z",
  );

  /// from: public boolean isAccessibilityFocused()
  bool isAccessibilityFocused() {
    return _id_isAccessibilityFocused(this, const jni.jbooleanType(), []);
  }

  static final _id_requestFocus = _class.instanceMethodId(
    r"requestFocus",
    r"()Z",
  );

  /// from: public final boolean requestFocus()
  bool requestFocus() {
    return _id_requestFocus(this, const jni.jbooleanType(), []);
  }

  static final _id_restoreDefaultFocus = _class.instanceMethodId(
    r"restoreDefaultFocus",
    r"()Z",
  );

  /// from: public boolean restoreDefaultFocus()
  bool restoreDefaultFocus() {
    return _id_restoreDefaultFocus(this, const jni.jbooleanType(), []);
  }

  static final _id_requestFocus1 = _class.instanceMethodId(
    r"requestFocus",
    r"(I)Z",
  );

  /// from: public final boolean requestFocus(int i)
  bool requestFocus1(
    int i,
  ) {
    return _id_requestFocus1(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_requestFocus2 = _class.instanceMethodId(
    r"requestFocus",
    r"(ILandroid/graphics/Rect;)Z",
  );

  /// from: public boolean requestFocus(int i, android.graphics.Rect rect)
  bool requestFocus2(
    int i,
    jni.JObject rect,
  ) {
    return _id_requestFocus2(this, const jni.jbooleanType(),
        [jni.JValueInt(i), rect.reference.pointer]);
  }

  static final _id_requestFocusFromTouch = _class.instanceMethodId(
    r"requestFocusFromTouch",
    r"()Z",
  );

  /// from: public final boolean requestFocusFromTouch()
  bool requestFocusFromTouch() {
    return _id_requestFocusFromTouch(this, const jni.jbooleanType(), []);
  }

  static final _id_getImportantForAccessibility = _class.instanceMethodId(
    r"getImportantForAccessibility",
    r"()I",
  );

  /// from: public int getImportantForAccessibility()
  int getImportantForAccessibility() {
    return _id_getImportantForAccessibility(this, const jni.jintType(), []);
  }

  static final _id_setAccessibilityLiveRegion = _class.instanceMethodId(
    r"setAccessibilityLiveRegion",
    r"(I)V",
  );

  /// from: public void setAccessibilityLiveRegion(int i)
  void setAccessibilityLiveRegion(
    int i,
  ) {
    _id_setAccessibilityLiveRegion(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getAccessibilityLiveRegion = _class.instanceMethodId(
    r"getAccessibilityLiveRegion",
    r"()I",
  );

  /// from: public int getAccessibilityLiveRegion()
  int getAccessibilityLiveRegion() {
    return _id_getAccessibilityLiveRegion(this, const jni.jintType(), []);
  }

  static final _id_setImportantForAccessibility = _class.instanceMethodId(
    r"setImportantForAccessibility",
    r"(I)V",
  );

  /// from: public void setImportantForAccessibility(int i)
  void setImportantForAccessibility(
    int i,
  ) {
    _id_setImportantForAccessibility(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isImportantForAccessibility = _class.instanceMethodId(
    r"isImportantForAccessibility",
    r"()Z",
  );

  /// from: public boolean isImportantForAccessibility()
  bool isImportantForAccessibility() {
    return _id_isImportantForAccessibility(this, const jni.jbooleanType(), []);
  }

  static final _id_getParentForAccessibility = _class.instanceMethodId(
    r"getParentForAccessibility",
    r"()Landroid/view/ViewParent;",
  );

  /// from: public android.view.ViewParent getParentForAccessibility()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getParentForAccessibility() {
    return _id_getParentForAccessibility(this, const jni.JObjectType(), []);
  }

  static final _id_addChildrenForAccessibility = _class.instanceMethodId(
    r"addChildrenForAccessibility",
    r"(Ljava/util/ArrayList;)V",
  );

  /// from: public void addChildrenForAccessibility(java.util.ArrayList arrayList)
  void addChildrenForAccessibility(
    jni.JObject arrayList,
  ) {
    _id_addChildrenForAccessibility(
        this, const jni.jvoidType(), [arrayList.reference.pointer]);
  }

  static final _id_isAccessibilityDataSensitive = _class.instanceMethodId(
    r"isAccessibilityDataSensitive",
    r"()Z",
  );

  /// from: public boolean isAccessibilityDataSensitive()
  bool isAccessibilityDataSensitive() {
    return _id_isAccessibilityDataSensitive(this, const jni.jbooleanType(), []);
  }

  static final _id_setAccessibilityDataSensitive = _class.instanceMethodId(
    r"setAccessibilityDataSensitive",
    r"(I)V",
  );

  /// from: public void setAccessibilityDataSensitive(int i)
  void setAccessibilityDataSensitive(
    int i,
  ) {
    _id_setAccessibilityDataSensitive(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setTransitionVisibility = _class.instanceMethodId(
    r"setTransitionVisibility",
    r"(I)V",
  );

  /// from: public void setTransitionVisibility(int i)
  void setTransitionVisibility(
    int i,
  ) {
    _id_setTransitionVisibility(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_dispatchNestedPrePerformAccessibilityAction =
      _class.instanceMethodId(
    r"dispatchNestedPrePerformAccessibilityAction",
    r"(ILandroid/os/Bundle;)Z",
  );

  /// from: public boolean dispatchNestedPrePerformAccessibilityAction(int i, android.os.Bundle bundle)
  bool dispatchNestedPrePerformAccessibilityAction(
    int i,
    jni.JObject bundle,
  ) {
    return _id_dispatchNestedPrePerformAccessibilityAction(this,
        const jni.jbooleanType(), [jni.JValueInt(i), bundle.reference.pointer]);
  }

  static final _id_performAccessibilityAction = _class.instanceMethodId(
    r"performAccessibilityAction",
    r"(ILandroid/os/Bundle;)Z",
  );

  /// from: public boolean performAccessibilityAction(int i, android.os.Bundle bundle)
  bool performAccessibilityAction(
    int i,
    jni.JObject bundle,
  ) {
    return _id_performAccessibilityAction(this, const jni.jbooleanType(),
        [jni.JValueInt(i), bundle.reference.pointer]);
  }

  static final _id_isTemporarilyDetached = _class.instanceMethodId(
    r"isTemporarilyDetached",
    r"()Z",
  );

  /// from: public final boolean isTemporarilyDetached()
  bool isTemporarilyDetached() {
    return _id_isTemporarilyDetached(this, const jni.jbooleanType(), []);
  }

  static final _id_dispatchStartTemporaryDetach = _class.instanceMethodId(
    r"dispatchStartTemporaryDetach",
    r"()V",
  );

  /// from: public void dispatchStartTemporaryDetach()
  void dispatchStartTemporaryDetach() {
    _id_dispatchStartTemporaryDetach(this, const jni.jvoidType(), []);
  }

  static final _id_onStartTemporaryDetach = _class.instanceMethodId(
    r"onStartTemporaryDetach",
    r"()V",
  );

  /// from: public void onStartTemporaryDetach()
  void onStartTemporaryDetach() {
    _id_onStartTemporaryDetach(this, const jni.jvoidType(), []);
  }

  static final _id_dispatchFinishTemporaryDetach = _class.instanceMethodId(
    r"dispatchFinishTemporaryDetach",
    r"()V",
  );

  /// from: public void dispatchFinishTemporaryDetach()
  void dispatchFinishTemporaryDetach() {
    _id_dispatchFinishTemporaryDetach(this, const jni.jvoidType(), []);
  }

  static final _id_onFinishTemporaryDetach = _class.instanceMethodId(
    r"onFinishTemporaryDetach",
    r"()V",
  );

  /// from: public void onFinishTemporaryDetach()
  void onFinishTemporaryDetach() {
    _id_onFinishTemporaryDetach(this, const jni.jvoidType(), []);
  }

  static final _id_getKeyDispatcherState = _class.instanceMethodId(
    r"getKeyDispatcherState",
    r"()Landroid/view/KeyEvent$DispatcherState;",
  );

  /// from: public android.view.KeyEvent$DispatcherState getKeyDispatcherState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getKeyDispatcherState() {
    return _id_getKeyDispatcherState(this, const jni.JObjectType(), []);
  }

  static final _id_dispatchKeyEventPreIme = _class.instanceMethodId(
    r"dispatchKeyEventPreIme",
    r"(Landroid/view/KeyEvent;)Z",
  );

  /// from: public boolean dispatchKeyEventPreIme(android.view.KeyEvent keyEvent)
  bool dispatchKeyEventPreIme(
    jni.JObject keyEvent,
  ) {
    return _id_dispatchKeyEventPreIme(
        this, const jni.jbooleanType(), [keyEvent.reference.pointer]);
  }

  static final _id_dispatchKeyEvent = _class.instanceMethodId(
    r"dispatchKeyEvent",
    r"(Landroid/view/KeyEvent;)Z",
  );

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyEvent(
    jni.JObject keyEvent,
  ) {
    return _id_dispatchKeyEvent(
        this, const jni.jbooleanType(), [keyEvent.reference.pointer]);
  }

  static final _id_dispatchKeyShortcutEvent = _class.instanceMethodId(
    r"dispatchKeyShortcutEvent",
    r"(Landroid/view/KeyEvent;)Z",
  );

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyShortcutEvent(
    jni.JObject keyEvent,
  ) {
    return _id_dispatchKeyShortcutEvent(
        this, const jni.jbooleanType(), [keyEvent.reference.pointer]);
  }

  static final _id_dispatchTouchEvent = _class.instanceMethodId(
    r"dispatchTouchEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent motionEvent)
  bool dispatchTouchEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchTouchEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onFilterTouchEventForSecurity = _class.instanceMethodId(
    r"onFilterTouchEventForSecurity",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onFilterTouchEventForSecurity(android.view.MotionEvent motionEvent)
  bool onFilterTouchEventForSecurity(
    jni.JObject motionEvent,
  ) {
    return _id_onFilterTouchEventForSecurity(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchTrackballEvent = _class.instanceMethodId(
    r"dispatchTrackballEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent motionEvent)
  bool dispatchTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchTrackballEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchCapturedPointerEvent = _class.instanceMethodId(
    r"dispatchCapturedPointerEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean dispatchCapturedPointerEvent(android.view.MotionEvent motionEvent)
  bool dispatchCapturedPointerEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchCapturedPointerEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchGenericMotionEvent = _class.instanceMethodId(
    r"dispatchGenericMotionEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchGenericMotionEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchHoverEvent = _class.instanceMethodId(
    r"dispatchHoverEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: protected boolean dispatchHoverEvent(android.view.MotionEvent motionEvent)
  bool dispatchHoverEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchHoverEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchGenericPointerEvent = _class.instanceMethodId(
    r"dispatchGenericPointerEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: protected boolean dispatchGenericPointerEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericPointerEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchGenericPointerEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchGenericFocusedEvent = _class.instanceMethodId(
    r"dispatchGenericFocusedEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: protected boolean dispatchGenericFocusedEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericFocusedEvent(
    jni.JObject motionEvent,
  ) {
    return _id_dispatchGenericFocusedEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_dispatchWindowFocusChanged = _class.instanceMethodId(
    r"dispatchWindowFocusChanged",
    r"(Z)V",
  );

  /// from: public void dispatchWindowFocusChanged(boolean z)
  void dispatchWindowFocusChanged(
    bool z,
  ) {
    _id_dispatchWindowFocusChanged(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_onWindowFocusChanged = _class.instanceMethodId(
    r"onWindowFocusChanged",
    r"(Z)V",
  );

  /// from: public void onWindowFocusChanged(boolean z)
  void onWindowFocusChanged(
    bool z,
  ) {
    _id_onWindowFocusChanged(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_hasWindowFocus = _class.instanceMethodId(
    r"hasWindowFocus",
    r"()Z",
  );

  /// from: public boolean hasWindowFocus()
  bool hasWindowFocus() {
    return _id_hasWindowFocus(this, const jni.jbooleanType(), []);
  }

  static final _id_dispatchVisibilityChanged = _class.instanceMethodId(
    r"dispatchVisibilityChanged",
    r"(Landroid/view/View;I)V",
  );

  /// from: protected void dispatchVisibilityChanged(android.view.View view, int i)
  void dispatchVisibilityChanged(
    View view,
    int i,
  ) {
    _id_dispatchVisibilityChanged(this, const jni.jvoidType(),
        [view.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_onVisibilityChanged = _class.instanceMethodId(
    r"onVisibilityChanged",
    r"(Landroid/view/View;I)V",
  );

  /// from: protected void onVisibilityChanged(android.view.View view, int i)
  void onVisibilityChanged(
    View view,
    int i,
  ) {
    _id_onVisibilityChanged(this, const jni.jvoidType(),
        [view.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_dispatchDisplayHint = _class.instanceMethodId(
    r"dispatchDisplayHint",
    r"(I)V",
  );

  /// from: public void dispatchDisplayHint(int i)
  void dispatchDisplayHint(
    int i,
  ) {
    _id_dispatchDisplayHint(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_onDisplayHint = _class.instanceMethodId(
    r"onDisplayHint",
    r"(I)V",
  );

  /// from: protected void onDisplayHint(int i)
  void onDisplayHint(
    int i,
  ) {
    _id_onDisplayHint(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_dispatchWindowVisibilityChanged = _class.instanceMethodId(
    r"dispatchWindowVisibilityChanged",
    r"(I)V",
  );

  /// from: public void dispatchWindowVisibilityChanged(int i)
  void dispatchWindowVisibilityChanged(
    int i,
  ) {
    _id_dispatchWindowVisibilityChanged(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_onWindowVisibilityChanged = _class.instanceMethodId(
    r"onWindowVisibilityChanged",
    r"(I)V",
  );

  /// from: protected void onWindowVisibilityChanged(int i)
  void onWindowVisibilityChanged(
    int i,
  ) {
    _id_onWindowVisibilityChanged(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_onVisibilityAggregated = _class.instanceMethodId(
    r"onVisibilityAggregated",
    r"(Z)V",
  );

  /// from: public void onVisibilityAggregated(boolean z)
  void onVisibilityAggregated(
    bool z,
  ) {
    _id_onVisibilityAggregated(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getWindowVisibility = _class.instanceMethodId(
    r"getWindowVisibility",
    r"()I",
  );

  /// from: public int getWindowVisibility()
  int getWindowVisibility() {
    return _id_getWindowVisibility(this, const jni.jintType(), []);
  }

  static final _id_getWindowVisibleDisplayFrame = _class.instanceMethodId(
    r"getWindowVisibleDisplayFrame",
    r"(Landroid/graphics/Rect;)V",
  );

  /// from: public void getWindowVisibleDisplayFrame(android.graphics.Rect rect)
  void getWindowVisibleDisplayFrame(
    jni.JObject rect,
  ) {
    _id_getWindowVisibleDisplayFrame(
        this, const jni.jvoidType(), [rect.reference.pointer]);
  }

  static final _id_dispatchConfigurationChanged = _class.instanceMethodId(
    r"dispatchConfigurationChanged",
    r"(Landroid/content/res/Configuration;)V",
  );

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration configuration)
  void dispatchConfigurationChanged(
    jni.JObject configuration,
  ) {
    _id_dispatchConfigurationChanged(
        this, const jni.jvoidType(), [configuration.reference.pointer]);
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r"onConfigurationChanged",
    r"(Landroid/content/res/Configuration;)V",
  );

  /// from: protected void onConfigurationChanged(android.content.res.Configuration configuration)
  void onConfigurationChanged(
    jni.JObject configuration,
  ) {
    _id_onConfigurationChanged(
        this, const jni.jvoidType(), [configuration.reference.pointer]);
  }

  static final _id_isInTouchMode = _class.instanceMethodId(
    r"isInTouchMode",
    r"()Z",
  );

  /// from: public boolean isInTouchMode()
  bool isInTouchMode() {
    return _id_isInTouchMode(this, const jni.jbooleanType(), []);
  }

  static final _id_getContext = _class.instanceMethodId(
    r"getContext",
    r"()Landroid/content/Context;",
  );

  /// from: public final android.content.Context getContext()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContext() {
    return _id_getContext(this, const jni.JObjectType(), []);
  }

  static final _id_onKeyPreIme = _class.instanceMethodId(
    r"onKeyPreIme",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyPreIme(int i, android.view.KeyEvent keyEvent)
  bool onKeyPreIme(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyPreIme(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onKeyDown = _class.instanceMethodId(
    r"onKeyDown",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyDown(int i, android.view.KeyEvent keyEvent)
  bool onKeyDown(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyDown(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onKeyLongPress = _class.instanceMethodId(
    r"onKeyLongPress",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyLongPress(int i, android.view.KeyEvent keyEvent)
  bool onKeyLongPress(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyLongPress(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onKeyUp = _class.instanceMethodId(
    r"onKeyUp",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyUp(int i, android.view.KeyEvent keyEvent)
  bool onKeyUp(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyUp(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onKeyMultiple = _class.instanceMethodId(
    r"onKeyMultiple",
    r"(IILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyMultiple(int i, int i1, android.view.KeyEvent keyEvent)
  bool onKeyMultiple(
    int i,
    int i1,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyMultiple(this, const jni.jbooleanType(),
        [jni.JValueInt(i), jni.JValueInt(i1), keyEvent.reference.pointer]);
  }

  static final _id_onKeyShortcut = _class.instanceMethodId(
    r"onKeyShortcut",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyShortcut(int i, android.view.KeyEvent keyEvent)
  bool onKeyShortcut(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyShortcut(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onCheckIsTextEditor = _class.instanceMethodId(
    r"onCheckIsTextEditor",
    r"()Z",
  );

  /// from: public boolean onCheckIsTextEditor()
  bool onCheckIsTextEditor() {
    return _id_onCheckIsTextEditor(this, const jni.jbooleanType(), []);
  }

  static final _id_onCreateInputConnection = _class.instanceMethodId(
    r"onCreateInputConnection",
    r"(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;",
  );

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo editorInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateInputConnection(
    jni.JObject editorInfo,
  ) {
    return _id_onCreateInputConnection(
        this, const jni.JObjectType(), [editorInfo.reference.pointer]);
  }

  static final _id_checkInputConnectionProxy = _class.instanceMethodId(
    r"checkInputConnectionProxy",
    r"(Landroid/view/View;)Z",
  );

  /// from: public boolean checkInputConnectionProxy(android.view.View view)
  bool checkInputConnectionProxy(
    View view,
  ) {
    return _id_checkInputConnectionProxy(
        this, const jni.jbooleanType(), [view.reference.pointer]);
  }

  static final _id_createContextMenu = _class.instanceMethodId(
    r"createContextMenu",
    r"(Landroid/view/ContextMenu;)V",
  );

  /// from: public void createContextMenu(android.view.ContextMenu contextMenu)
  void createContextMenu(
    jni.JObject contextMenu,
  ) {
    _id_createContextMenu(
        this, const jni.jvoidType(), [contextMenu.reference.pointer]);
  }

  static final _id_getContextMenuInfo = _class.instanceMethodId(
    r"getContextMenuInfo",
    r"()Landroid/view/ContextMenu$ContextMenuInfo;",
  );

  /// from: protected android.view.ContextMenu$ContextMenuInfo getContextMenuInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContextMenuInfo() {
    return _id_getContextMenuInfo(this, const jni.JObjectType(), []);
  }

  static final _id_onCreateContextMenu = _class.instanceMethodId(
    r"onCreateContextMenu",
    r"(Landroid/view/ContextMenu;)V",
  );

  /// from: protected void onCreateContextMenu(android.view.ContextMenu contextMenu)
  void onCreateContextMenu(
    jni.JObject contextMenu,
  ) {
    _id_onCreateContextMenu(
        this, const jni.jvoidType(), [contextMenu.reference.pointer]);
  }

  static final _id_onTrackballEvent = _class.instanceMethodId(
    r"onTrackballEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onTrackballEvent(android.view.MotionEvent motionEvent)
  bool onTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onTrackballEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onGenericMotionEvent = _class.instanceMethodId(
    r"onGenericMotionEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool onGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onGenericMotionEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onHoverEvent = _class.instanceMethodId(
    r"onHoverEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onHoverEvent(android.view.MotionEvent motionEvent)
  bool onHoverEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onHoverEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_isHovered = _class.instanceMethodId(
    r"isHovered",
    r"()Z",
  );

  /// from: public boolean isHovered()
  bool isHovered() {
    return _id_isHovered(this, const jni.jbooleanType(), []);
  }

  static final _id_setHovered = _class.instanceMethodId(
    r"setHovered",
    r"(Z)V",
  );

  /// from: public void setHovered(boolean z)
  void setHovered(
    bool z,
  ) {
    _id_setHovered(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_onHoverChanged = _class.instanceMethodId(
    r"onHoverChanged",
    r"(Z)V",
  );

  /// from: public void onHoverChanged(boolean z)
  void onHoverChanged(
    bool z,
  ) {
    _id_onHoverChanged(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r"onTouchEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onTouchEvent(android.view.MotionEvent motionEvent)
  bool onTouchEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onTouchEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_cancelLongPress = _class.instanceMethodId(
    r"cancelLongPress",
    r"()V",
  );

  /// from: public void cancelLongPress()
  void cancelLongPress() {
    _id_cancelLongPress(this, const jni.jvoidType(), []);
  }

  static final _id_setTouchDelegate = _class.instanceMethodId(
    r"setTouchDelegate",
    r"(Landroid/view/TouchDelegate;)V",
  );

  /// from: public void setTouchDelegate(android.view.TouchDelegate touchDelegate)
  void setTouchDelegate(
    jni.JObject touchDelegate,
  ) {
    _id_setTouchDelegate(
        this, const jni.jvoidType(), [touchDelegate.reference.pointer]);
  }

  static final _id_getTouchDelegate = _class.instanceMethodId(
    r"getTouchDelegate",
    r"()Landroid/view/TouchDelegate;",
  );

  /// from: public android.view.TouchDelegate getTouchDelegate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTouchDelegate() {
    return _id_getTouchDelegate(this, const jni.JObjectType(), []);
  }

  static final _id_requestUnbufferedDispatch = _class.instanceMethodId(
    r"requestUnbufferedDispatch",
    r"(Landroid/view/MotionEvent;)V",
  );

  /// from: public final void requestUnbufferedDispatch(android.view.MotionEvent motionEvent)
  void requestUnbufferedDispatch(
    jni.JObject motionEvent,
  ) {
    _id_requestUnbufferedDispatch(
        this, const jni.jvoidType(), [motionEvent.reference.pointer]);
  }

  static final _id_requestUnbufferedDispatch1 = _class.instanceMethodId(
    r"requestUnbufferedDispatch",
    r"(I)V",
  );

  /// from: public final void requestUnbufferedDispatch(int i)
  void requestUnbufferedDispatch1(
    int i,
  ) {
    _id_requestUnbufferedDispatch1(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_bringToFront = _class.instanceMethodId(
    r"bringToFront",
    r"()V",
  );

  /// from: public void bringToFront()
  void bringToFront() {
    _id_bringToFront(this, const jni.jvoidType(), []);
  }

  static final _id_onScrollChanged = _class.instanceMethodId(
    r"onScrollChanged",
    r"(IIII)V",
  );

  /// from: protected void onScrollChanged(int i, int i1, int i2, int i3)
  void onScrollChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_onScrollChanged(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_onSizeChanged = _class.instanceMethodId(
    r"onSizeChanged",
    r"(IIII)V",
  );

  /// from: protected void onSizeChanged(int i, int i1, int i2, int i3)
  void onSizeChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_onSizeChanged(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_dispatchDraw = _class.instanceMethodId(
    r"dispatchDraw",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(
    jni.JObject canvas,
  ) {
    _id_dispatchDraw(this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_getParent = _class.instanceMethodId(
    r"getParent",
    r"()Landroid/view/ViewParent;",
  );

  /// from: public final android.view.ViewParent getParent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getParent() {
    return _id_getParent(this, const jni.JObjectType(), []);
  }

  static final _id_setScrollX = _class.instanceMethodId(
    r"setScrollX",
    r"(I)V",
  );

  /// from: public void setScrollX(int i)
  void setScrollX(
    int i,
  ) {
    _id_setScrollX(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setScrollY = _class.instanceMethodId(
    r"setScrollY",
    r"(I)V",
  );

  /// from: public void setScrollY(int i)
  void setScrollY(
    int i,
  ) {
    _id_setScrollY(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getScrollX = _class.instanceMethodId(
    r"getScrollX",
    r"()I",
  );

  /// from: public final int getScrollX()
  int getScrollX() {
    return _id_getScrollX(this, const jni.jintType(), []);
  }

  static final _id_getScrollY = _class.instanceMethodId(
    r"getScrollY",
    r"()I",
  );

  /// from: public final int getScrollY()
  int getScrollY() {
    return _id_getScrollY(this, const jni.jintType(), []);
  }

  static final _id_getWidth = _class.instanceMethodId(
    r"getWidth",
    r"()I",
  );

  /// from: public final int getWidth()
  int getWidth() {
    return _id_getWidth(this, const jni.jintType(), []);
  }

  static final _id_getHeight = _class.instanceMethodId(
    r"getHeight",
    r"()I",
  );

  /// from: public final int getHeight()
  int getHeight() {
    return _id_getHeight(this, const jni.jintType(), []);
  }

  static final _id_getDrawingRect = _class.instanceMethodId(
    r"getDrawingRect",
    r"(Landroid/graphics/Rect;)V",
  );

  /// from: public void getDrawingRect(android.graphics.Rect rect)
  void getDrawingRect(
    jni.JObject rect,
  ) {
    _id_getDrawingRect(this, const jni.jvoidType(), [rect.reference.pointer]);
  }

  static final _id_getMeasuredWidth = _class.instanceMethodId(
    r"getMeasuredWidth",
    r"()I",
  );

  /// from: public final int getMeasuredWidth()
  int getMeasuredWidth() {
    return _id_getMeasuredWidth(this, const jni.jintType(), []);
  }

  static final _id_getMeasuredWidthAndState = _class.instanceMethodId(
    r"getMeasuredWidthAndState",
    r"()I",
  );

  /// from: public final int getMeasuredWidthAndState()
  int getMeasuredWidthAndState() {
    return _id_getMeasuredWidthAndState(this, const jni.jintType(), []);
  }

  static final _id_getMeasuredHeight = _class.instanceMethodId(
    r"getMeasuredHeight",
    r"()I",
  );

  /// from: public final int getMeasuredHeight()
  int getMeasuredHeight() {
    return _id_getMeasuredHeight(this, const jni.jintType(), []);
  }

  static final _id_getMeasuredHeightAndState = _class.instanceMethodId(
    r"getMeasuredHeightAndState",
    r"()I",
  );

  /// from: public final int getMeasuredHeightAndState()
  int getMeasuredHeightAndState() {
    return _id_getMeasuredHeightAndState(this, const jni.jintType(), []);
  }

  static final _id_getMeasuredState = _class.instanceMethodId(
    r"getMeasuredState",
    r"()I",
  );

  /// from: public final int getMeasuredState()
  int getMeasuredState() {
    return _id_getMeasuredState(this, const jni.jintType(), []);
  }

  static final _id_getMatrix = _class.instanceMethodId(
    r"getMatrix",
    r"()Landroid/graphics/Matrix;",
  );

  /// from: public android.graphics.Matrix getMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMatrix() {
    return _id_getMatrix(this, const jni.JObjectType(), []);
  }

  static final _id_getCameraDistance = _class.instanceMethodId(
    r"getCameraDistance",
    r"()F",
  );

  /// from: public float getCameraDistance()
  double getCameraDistance() {
    return _id_getCameraDistance(this, const jni.jfloatType(), []);
  }

  static final _id_setCameraDistance = _class.instanceMethodId(
    r"setCameraDistance",
    r"(F)V",
  );

  /// from: public void setCameraDistance(float f)
  void setCameraDistance(
    double f,
  ) {
    _id_setCameraDistance(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getRotation = _class.instanceMethodId(
    r"getRotation",
    r"()F",
  );

  /// from: public float getRotation()
  double getRotation() {
    return _id_getRotation(this, const jni.jfloatType(), []);
  }

  static final _id_setRotation = _class.instanceMethodId(
    r"setRotation",
    r"(F)V",
  );

  /// from: public void setRotation(float f)
  void setRotation(
    double f,
  ) {
    _id_setRotation(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getRotationY = _class.instanceMethodId(
    r"getRotationY",
    r"()F",
  );

  /// from: public float getRotationY()
  double getRotationY() {
    return _id_getRotationY(this, const jni.jfloatType(), []);
  }

  static final _id_setRotationY = _class.instanceMethodId(
    r"setRotationY",
    r"(F)V",
  );

  /// from: public void setRotationY(float f)
  void setRotationY(
    double f,
  ) {
    _id_setRotationY(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getRotationX = _class.instanceMethodId(
    r"getRotationX",
    r"()F",
  );

  /// from: public float getRotationX()
  double getRotationX() {
    return _id_getRotationX(this, const jni.jfloatType(), []);
  }

  static final _id_setRotationX = _class.instanceMethodId(
    r"setRotationX",
    r"(F)V",
  );

  /// from: public void setRotationX(float f)
  void setRotationX(
    double f,
  ) {
    _id_setRotationX(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getScaleX = _class.instanceMethodId(
    r"getScaleX",
    r"()F",
  );

  /// from: public float getScaleX()
  double getScaleX() {
    return _id_getScaleX(this, const jni.jfloatType(), []);
  }

  static final _id_setScaleX = _class.instanceMethodId(
    r"setScaleX",
    r"(F)V",
  );

  /// from: public void setScaleX(float f)
  void setScaleX(
    double f,
  ) {
    _id_setScaleX(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getScaleY = _class.instanceMethodId(
    r"getScaleY",
    r"()F",
  );

  /// from: public float getScaleY()
  double getScaleY() {
    return _id_getScaleY(this, const jni.jfloatType(), []);
  }

  static final _id_setScaleY = _class.instanceMethodId(
    r"setScaleY",
    r"(F)V",
  );

  /// from: public void setScaleY(float f)
  void setScaleY(
    double f,
  ) {
    _id_setScaleY(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getPivotX = _class.instanceMethodId(
    r"getPivotX",
    r"()F",
  );

  /// from: public float getPivotX()
  double getPivotX() {
    return _id_getPivotX(this, const jni.jfloatType(), []);
  }

  static final _id_setPivotX = _class.instanceMethodId(
    r"setPivotX",
    r"(F)V",
  );

  /// from: public void setPivotX(float f)
  void setPivotX(
    double f,
  ) {
    _id_setPivotX(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getPivotY = _class.instanceMethodId(
    r"getPivotY",
    r"()F",
  );

  /// from: public float getPivotY()
  double getPivotY() {
    return _id_getPivotY(this, const jni.jfloatType(), []);
  }

  static final _id_setPivotY = _class.instanceMethodId(
    r"setPivotY",
    r"(F)V",
  );

  /// from: public void setPivotY(float f)
  void setPivotY(
    double f,
  ) {
    _id_setPivotY(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_isPivotSet = _class.instanceMethodId(
    r"isPivotSet",
    r"()Z",
  );

  /// from: public boolean isPivotSet()
  bool isPivotSet() {
    return _id_isPivotSet(this, const jni.jbooleanType(), []);
  }

  static final _id_resetPivot = _class.instanceMethodId(
    r"resetPivot",
    r"()V",
  );

  /// from: public void resetPivot()
  void resetPivot() {
    _id_resetPivot(this, const jni.jvoidType(), []);
  }

  static final _id_getAlpha = _class.instanceMethodId(
    r"getAlpha",
    r"()F",
  );

  /// from: public float getAlpha()
  double getAlpha() {
    return _id_getAlpha(this, const jni.jfloatType(), []);
  }

  static final _id_forceHasOverlappingRendering = _class.instanceMethodId(
    r"forceHasOverlappingRendering",
    r"(Z)V",
  );

  /// from: public void forceHasOverlappingRendering(boolean z)
  void forceHasOverlappingRendering(
    bool z,
  ) {
    _id_forceHasOverlappingRendering(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getHasOverlappingRendering = _class.instanceMethodId(
    r"getHasOverlappingRendering",
    r"()Z",
  );

  /// from: public final boolean getHasOverlappingRendering()
  bool getHasOverlappingRendering() {
    return _id_getHasOverlappingRendering(this, const jni.jbooleanType(), []);
  }

  static final _id_hasOverlappingRendering = _class.instanceMethodId(
    r"hasOverlappingRendering",
    r"()Z",
  );

  /// from: public boolean hasOverlappingRendering()
  bool hasOverlappingRendering() {
    return _id_hasOverlappingRendering(this, const jni.jbooleanType(), []);
  }

  static final _id_setAlpha = _class.instanceMethodId(
    r"setAlpha",
    r"(F)V",
  );

  /// from: public void setAlpha(float f)
  void setAlpha(
    double f,
  ) {
    _id_setAlpha(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_setTransitionAlpha = _class.instanceMethodId(
    r"setTransitionAlpha",
    r"(F)V",
  );

  /// from: public void setTransitionAlpha(float f)
  void setTransitionAlpha(
    double f,
  ) {
    _id_setTransitionAlpha(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getTransitionAlpha = _class.instanceMethodId(
    r"getTransitionAlpha",
    r"()F",
  );

  /// from: public float getTransitionAlpha()
  double getTransitionAlpha() {
    return _id_getTransitionAlpha(this, const jni.jfloatType(), []);
  }

  static final _id_setForceDarkAllowed = _class.instanceMethodId(
    r"setForceDarkAllowed",
    r"(Z)V",
  );

  /// from: public void setForceDarkAllowed(boolean z)
  void setForceDarkAllowed(
    bool z,
  ) {
    _id_setForceDarkAllowed(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isForceDarkAllowed = _class.instanceMethodId(
    r"isForceDarkAllowed",
    r"()Z",
  );

  /// from: public boolean isForceDarkAllowed()
  bool isForceDarkAllowed() {
    return _id_isForceDarkAllowed(this, const jni.jbooleanType(), []);
  }

  static final _id_getTop = _class.instanceMethodId(
    r"getTop",
    r"()I",
  );

  /// from: public final int getTop()
  int getTop() {
    return _id_getTop(this, const jni.jintType(), []);
  }

  static final _id_setTop = _class.instanceMethodId(
    r"setTop",
    r"(I)V",
  );

  /// from: public final void setTop(int i)
  void setTop(
    int i,
  ) {
    _id_setTop(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getBottom = _class.instanceMethodId(
    r"getBottom",
    r"()I",
  );

  /// from: public final int getBottom()
  int getBottom() {
    return _id_getBottom(this, const jni.jintType(), []);
  }

  static final _id_isDirty = _class.instanceMethodId(
    r"isDirty",
    r"()Z",
  );

  /// from: public boolean isDirty()
  bool isDirty() {
    return _id_isDirty(this, const jni.jbooleanType(), []);
  }

  static final _id_setBottom = _class.instanceMethodId(
    r"setBottom",
    r"(I)V",
  );

  /// from: public final void setBottom(int i)
  void setBottom(
    int i,
  ) {
    _id_setBottom(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getLeft = _class.instanceMethodId(
    r"getLeft",
    r"()I",
  );

  /// from: public final int getLeft()
  int getLeft() {
    return _id_getLeft(this, const jni.jintType(), []);
  }

  static final _id_setLeft = _class.instanceMethodId(
    r"setLeft",
    r"(I)V",
  );

  /// from: public final void setLeft(int i)
  void setLeft(
    int i,
  ) {
    _id_setLeft(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getRight = _class.instanceMethodId(
    r"getRight",
    r"()I",
  );

  /// from: public final int getRight()
  int getRight() {
    return _id_getRight(this, const jni.jintType(), []);
  }

  static final _id_setRight = _class.instanceMethodId(
    r"setRight",
    r"(I)V",
  );

  /// from: public final void setRight(int i)
  void setRight(
    int i,
  ) {
    _id_setRight(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getX = _class.instanceMethodId(
    r"getX",
    r"()F",
  );

  /// from: public float getX()
  double getX() {
    return _id_getX(this, const jni.jfloatType(), []);
  }

  static final _id_setX = _class.instanceMethodId(
    r"setX",
    r"(F)V",
  );

  /// from: public void setX(float f)
  void setX(
    double f,
  ) {
    _id_setX(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getY = _class.instanceMethodId(
    r"getY",
    r"()F",
  );

  /// from: public float getY()
  double getY() {
    return _id_getY(this, const jni.jfloatType(), []);
  }

  static final _id_setY = _class.instanceMethodId(
    r"setY",
    r"(F)V",
  );

  /// from: public void setY(float f)
  void setY(
    double f,
  ) {
    _id_setY(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getZ = _class.instanceMethodId(
    r"getZ",
    r"()F",
  );

  /// from: public float getZ()
  double getZ() {
    return _id_getZ(this, const jni.jfloatType(), []);
  }

  static final _id_setZ = _class.instanceMethodId(
    r"setZ",
    r"(F)V",
  );

  /// from: public void setZ(float f)
  void setZ(
    double f,
  ) {
    _id_setZ(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getElevation = _class.instanceMethodId(
    r"getElevation",
    r"()F",
  );

  /// from: public float getElevation()
  double getElevation() {
    return _id_getElevation(this, const jni.jfloatType(), []);
  }

  static final _id_setElevation = _class.instanceMethodId(
    r"setElevation",
    r"(F)V",
  );

  /// from: public void setElevation(float f)
  void setElevation(
    double f,
  ) {
    _id_setElevation(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getTranslationX = _class.instanceMethodId(
    r"getTranslationX",
    r"()F",
  );

  /// from: public float getTranslationX()
  double getTranslationX() {
    return _id_getTranslationX(this, const jni.jfloatType(), []);
  }

  static final _id_setTranslationX = _class.instanceMethodId(
    r"setTranslationX",
    r"(F)V",
  );

  /// from: public void setTranslationX(float f)
  void setTranslationX(
    double f,
  ) {
    _id_setTranslationX(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getTranslationY = _class.instanceMethodId(
    r"getTranslationY",
    r"()F",
  );

  /// from: public float getTranslationY()
  double getTranslationY() {
    return _id_getTranslationY(this, const jni.jfloatType(), []);
  }

  static final _id_setTranslationY = _class.instanceMethodId(
    r"setTranslationY",
    r"(F)V",
  );

  /// from: public void setTranslationY(float f)
  void setTranslationY(
    double f,
  ) {
    _id_setTranslationY(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_getTranslationZ = _class.instanceMethodId(
    r"getTranslationZ",
    r"()F",
  );

  /// from: public float getTranslationZ()
  double getTranslationZ() {
    return _id_getTranslationZ(this, const jni.jfloatType(), []);
  }

  static final _id_setTranslationZ = _class.instanceMethodId(
    r"setTranslationZ",
    r"(F)V",
  );

  /// from: public void setTranslationZ(float f)
  void setTranslationZ(
    double f,
  ) {
    _id_setTranslationZ(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_setAnimationMatrix = _class.instanceMethodId(
    r"setAnimationMatrix",
    r"(Landroid/graphics/Matrix;)V",
  );

  /// from: public void setAnimationMatrix(android.graphics.Matrix matrix)
  void setAnimationMatrix(
    jni.JObject matrix,
  ) {
    _id_setAnimationMatrix(
        this, const jni.jvoidType(), [matrix.reference.pointer]);
  }

  static final _id_getAnimationMatrix = _class.instanceMethodId(
    r"getAnimationMatrix",
    r"()Landroid/graphics/Matrix;",
  );

  /// from: public android.graphics.Matrix getAnimationMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAnimationMatrix() {
    return _id_getAnimationMatrix(this, const jni.JObjectType(), []);
  }

  static final _id_getStateListAnimator = _class.instanceMethodId(
    r"getStateListAnimator",
    r"()Landroid/animation/StateListAnimator;",
  );

  /// from: public android.animation.StateListAnimator getStateListAnimator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getStateListAnimator() {
    return _id_getStateListAnimator(this, const jni.JObjectType(), []);
  }

  static final _id_setStateListAnimator = _class.instanceMethodId(
    r"setStateListAnimator",
    r"(Landroid/animation/StateListAnimator;)V",
  );

  /// from: public void setStateListAnimator(android.animation.StateListAnimator stateListAnimator)
  void setStateListAnimator(
    jni.JObject stateListAnimator,
  ) {
    _id_setStateListAnimator(
        this, const jni.jvoidType(), [stateListAnimator.reference.pointer]);
  }

  static final _id_getClipToOutline = _class.instanceMethodId(
    r"getClipToOutline",
    r"()Z",
  );

  /// from: public final boolean getClipToOutline()
  bool getClipToOutline() {
    return _id_getClipToOutline(this, const jni.jbooleanType(), []);
  }

  static final _id_setClipToOutline = _class.instanceMethodId(
    r"setClipToOutline",
    r"(Z)V",
  );

  /// from: public void setClipToOutline(boolean z)
  void setClipToOutline(
    bool z,
  ) {
    _id_setClipToOutline(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setOutlineProvider = _class.instanceMethodId(
    r"setOutlineProvider",
    r"(Landroid/view/ViewOutlineProvider;)V",
  );

  /// from: public void setOutlineProvider(android.view.ViewOutlineProvider viewOutlineProvider)
  void setOutlineProvider(
    jni.JObject viewOutlineProvider,
  ) {
    _id_setOutlineProvider(
        this, const jni.jvoidType(), [viewOutlineProvider.reference.pointer]);
  }

  static final _id_getOutlineProvider = _class.instanceMethodId(
    r"getOutlineProvider",
    r"()Landroid/view/ViewOutlineProvider;",
  );

  /// from: public android.view.ViewOutlineProvider getOutlineProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOutlineProvider() {
    return _id_getOutlineProvider(this, const jni.JObjectType(), []);
  }

  static final _id_invalidateOutline = _class.instanceMethodId(
    r"invalidateOutline",
    r"()V",
  );

  /// from: public void invalidateOutline()
  void invalidateOutline() {
    _id_invalidateOutline(this, const jni.jvoidType(), []);
  }

  static final _id_setOutlineSpotShadowColor = _class.instanceMethodId(
    r"setOutlineSpotShadowColor",
    r"(I)V",
  );

  /// from: public void setOutlineSpotShadowColor(int i)
  void setOutlineSpotShadowColor(
    int i,
  ) {
    _id_setOutlineSpotShadowColor(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getOutlineSpotShadowColor = _class.instanceMethodId(
    r"getOutlineSpotShadowColor",
    r"()I",
  );

  /// from: public int getOutlineSpotShadowColor()
  int getOutlineSpotShadowColor() {
    return _id_getOutlineSpotShadowColor(this, const jni.jintType(), []);
  }

  static final _id_setOutlineAmbientShadowColor = _class.instanceMethodId(
    r"setOutlineAmbientShadowColor",
    r"(I)V",
  );

  /// from: public void setOutlineAmbientShadowColor(int i)
  void setOutlineAmbientShadowColor(
    int i,
  ) {
    _id_setOutlineAmbientShadowColor(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getOutlineAmbientShadowColor = _class.instanceMethodId(
    r"getOutlineAmbientShadowColor",
    r"()I",
  );

  /// from: public int getOutlineAmbientShadowColor()
  int getOutlineAmbientShadowColor() {
    return _id_getOutlineAmbientShadowColor(this, const jni.jintType(), []);
  }

  static final _id_getHitRect = _class.instanceMethodId(
    r"getHitRect",
    r"(Landroid/graphics/Rect;)V",
  );

  /// from: public void getHitRect(android.graphics.Rect rect)
  void getHitRect(
    jni.JObject rect,
  ) {
    _id_getHitRect(this, const jni.jvoidType(), [rect.reference.pointer]);
  }

  static final _id_getFocusedRect = _class.instanceMethodId(
    r"getFocusedRect",
    r"(Landroid/graphics/Rect;)V",
  );

  /// from: public void getFocusedRect(android.graphics.Rect rect)
  void getFocusedRect(
    jni.JObject rect,
  ) {
    _id_getFocusedRect(this, const jni.jvoidType(), [rect.reference.pointer]);
  }

  static final _id_getGlobalVisibleRect = _class.instanceMethodId(
    r"getGlobalVisibleRect",
    r"(Landroid/graphics/Rect;Landroid/graphics/Point;)Z",
  );

  /// from: public boolean getGlobalVisibleRect(android.graphics.Rect rect, android.graphics.Point point)
  bool getGlobalVisibleRect(
    jni.JObject rect,
    jni.JObject point,
  ) {
    return _id_getGlobalVisibleRect(this, const jni.jbooleanType(),
        [rect.reference.pointer, point.reference.pointer]);
  }

  static final _id_getGlobalVisibleRect1 = _class.instanceMethodId(
    r"getGlobalVisibleRect",
    r"(Landroid/graphics/Rect;)Z",
  );

  /// from: public final boolean getGlobalVisibleRect(android.graphics.Rect rect)
  bool getGlobalVisibleRect1(
    jni.JObject rect,
  ) {
    return _id_getGlobalVisibleRect1(
        this, const jni.jbooleanType(), [rect.reference.pointer]);
  }

  static final _id_getLocalVisibleRect = _class.instanceMethodId(
    r"getLocalVisibleRect",
    r"(Landroid/graphics/Rect;)Z",
  );

  /// from: public final boolean getLocalVisibleRect(android.graphics.Rect rect)
  bool getLocalVisibleRect(
    jni.JObject rect,
  ) {
    return _id_getLocalVisibleRect(
        this, const jni.jbooleanType(), [rect.reference.pointer]);
  }

  static final _id_offsetTopAndBottom = _class.instanceMethodId(
    r"offsetTopAndBottom",
    r"(I)V",
  );

  /// from: public void offsetTopAndBottom(int i)
  void offsetTopAndBottom(
    int i,
  ) {
    _id_offsetTopAndBottom(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_offsetLeftAndRight = _class.instanceMethodId(
    r"offsetLeftAndRight",
    r"(I)V",
  );

  /// from: public void offsetLeftAndRight(int i)
  void offsetLeftAndRight(
    int i,
  ) {
    _id_offsetLeftAndRight(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getLayoutParams = _class.instanceMethodId(
    r"getLayoutParams",
    r"()Landroid/view/ViewGroup$LayoutParams;",
  );

  /// from: public android.view.ViewGroup$LayoutParams getLayoutParams()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLayoutParams() {
    return _id_getLayoutParams(this, const jni.JObjectType(), []);
  }

  static final _id_setLayoutParams = _class.instanceMethodId(
    r"setLayoutParams",
    r"(Landroid/view/ViewGroup$LayoutParams;)V",
  );

  /// from: public void setLayoutParams(android.view.ViewGroup$LayoutParams layoutParams)
  void setLayoutParams(
    jni.JObject layoutParams,
  ) {
    _id_setLayoutParams(
        this, const jni.jvoidType(), [layoutParams.reference.pointer]);
  }

  static final _id_scrollTo = _class.instanceMethodId(
    r"scrollTo",
    r"(II)V",
  );

  /// from: public void scrollTo(int i, int i1)
  void scrollTo(
    int i,
    int i1,
  ) {
    _id_scrollTo(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_scrollBy = _class.instanceMethodId(
    r"scrollBy",
    r"(II)V",
  );

  /// from: public void scrollBy(int i, int i1)
  void scrollBy(
    int i,
    int i1,
  ) {
    _id_scrollBy(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_awakenScrollBars = _class.instanceMethodId(
    r"awakenScrollBars",
    r"()Z",
  );

  /// from: protected boolean awakenScrollBars()
  bool awakenScrollBars() {
    return _id_awakenScrollBars(this, const jni.jbooleanType(), []);
  }

  static final _id_awakenScrollBars1 = _class.instanceMethodId(
    r"awakenScrollBars",
    r"(I)Z",
  );

  /// from: protected boolean awakenScrollBars(int i)
  bool awakenScrollBars1(
    int i,
  ) {
    return _id_awakenScrollBars1(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_awakenScrollBars2 = _class.instanceMethodId(
    r"awakenScrollBars",
    r"(IZ)Z",
  );

  /// from: protected boolean awakenScrollBars(int i, boolean z)
  bool awakenScrollBars2(
    int i,
    bool z,
  ) {
    return _id_awakenScrollBars2(
        this, const jni.jbooleanType(), [jni.JValueInt(i), z ? 1 : 0]);
  }

  static final _id_invalidate = _class.instanceMethodId(
    r"invalidate",
    r"(Landroid/graphics/Rect;)V",
  );

  /// from: public void invalidate(android.graphics.Rect rect)
  void invalidate(
    jni.JObject rect,
  ) {
    _id_invalidate(this, const jni.jvoidType(), [rect.reference.pointer]);
  }

  static final _id_invalidate1 = _class.instanceMethodId(
    r"invalidate",
    r"(IIII)V",
  );

  /// from: public void invalidate(int i, int i1, int i2, int i3)
  void invalidate1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_invalidate1(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_invalidate2 = _class.instanceMethodId(
    r"invalidate",
    r"()V",
  );

  /// from: public void invalidate()
  void invalidate2() {
    _id_invalidate2(this, const jni.jvoidType(), []);
  }

  static final _id_isOpaque = _class.instanceMethodId(
    r"isOpaque",
    r"()Z",
  );

  /// from: public boolean isOpaque()
  bool isOpaque() {
    return _id_isOpaque(this, const jni.jbooleanType(), []);
  }

  static final _id_getHandler = _class.instanceMethodId(
    r"getHandler",
    r"()Landroid/os/Handler;",
  );

  /// from: public android.os.Handler getHandler()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHandler() {
    return _id_getHandler(this, const jni.JObjectType(), []);
  }

  static final _id_post = _class.instanceMethodId(
    r"post",
    r"(Ljava/lang/Runnable;)Z",
  );

  /// from: public boolean post(java.lang.Runnable runnable)
  bool post(
    jni.JObject runnable,
  ) {
    return _id_post(
        this, const jni.jbooleanType(), [runnable.reference.pointer]);
  }

  static final _id_postDelayed = _class.instanceMethodId(
    r"postDelayed",
    r"(Ljava/lang/Runnable;J)Z",
  );

  /// from: public boolean postDelayed(java.lang.Runnable runnable, long j)
  bool postDelayed(
    jni.JObject runnable,
    int j,
  ) {
    return _id_postDelayed(
        this, const jni.jbooleanType(), [runnable.reference.pointer, j]);
  }

  static final _id_postOnAnimation = _class.instanceMethodId(
    r"postOnAnimation",
    r"(Ljava/lang/Runnable;)V",
  );

  /// from: public void postOnAnimation(java.lang.Runnable runnable)
  void postOnAnimation(
    jni.JObject runnable,
  ) {
    _id_postOnAnimation(
        this, const jni.jvoidType(), [runnable.reference.pointer]);
  }

  static final _id_postOnAnimationDelayed = _class.instanceMethodId(
    r"postOnAnimationDelayed",
    r"(Ljava/lang/Runnable;J)V",
  );

  /// from: public void postOnAnimationDelayed(java.lang.Runnable runnable, long j)
  void postOnAnimationDelayed(
    jni.JObject runnable,
    int j,
  ) {
    _id_postOnAnimationDelayed(
        this, const jni.jvoidType(), [runnable.reference.pointer, j]);
  }

  static final _id_removeCallbacks = _class.instanceMethodId(
    r"removeCallbacks",
    r"(Ljava/lang/Runnable;)Z",
  );

  /// from: public boolean removeCallbacks(java.lang.Runnable runnable)
  bool removeCallbacks(
    jni.JObject runnable,
  ) {
    return _id_removeCallbacks(
        this, const jni.jbooleanType(), [runnable.reference.pointer]);
  }

  static final _id_postInvalidate = _class.instanceMethodId(
    r"postInvalidate",
    r"()V",
  );

  /// from: public void postInvalidate()
  void postInvalidate() {
    _id_postInvalidate(this, const jni.jvoidType(), []);
  }

  static final _id_postInvalidate1 = _class.instanceMethodId(
    r"postInvalidate",
    r"(IIII)V",
  );

  /// from: public void postInvalidate(int i, int i1, int i2, int i3)
  void postInvalidate1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_postInvalidate1(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_postInvalidateDelayed = _class.instanceMethodId(
    r"postInvalidateDelayed",
    r"(J)V",
  );

  /// from: public void postInvalidateDelayed(long j)
  void postInvalidateDelayed(
    int j,
  ) {
    _id_postInvalidateDelayed(this, const jni.jvoidType(), [j]);
  }

  static final _id_postInvalidateDelayed1 = _class.instanceMethodId(
    r"postInvalidateDelayed",
    r"(JIIII)V",
  );

  /// from: public void postInvalidateDelayed(long j, int i, int i1, int i2, int i3)
  void postInvalidateDelayed1(
    int j,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_postInvalidateDelayed1(this, const jni.jvoidType(), [
      j,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_postInvalidateOnAnimation = _class.instanceMethodId(
    r"postInvalidateOnAnimation",
    r"()V",
  );

  /// from: public void postInvalidateOnAnimation()
  void postInvalidateOnAnimation() {
    _id_postInvalidateOnAnimation(this, const jni.jvoidType(), []);
  }

  static final _id_postInvalidateOnAnimation1 = _class.instanceMethodId(
    r"postInvalidateOnAnimation",
    r"(IIII)V",
  );

  /// from: public void postInvalidateOnAnimation(int i, int i1, int i2, int i3)
  void postInvalidateOnAnimation1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_postInvalidateOnAnimation1(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_computeScroll = _class.instanceMethodId(
    r"computeScroll",
    r"()V",
  );

  /// from: public void computeScroll()
  void computeScroll() {
    _id_computeScroll(this, const jni.jvoidType(), []);
  }

  static final _id_isHorizontalFadingEdgeEnabled = _class.instanceMethodId(
    r"isHorizontalFadingEdgeEnabled",
    r"()Z",
  );

  /// from: public boolean isHorizontalFadingEdgeEnabled()
  bool isHorizontalFadingEdgeEnabled() {
    return _id_isHorizontalFadingEdgeEnabled(
        this, const jni.jbooleanType(), []);
  }

  static final _id_setHorizontalFadingEdgeEnabled = _class.instanceMethodId(
    r"setHorizontalFadingEdgeEnabled",
    r"(Z)V",
  );

  /// from: public void setHorizontalFadingEdgeEnabled(boolean z)
  void setHorizontalFadingEdgeEnabled(
    bool z,
  ) {
    _id_setHorizontalFadingEdgeEnabled(
        this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isVerticalFadingEdgeEnabled = _class.instanceMethodId(
    r"isVerticalFadingEdgeEnabled",
    r"()Z",
  );

  /// from: public boolean isVerticalFadingEdgeEnabled()
  bool isVerticalFadingEdgeEnabled() {
    return _id_isVerticalFadingEdgeEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setVerticalFadingEdgeEnabled = _class.instanceMethodId(
    r"setVerticalFadingEdgeEnabled",
    r"(Z)V",
  );

  /// from: public void setVerticalFadingEdgeEnabled(boolean z)
  void setVerticalFadingEdgeEnabled(
    bool z,
  ) {
    _id_setVerticalFadingEdgeEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_getTopFadingEdgeStrength = _class.instanceMethodId(
    r"getTopFadingEdgeStrength",
    r"()F",
  );

  /// from: protected float getTopFadingEdgeStrength()
  double getTopFadingEdgeStrength() {
    return _id_getTopFadingEdgeStrength(this, const jni.jfloatType(), []);
  }

  static final _id_getBottomFadingEdgeStrength = _class.instanceMethodId(
    r"getBottomFadingEdgeStrength",
    r"()F",
  );

  /// from: protected float getBottomFadingEdgeStrength()
  double getBottomFadingEdgeStrength() {
    return _id_getBottomFadingEdgeStrength(this, const jni.jfloatType(), []);
  }

  static final _id_getLeftFadingEdgeStrength = _class.instanceMethodId(
    r"getLeftFadingEdgeStrength",
    r"()F",
  );

  /// from: protected float getLeftFadingEdgeStrength()
  double getLeftFadingEdgeStrength() {
    return _id_getLeftFadingEdgeStrength(this, const jni.jfloatType(), []);
  }

  static final _id_getRightFadingEdgeStrength = _class.instanceMethodId(
    r"getRightFadingEdgeStrength",
    r"()F",
  );

  /// from: protected float getRightFadingEdgeStrength()
  double getRightFadingEdgeStrength() {
    return _id_getRightFadingEdgeStrength(this, const jni.jfloatType(), []);
  }

  static final _id_isHorizontalScrollBarEnabled = _class.instanceMethodId(
    r"isHorizontalScrollBarEnabled",
    r"()Z",
  );

  /// from: public boolean isHorizontalScrollBarEnabled()
  bool isHorizontalScrollBarEnabled() {
    return _id_isHorizontalScrollBarEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setHorizontalScrollBarEnabled = _class.instanceMethodId(
    r"setHorizontalScrollBarEnabled",
    r"(Z)V",
  );

  /// from: public void setHorizontalScrollBarEnabled(boolean z)
  void setHorizontalScrollBarEnabled(
    bool z,
  ) {
    _id_setHorizontalScrollBarEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isVerticalScrollBarEnabled = _class.instanceMethodId(
    r"isVerticalScrollBarEnabled",
    r"()Z",
  );

  /// from: public boolean isVerticalScrollBarEnabled()
  bool isVerticalScrollBarEnabled() {
    return _id_isVerticalScrollBarEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_setVerticalScrollBarEnabled = _class.instanceMethodId(
    r"setVerticalScrollBarEnabled",
    r"(Z)V",
  );

  /// from: public void setVerticalScrollBarEnabled(boolean z)
  void setVerticalScrollBarEnabled(
    bool z,
  ) {
    _id_setVerticalScrollBarEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setScrollbarFadingEnabled = _class.instanceMethodId(
    r"setScrollbarFadingEnabled",
    r"(Z)V",
  );

  /// from: public void setScrollbarFadingEnabled(boolean z)
  void setScrollbarFadingEnabled(
    bool z,
  ) {
    _id_setScrollbarFadingEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isScrollbarFadingEnabled = _class.instanceMethodId(
    r"isScrollbarFadingEnabled",
    r"()Z",
  );

  /// from: public boolean isScrollbarFadingEnabled()
  bool isScrollbarFadingEnabled() {
    return _id_isScrollbarFadingEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_getScrollBarDefaultDelayBeforeFade = _class.instanceMethodId(
    r"getScrollBarDefaultDelayBeforeFade",
    r"()I",
  );

  /// from: public int getScrollBarDefaultDelayBeforeFade()
  int getScrollBarDefaultDelayBeforeFade() {
    return _id_getScrollBarDefaultDelayBeforeFade(
        this, const jni.jintType(), []);
  }

  static final _id_setScrollBarDefaultDelayBeforeFade = _class.instanceMethodId(
    r"setScrollBarDefaultDelayBeforeFade",
    r"(I)V",
  );

  /// from: public void setScrollBarDefaultDelayBeforeFade(int i)
  void setScrollBarDefaultDelayBeforeFade(
    int i,
  ) {
    _id_setScrollBarDefaultDelayBeforeFade(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getScrollBarFadeDuration = _class.instanceMethodId(
    r"getScrollBarFadeDuration",
    r"()I",
  );

  /// from: public int getScrollBarFadeDuration()
  int getScrollBarFadeDuration() {
    return _id_getScrollBarFadeDuration(this, const jni.jintType(), []);
  }

  static final _id_setScrollBarFadeDuration = _class.instanceMethodId(
    r"setScrollBarFadeDuration",
    r"(I)V",
  );

  /// from: public void setScrollBarFadeDuration(int i)
  void setScrollBarFadeDuration(
    int i,
  ) {
    _id_setScrollBarFadeDuration(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getScrollBarSize = _class.instanceMethodId(
    r"getScrollBarSize",
    r"()I",
  );

  /// from: public int getScrollBarSize()
  int getScrollBarSize() {
    return _id_getScrollBarSize(this, const jni.jintType(), []);
  }

  static final _id_setScrollBarSize = _class.instanceMethodId(
    r"setScrollBarSize",
    r"(I)V",
  );

  /// from: public void setScrollBarSize(int i)
  void setScrollBarSize(
    int i,
  ) {
    _id_setScrollBarSize(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setScrollBarStyle = _class.instanceMethodId(
    r"setScrollBarStyle",
    r"(I)V",
  );

  /// from: public void setScrollBarStyle(int i)
  void setScrollBarStyle(
    int i,
  ) {
    _id_setScrollBarStyle(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getScrollBarStyle = _class.instanceMethodId(
    r"getScrollBarStyle",
    r"()I",
  );

  /// from: public int getScrollBarStyle()
  int getScrollBarStyle() {
    return _id_getScrollBarStyle(this, const jni.jintType(), []);
  }

  static final _id_computeHorizontalScrollRange = _class.instanceMethodId(
    r"computeHorizontalScrollRange",
    r"()I",
  );

  /// from: protected int computeHorizontalScrollRange()
  int computeHorizontalScrollRange() {
    return _id_computeHorizontalScrollRange(this, const jni.jintType(), []);
  }

  static final _id_computeHorizontalScrollOffset = _class.instanceMethodId(
    r"computeHorizontalScrollOffset",
    r"()I",
  );

  /// from: protected int computeHorizontalScrollOffset()
  int computeHorizontalScrollOffset() {
    return _id_computeHorizontalScrollOffset(this, const jni.jintType(), []);
  }

  static final _id_computeHorizontalScrollExtent = _class.instanceMethodId(
    r"computeHorizontalScrollExtent",
    r"()I",
  );

  /// from: protected int computeHorizontalScrollExtent()
  int computeHorizontalScrollExtent() {
    return _id_computeHorizontalScrollExtent(this, const jni.jintType(), []);
  }

  static final _id_computeVerticalScrollRange = _class.instanceMethodId(
    r"computeVerticalScrollRange",
    r"()I",
  );

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange() {
    return _id_computeVerticalScrollRange(this, const jni.jintType(), []);
  }

  static final _id_computeVerticalScrollOffset = _class.instanceMethodId(
    r"computeVerticalScrollOffset",
    r"()I",
  );

  /// from: protected int computeVerticalScrollOffset()
  int computeVerticalScrollOffset() {
    return _id_computeVerticalScrollOffset(this, const jni.jintType(), []);
  }

  static final _id_computeVerticalScrollExtent = _class.instanceMethodId(
    r"computeVerticalScrollExtent",
    r"()I",
  );

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent() {
    return _id_computeVerticalScrollExtent(this, const jni.jintType(), []);
  }

  static final _id_canScrollHorizontally = _class.instanceMethodId(
    r"canScrollHorizontally",
    r"(I)Z",
  );

  /// from: public boolean canScrollHorizontally(int i)
  bool canScrollHorizontally(
    int i,
  ) {
    return _id_canScrollHorizontally(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_canScrollVertically = _class.instanceMethodId(
    r"canScrollVertically",
    r"(I)Z",
  );

  /// from: public boolean canScrollVertically(int i)
  bool canScrollVertically(
    int i,
  ) {
    return _id_canScrollVertically(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_onDrawScrollBars = _class.instanceMethodId(
    r"onDrawScrollBars",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: protected final void onDrawScrollBars(android.graphics.Canvas canvas)
  void onDrawScrollBars(
    jni.JObject canvas,
  ) {
    _id_onDrawScrollBars(
        this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_onDraw = _class.instanceMethodId(
    r"onDraw",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(
    jni.JObject canvas,
  ) {
    _id_onDraw(this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_onAttachedToWindow = _class.instanceMethodId(
    r"onAttachedToWindow",
    r"()V",
  );

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() {
    _id_onAttachedToWindow(this, const jni.jvoidType(), []);
  }

  static final _id_onScreenStateChanged = _class.instanceMethodId(
    r"onScreenStateChanged",
    r"(I)V",
  );

  /// from: public void onScreenStateChanged(int i)
  void onScreenStateChanged(
    int i,
  ) {
    _id_onScreenStateChanged(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_onRtlPropertiesChanged = _class.instanceMethodId(
    r"onRtlPropertiesChanged",
    r"(I)V",
  );

  /// from: public void onRtlPropertiesChanged(int i)
  void onRtlPropertiesChanged(
    int i,
  ) {
    _id_onRtlPropertiesChanged(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_canResolveLayoutDirection = _class.instanceMethodId(
    r"canResolveLayoutDirection",
    r"()Z",
  );

  /// from: public boolean canResolveLayoutDirection()
  bool canResolveLayoutDirection() {
    return _id_canResolveLayoutDirection(this, const jni.jbooleanType(), []);
  }

  static final _id_isLayoutDirectionResolved = _class.instanceMethodId(
    r"isLayoutDirectionResolved",
    r"()Z",
  );

  /// from: public boolean isLayoutDirectionResolved()
  bool isLayoutDirectionResolved() {
    return _id_isLayoutDirectionResolved(this, const jni.jbooleanType(), []);
  }

  static final _id_onDetachedFromWindow = _class.instanceMethodId(
    r"onDetachedFromWindow",
    r"()V",
  );

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() {
    _id_onDetachedFromWindow(this, const jni.jvoidType(), []);
  }

  static final _id_getWindowAttachCount = _class.instanceMethodId(
    r"getWindowAttachCount",
    r"()I",
  );

  /// from: protected int getWindowAttachCount()
  int getWindowAttachCount() {
    return _id_getWindowAttachCount(this, const jni.jintType(), []);
  }

  static final _id_getWindowToken = _class.instanceMethodId(
    r"getWindowToken",
    r"()Landroid/os/IBinder;",
  );

  /// from: public android.os.IBinder getWindowToken()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowToken() {
    return _id_getWindowToken(this, const jni.JObjectType(), []);
  }

  static final _id_getWindowId = _class.instanceMethodId(
    r"getWindowId",
    r"()Landroid/view/WindowId;",
  );

  /// from: public android.view.WindowId getWindowId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowId() {
    return _id_getWindowId(this, const jni.JObjectType(), []);
  }

  static final _id_getApplicationWindowToken = _class.instanceMethodId(
    r"getApplicationWindowToken",
    r"()Landroid/os/IBinder;",
  );

  /// from: public android.os.IBinder getApplicationWindowToken()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getApplicationWindowToken() {
    return _id_getApplicationWindowToken(this, const jni.JObjectType(), []);
  }

  static final _id_getDisplay = _class.instanceMethodId(
    r"getDisplay",
    r"()Landroid/view/Display;",
  );

  /// from: public android.view.Display getDisplay()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDisplay() {
    return _id_getDisplay(this, const jni.JObjectType(), []);
  }

  static final _id_cancelPendingInputEvents = _class.instanceMethodId(
    r"cancelPendingInputEvents",
    r"()V",
  );

  /// from: public final void cancelPendingInputEvents()
  void cancelPendingInputEvents() {
    _id_cancelPendingInputEvents(this, const jni.jvoidType(), []);
  }

  static final _id_onCancelPendingInputEvents = _class.instanceMethodId(
    r"onCancelPendingInputEvents",
    r"()V",
  );

  /// from: public void onCancelPendingInputEvents()
  void onCancelPendingInputEvents() {
    _id_onCancelPendingInputEvents(this, const jni.jvoidType(), []);
  }

  static final _id_saveHierarchyState = _class.instanceMethodId(
    r"saveHierarchyState",
    r"(Landroid/util/SparseArray;)V",
  );

  /// from: public void saveHierarchyState(android.util.SparseArray sparseArray)
  void saveHierarchyState(
    jni.JObject sparseArray,
  ) {
    _id_saveHierarchyState(
        this, const jni.jvoidType(), [sparseArray.reference.pointer]);
  }

  static final _id_dispatchSaveInstanceState = _class.instanceMethodId(
    r"dispatchSaveInstanceState",
    r"(Landroid/util/SparseArray;)V",
  );

  /// from: protected void dispatchSaveInstanceState(android.util.SparseArray sparseArray)
  void dispatchSaveInstanceState(
    jni.JObject sparseArray,
  ) {
    _id_dispatchSaveInstanceState(
        this, const jni.jvoidType(), [sparseArray.reference.pointer]);
  }

  static final _id_onSaveInstanceState = _class.instanceMethodId(
    r"onSaveInstanceState",
    r"()Landroid/os/Parcelable;",
  );

  /// from: protected android.os.Parcelable onSaveInstanceState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onSaveInstanceState() {
    return _id_onSaveInstanceState(this, const jni.JObjectType(), []);
  }

  static final _id_restoreHierarchyState = _class.instanceMethodId(
    r"restoreHierarchyState",
    r"(Landroid/util/SparseArray;)V",
  );

  /// from: public void restoreHierarchyState(android.util.SparseArray sparseArray)
  void restoreHierarchyState(
    jni.JObject sparseArray,
  ) {
    _id_restoreHierarchyState(
        this, const jni.jvoidType(), [sparseArray.reference.pointer]);
  }

  static final _id_dispatchRestoreInstanceState = _class.instanceMethodId(
    r"dispatchRestoreInstanceState",
    r"(Landroid/util/SparseArray;)V",
  );

  /// from: protected void dispatchRestoreInstanceState(android.util.SparseArray sparseArray)
  void dispatchRestoreInstanceState(
    jni.JObject sparseArray,
  ) {
    _id_dispatchRestoreInstanceState(
        this, const jni.jvoidType(), [sparseArray.reference.pointer]);
  }

  static final _id_onRestoreInstanceState = _class.instanceMethodId(
    r"onRestoreInstanceState",
    r"(Landroid/os/Parcelable;)V",
  );

  /// from: protected void onRestoreInstanceState(android.os.Parcelable parcelable)
  void onRestoreInstanceState(
    jni.JObject parcelable,
  ) {
    _id_onRestoreInstanceState(
        this, const jni.jvoidType(), [parcelable.reference.pointer]);
  }

  static final _id_getDrawingTime = _class.instanceMethodId(
    r"getDrawingTime",
    r"()J",
  );

  /// from: public long getDrawingTime()
  int getDrawingTime() {
    return _id_getDrawingTime(this, const jni.jlongType(), []);
  }

  static final _id_setDuplicateParentStateEnabled = _class.instanceMethodId(
    r"setDuplicateParentStateEnabled",
    r"(Z)V",
  );

  /// from: public void setDuplicateParentStateEnabled(boolean z)
  void setDuplicateParentStateEnabled(
    bool z,
  ) {
    _id_setDuplicateParentStateEnabled(
        this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isDuplicateParentStateEnabled = _class.instanceMethodId(
    r"isDuplicateParentStateEnabled",
    r"()Z",
  );

  /// from: public boolean isDuplicateParentStateEnabled()
  bool isDuplicateParentStateEnabled() {
    return _id_isDuplicateParentStateEnabled(
        this, const jni.jbooleanType(), []);
  }

  static final _id_setLayerType = _class.instanceMethodId(
    r"setLayerType",
    r"(ILandroid/graphics/Paint;)V",
  );

  /// from: public void setLayerType(int i, android.graphics.Paint paint)
  void setLayerType(
    int i,
    jni.JObject paint,
  ) {
    _id_setLayerType(this, const jni.jvoidType(),
        [jni.JValueInt(i), paint.reference.pointer]);
  }

  static final _id_setRenderEffect = _class.instanceMethodId(
    r"setRenderEffect",
    r"(Landroid/graphics/RenderEffect;)V",
  );

  /// from: public void setRenderEffect(android.graphics.RenderEffect renderEffect)
  void setRenderEffect(
    jni.JObject renderEffect,
  ) {
    _id_setRenderEffect(
        this, const jni.jvoidType(), [renderEffect.reference.pointer]);
  }

  static final _id_setLayerPaint = _class.instanceMethodId(
    r"setLayerPaint",
    r"(Landroid/graphics/Paint;)V",
  );

  /// from: public void setLayerPaint(android.graphics.Paint paint)
  void setLayerPaint(
    jni.JObject paint,
  ) {
    _id_setLayerPaint(this, const jni.jvoidType(), [paint.reference.pointer]);
  }

  static final _id_getLayerType = _class.instanceMethodId(
    r"getLayerType",
    r"()I",
  );

  /// from: public int getLayerType()
  int getLayerType() {
    return _id_getLayerType(this, const jni.jintType(), []);
  }

  static final _id_buildLayer = _class.instanceMethodId(
    r"buildLayer",
    r"()V",
  );

  /// from: public void buildLayer()
  void buildLayer() {
    _id_buildLayer(this, const jni.jvoidType(), []);
  }

  static final _id_setDrawingCacheEnabled = _class.instanceMethodId(
    r"setDrawingCacheEnabled",
    r"(Z)V",
  );

  /// from: public void setDrawingCacheEnabled(boolean z)
  void setDrawingCacheEnabled(
    bool z,
  ) {
    _id_setDrawingCacheEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isDrawingCacheEnabled = _class.instanceMethodId(
    r"isDrawingCacheEnabled",
    r"()Z",
  );

  /// from: public boolean isDrawingCacheEnabled()
  bool isDrawingCacheEnabled() {
    return _id_isDrawingCacheEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_getDrawingCache = _class.instanceMethodId(
    r"getDrawingCache",
    r"()Landroid/graphics/Bitmap;",
  );

  /// from: public android.graphics.Bitmap getDrawingCache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDrawingCache() {
    return _id_getDrawingCache(this, const jni.JObjectType(), []);
  }

  static final _id_getDrawingCache1 = _class.instanceMethodId(
    r"getDrawingCache",
    r"(Z)Landroid/graphics/Bitmap;",
  );

  /// from: public android.graphics.Bitmap getDrawingCache(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDrawingCache1(
    bool z,
  ) {
    return _id_getDrawingCache1(this, const jni.JObjectType(), [z ? 1 : 0]);
  }

  static final _id_destroyDrawingCache = _class.instanceMethodId(
    r"destroyDrawingCache",
    r"()V",
  );

  /// from: public void destroyDrawingCache()
  void destroyDrawingCache() {
    _id_destroyDrawingCache(this, const jni.jvoidType(), []);
  }

  static final _id_setDrawingCacheBackgroundColor = _class.instanceMethodId(
    r"setDrawingCacheBackgroundColor",
    r"(I)V",
  );

  /// from: public void setDrawingCacheBackgroundColor(int i)
  void setDrawingCacheBackgroundColor(
    int i,
  ) {
    _id_setDrawingCacheBackgroundColor(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getDrawingCacheBackgroundColor = _class.instanceMethodId(
    r"getDrawingCacheBackgroundColor",
    r"()I",
  );

  /// from: public int getDrawingCacheBackgroundColor()
  int getDrawingCacheBackgroundColor() {
    return _id_getDrawingCacheBackgroundColor(this, const jni.jintType(), []);
  }

  static final _id_buildDrawingCache = _class.instanceMethodId(
    r"buildDrawingCache",
    r"()V",
  );

  /// from: public void buildDrawingCache()
  void buildDrawingCache() {
    _id_buildDrawingCache(this, const jni.jvoidType(), []);
  }

  static final _id_buildDrawingCache1 = _class.instanceMethodId(
    r"buildDrawingCache",
    r"(Z)V",
  );

  /// from: public void buildDrawingCache(boolean z)
  void buildDrawingCache1(
    bool z,
  ) {
    _id_buildDrawingCache1(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isInEditMode = _class.instanceMethodId(
    r"isInEditMode",
    r"()Z",
  );

  /// from: public boolean isInEditMode()
  bool isInEditMode() {
    return _id_isInEditMode(this, const jni.jbooleanType(), []);
  }

  static final _id_isPaddingOffsetRequired = _class.instanceMethodId(
    r"isPaddingOffsetRequired",
    r"()Z",
  );

  /// from: protected boolean isPaddingOffsetRequired()
  bool isPaddingOffsetRequired() {
    return _id_isPaddingOffsetRequired(this, const jni.jbooleanType(), []);
  }

  static final _id_getLeftPaddingOffset = _class.instanceMethodId(
    r"getLeftPaddingOffset",
    r"()I",
  );

  /// from: protected int getLeftPaddingOffset()
  int getLeftPaddingOffset() {
    return _id_getLeftPaddingOffset(this, const jni.jintType(), []);
  }

  static final _id_getRightPaddingOffset = _class.instanceMethodId(
    r"getRightPaddingOffset",
    r"()I",
  );

  /// from: protected int getRightPaddingOffset()
  int getRightPaddingOffset() {
    return _id_getRightPaddingOffset(this, const jni.jintType(), []);
  }

  static final _id_getTopPaddingOffset = _class.instanceMethodId(
    r"getTopPaddingOffset",
    r"()I",
  );

  /// from: protected int getTopPaddingOffset()
  int getTopPaddingOffset() {
    return _id_getTopPaddingOffset(this, const jni.jintType(), []);
  }

  static final _id_getBottomPaddingOffset = _class.instanceMethodId(
    r"getBottomPaddingOffset",
    r"()I",
  );

  /// from: protected int getBottomPaddingOffset()
  int getBottomPaddingOffset() {
    return _id_getBottomPaddingOffset(this, const jni.jintType(), []);
  }

  static final _id_isHardwareAccelerated = _class.instanceMethodId(
    r"isHardwareAccelerated",
    r"()Z",
  );

  /// from: public boolean isHardwareAccelerated()
  bool isHardwareAccelerated() {
    return _id_isHardwareAccelerated(this, const jni.jbooleanType(), []);
  }

  static final _id_setClipBounds = _class.instanceMethodId(
    r"setClipBounds",
    r"(Landroid/graphics/Rect;)V",
  );

  /// from: public void setClipBounds(android.graphics.Rect rect)
  void setClipBounds(
    jni.JObject rect,
  ) {
    _id_setClipBounds(this, const jni.jvoidType(), [rect.reference.pointer]);
  }

  static final _id_getClipBounds = _class.instanceMethodId(
    r"getClipBounds",
    r"()Landroid/graphics/Rect;",
  );

  /// from: public android.graphics.Rect getClipBounds()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getClipBounds() {
    return _id_getClipBounds(this, const jni.JObjectType(), []);
  }

  static final _id_getClipBounds1 = _class.instanceMethodId(
    r"getClipBounds",
    r"(Landroid/graphics/Rect;)Z",
  );

  /// from: public boolean getClipBounds(android.graphics.Rect rect)
  bool getClipBounds1(
    jni.JObject rect,
  ) {
    return _id_getClipBounds1(
        this, const jni.jbooleanType(), [rect.reference.pointer]);
  }

  static final _id_draw = _class.instanceMethodId(
    r"draw",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(
    jni.JObject canvas,
  ) {
    _id_draw(this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_getOverlay = _class.instanceMethodId(
    r"getOverlay",
    r"()Landroid/view/ViewOverlay;",
  );

  /// from: public android.view.ViewOverlay getOverlay()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOverlay() {
    return _id_getOverlay(this, const jni.JObjectType(), []);
  }

  static final _id_getSolidColor = _class.instanceMethodId(
    r"getSolidColor",
    r"()I",
  );

  /// from: public int getSolidColor()
  int getSolidColor() {
    return _id_getSolidColor(this, const jni.jintType(), []);
  }

  static final _id_isLayoutRequested = _class.instanceMethodId(
    r"isLayoutRequested",
    r"()Z",
  );

  /// from: public boolean isLayoutRequested()
  bool isLayoutRequested() {
    return _id_isLayoutRequested(this, const jni.jbooleanType(), []);
  }

  static final _id_layout = _class.instanceMethodId(
    r"layout",
    r"(IIII)V",
  );

  /// from: public void layout(int i, int i1, int i2, int i3)
  void layout(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_layout(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_onLayout = _class.instanceMethodId(
    r"onLayout",
    r"(ZIIII)V",
  );

  /// from: protected void onLayout(boolean z, int i, int i1, int i2, int i3)
  void onLayout(
    bool z,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_onLayout(this, const jni.jvoidType(), [
      z ? 1 : 0,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_setLeftTopRightBottom = _class.instanceMethodId(
    r"setLeftTopRightBottom",
    r"(IIII)V",
  );

  /// from: public final void setLeftTopRightBottom(int i, int i1, int i2, int i3)
  void setLeftTopRightBottom(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_setLeftTopRightBottom(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_onFinishInflate = _class.instanceMethodId(
    r"onFinishInflate",
    r"()V",
  );

  /// from: protected void onFinishInflate()
  void onFinishInflate() {
    _id_onFinishInflate(this, const jni.jvoidType(), []);
  }

  static final _id_getResources = _class.instanceMethodId(
    r"getResources",
    r"()Landroid/content/res/Resources;",
  );

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getResources() {
    return _id_getResources(this, const jni.JObjectType(), []);
  }

  static final _id_invalidateDrawable = _class.instanceMethodId(
    r"invalidateDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable drawable)
  void invalidateDrawable(
    jni.JObject drawable,
  ) {
    _id_invalidateDrawable(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_scheduleDrawable = _class.instanceMethodId(
    r"scheduleDrawable",
    r"(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V",
  );

  /// from: public void scheduleDrawable(android.graphics.drawable.Drawable drawable, java.lang.Runnable runnable, long j)
  void scheduleDrawable(
    jni.JObject drawable,
    jni.JObject runnable,
    int j,
  ) {
    _id_scheduleDrawable(this, const jni.jvoidType(),
        [drawable.reference.pointer, runnable.reference.pointer, j]);
  }

  static final _id_unscheduleDrawable = _class.instanceMethodId(
    r"unscheduleDrawable",
    r"(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V",
  );

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable drawable, java.lang.Runnable runnable)
  void unscheduleDrawable(
    jni.JObject drawable,
    jni.JObject runnable,
  ) {
    _id_unscheduleDrawable(this, const jni.jvoidType(),
        [drawable.reference.pointer, runnable.reference.pointer]);
  }

  static final _id_unscheduleDrawable1 = _class.instanceMethodId(
    r"unscheduleDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable drawable)
  void unscheduleDrawable1(
    jni.JObject drawable,
  ) {
    _id_unscheduleDrawable1(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_verifyDrawable = _class.instanceMethodId(
    r"verifyDrawable",
    r"(Landroid/graphics/drawable/Drawable;)Z",
  );

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable drawable)
  bool verifyDrawable(
    jni.JObject drawable,
  ) {
    return _id_verifyDrawable(
        this, const jni.jbooleanType(), [drawable.reference.pointer]);
  }

  static final _id_drawableStateChanged = _class.instanceMethodId(
    r"drawableStateChanged",
    r"()V",
  );

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() {
    _id_drawableStateChanged(this, const jni.jvoidType(), []);
  }

  static final _id_drawableHotspotChanged = _class.instanceMethodId(
    r"drawableHotspotChanged",
    r"(FF)V",
  );

  /// from: public void drawableHotspotChanged(float f, float f1)
  void drawableHotspotChanged(
    double f,
    double f1,
  ) {
    _id_drawableHotspotChanged(
        this, const jni.jvoidType(), [jni.JValueFloat(f), jni.JValueFloat(f1)]);
  }

  static final _id_dispatchDrawableHotspotChanged = _class.instanceMethodId(
    r"dispatchDrawableHotspotChanged",
    r"(FF)V",
  );

  /// from: public void dispatchDrawableHotspotChanged(float f, float f1)
  void dispatchDrawableHotspotChanged(
    double f,
    double f1,
  ) {
    _id_dispatchDrawableHotspotChanged(
        this, const jni.jvoidType(), [jni.JValueFloat(f), jni.JValueFloat(f1)]);
  }

  static final _id_refreshDrawableState = _class.instanceMethodId(
    r"refreshDrawableState",
    r"()V",
  );

  /// from: public void refreshDrawableState()
  void refreshDrawableState() {
    _id_refreshDrawableState(this, const jni.jvoidType(), []);
  }

  static final _id_getDrawableState = _class.instanceMethodId(
    r"getDrawableState",
    r"()[I",
  );

  /// from: public final int[] getDrawableState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getDrawableState() {
    return _id_getDrawableState(this, const jni.JArrayType(jni.jintType()), []);
  }

  static final _id_onCreateDrawableState = _class.instanceMethodId(
    r"onCreateDrawableState",
    r"(I)[I",
  );

  /// from: protected int[] onCreateDrawableState(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> onCreateDrawableState(
    int i,
  ) {
    return _id_onCreateDrawableState(
        this, const jni.JArrayType(jni.jintType()), [jni.JValueInt(i)]);
  }

  static final _id_mergeDrawableStates = _class.staticMethodId(
    r"mergeDrawableStates",
    r"([I[I)[I",
  );

  /// from: static protected int[] mergeDrawableStates(int[] is, int[] is1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> mergeDrawableStates(
    jni.JArray<jni.jint> is0,
    jni.JArray<jni.jint> is1,
  ) {
    return _id_mergeDrawableStates(_class, const jni.JArrayType(jni.jintType()),
        [is0.reference.pointer, is1.reference.pointer]);
  }

  static final _id_jumpDrawablesToCurrentState = _class.instanceMethodId(
    r"jumpDrawablesToCurrentState",
    r"()V",
  );

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() {
    _id_jumpDrawablesToCurrentState(this, const jni.jvoidType(), []);
  }

  static final _id_setBackgroundColor = _class.instanceMethodId(
    r"setBackgroundColor",
    r"(I)V",
  );

  /// from: public void setBackgroundColor(int i)
  void setBackgroundColor(
    int i,
  ) {
    _id_setBackgroundColor(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setBackgroundResource = _class.instanceMethodId(
    r"setBackgroundResource",
    r"(I)V",
  );

  /// from: public void setBackgroundResource(int i)
  void setBackgroundResource(
    int i,
  ) {
    _id_setBackgroundResource(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setBackground = _class.instanceMethodId(
    r"setBackground",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setBackground(android.graphics.drawable.Drawable drawable)
  void setBackground(
    jni.JObject drawable,
  ) {
    _id_setBackground(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_setBackgroundDrawable = _class.instanceMethodId(
    r"setBackgroundDrawable",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setBackgroundDrawable(android.graphics.drawable.Drawable drawable)
  void setBackgroundDrawable(
    jni.JObject drawable,
  ) {
    _id_setBackgroundDrawable(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_getBackground = _class.instanceMethodId(
    r"getBackground",
    r"()Landroid/graphics/drawable/Drawable;",
  );

  /// from: public android.graphics.drawable.Drawable getBackground()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackground() {
    return _id_getBackground(this, const jni.JObjectType(), []);
  }

  static final _id_setBackgroundTintList = _class.instanceMethodId(
    r"setBackgroundTintList",
    r"(Landroid/content/res/ColorStateList;)V",
  );

  /// from: public void setBackgroundTintList(android.content.res.ColorStateList colorStateList)
  void setBackgroundTintList(
    jni.JObject colorStateList,
  ) {
    _id_setBackgroundTintList(
        this, const jni.jvoidType(), [colorStateList.reference.pointer]);
  }

  static final _id_getBackgroundTintList = _class.instanceMethodId(
    r"getBackgroundTintList",
    r"()Landroid/content/res/ColorStateList;",
  );

  /// from: public android.content.res.ColorStateList getBackgroundTintList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackgroundTintList() {
    return _id_getBackgroundTintList(this, const jni.JObjectType(), []);
  }

  static final _id_setBackgroundTintMode = _class.instanceMethodId(
    r"setBackgroundTintMode",
    r"(Landroid/graphics/PorterDuff$Mode;)V",
  );

  /// from: public void setBackgroundTintMode(android.graphics.PorterDuff$Mode mode)
  void setBackgroundTintMode(
    jni.JObject mode,
  ) {
    _id_setBackgroundTintMode(
        this, const jni.jvoidType(), [mode.reference.pointer]);
  }

  static final _id_setBackgroundTintBlendMode = _class.instanceMethodId(
    r"setBackgroundTintBlendMode",
    r"(Landroid/graphics/BlendMode;)V",
  );

  /// from: public void setBackgroundTintBlendMode(android.graphics.BlendMode blendMode)
  void setBackgroundTintBlendMode(
    jni.JObject blendMode,
  ) {
    _id_setBackgroundTintBlendMode(
        this, const jni.jvoidType(), [blendMode.reference.pointer]);
  }

  static final _id_getBackgroundTintMode = _class.instanceMethodId(
    r"getBackgroundTintMode",
    r"()Landroid/graphics/PorterDuff$Mode;",
  );

  /// from: public android.graphics.PorterDuff$Mode getBackgroundTintMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackgroundTintMode() {
    return _id_getBackgroundTintMode(this, const jni.JObjectType(), []);
  }

  static final _id_getBackgroundTintBlendMode = _class.instanceMethodId(
    r"getBackgroundTintBlendMode",
    r"()Landroid/graphics/BlendMode;",
  );

  /// from: public android.graphics.BlendMode getBackgroundTintBlendMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackgroundTintBlendMode() {
    return _id_getBackgroundTintBlendMode(this, const jni.JObjectType(), []);
  }

  static final _id_getForeground = _class.instanceMethodId(
    r"getForeground",
    r"()Landroid/graphics/drawable/Drawable;",
  );

  /// from: public android.graphics.drawable.Drawable getForeground()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForeground() {
    return _id_getForeground(this, const jni.JObjectType(), []);
  }

  static final _id_setForeground = _class.instanceMethodId(
    r"setForeground",
    r"(Landroid/graphics/drawable/Drawable;)V",
  );

  /// from: public void setForeground(android.graphics.drawable.Drawable drawable)
  void setForeground(
    jni.JObject drawable,
  ) {
    _id_setForeground(
        this, const jni.jvoidType(), [drawable.reference.pointer]);
  }

  static final _id_getForegroundGravity = _class.instanceMethodId(
    r"getForegroundGravity",
    r"()I",
  );

  /// from: public int getForegroundGravity()
  int getForegroundGravity() {
    return _id_getForegroundGravity(this, const jni.jintType(), []);
  }

  static final _id_setForegroundGravity = _class.instanceMethodId(
    r"setForegroundGravity",
    r"(I)V",
  );

  /// from: public void setForegroundGravity(int i)
  void setForegroundGravity(
    int i,
  ) {
    _id_setForegroundGravity(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setForegroundTintList = _class.instanceMethodId(
    r"setForegroundTintList",
    r"(Landroid/content/res/ColorStateList;)V",
  );

  /// from: public void setForegroundTintList(android.content.res.ColorStateList colorStateList)
  void setForegroundTintList(
    jni.JObject colorStateList,
  ) {
    _id_setForegroundTintList(
        this, const jni.jvoidType(), [colorStateList.reference.pointer]);
  }

  static final _id_getForegroundTintList = _class.instanceMethodId(
    r"getForegroundTintList",
    r"()Landroid/content/res/ColorStateList;",
  );

  /// from: public android.content.res.ColorStateList getForegroundTintList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForegroundTintList() {
    return _id_getForegroundTintList(this, const jni.JObjectType(), []);
  }

  static final _id_setForegroundTintMode = _class.instanceMethodId(
    r"setForegroundTintMode",
    r"(Landroid/graphics/PorterDuff$Mode;)V",
  );

  /// from: public void setForegroundTintMode(android.graphics.PorterDuff$Mode mode)
  void setForegroundTintMode(
    jni.JObject mode,
  ) {
    _id_setForegroundTintMode(
        this, const jni.jvoidType(), [mode.reference.pointer]);
  }

  static final _id_setForegroundTintBlendMode = _class.instanceMethodId(
    r"setForegroundTintBlendMode",
    r"(Landroid/graphics/BlendMode;)V",
  );

  /// from: public void setForegroundTintBlendMode(android.graphics.BlendMode blendMode)
  void setForegroundTintBlendMode(
    jni.JObject blendMode,
  ) {
    _id_setForegroundTintBlendMode(
        this, const jni.jvoidType(), [blendMode.reference.pointer]);
  }

  static final _id_getForegroundTintMode = _class.instanceMethodId(
    r"getForegroundTintMode",
    r"()Landroid/graphics/PorterDuff$Mode;",
  );

  /// from: public android.graphics.PorterDuff$Mode getForegroundTintMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForegroundTintMode() {
    return _id_getForegroundTintMode(this, const jni.JObjectType(), []);
  }

  static final _id_getForegroundTintBlendMode = _class.instanceMethodId(
    r"getForegroundTintBlendMode",
    r"()Landroid/graphics/BlendMode;",
  );

  /// from: public android.graphics.BlendMode getForegroundTintBlendMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForegroundTintBlendMode() {
    return _id_getForegroundTintBlendMode(this, const jni.JObjectType(), []);
  }

  static final _id_onDrawForeground = _class.instanceMethodId(
    r"onDrawForeground",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: public void onDrawForeground(android.graphics.Canvas canvas)
  void onDrawForeground(
    jni.JObject canvas,
  ) {
    _id_onDrawForeground(
        this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_setPadding = _class.instanceMethodId(
    r"setPadding",
    r"(IIII)V",
  );

  /// from: public void setPadding(int i, int i1, int i2, int i3)
  void setPadding(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_setPadding(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_setPaddingRelative = _class.instanceMethodId(
    r"setPaddingRelative",
    r"(IIII)V",
  );

  /// from: public void setPaddingRelative(int i, int i1, int i2, int i3)
  void setPaddingRelative(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_setPaddingRelative(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_getSourceLayoutResId = _class.instanceMethodId(
    r"getSourceLayoutResId",
    r"()I",
  );

  /// from: public int getSourceLayoutResId()
  int getSourceLayoutResId() {
    return _id_getSourceLayoutResId(this, const jni.jintType(), []);
  }

  static final _id_getPaddingTop = _class.instanceMethodId(
    r"getPaddingTop",
    r"()I",
  );

  /// from: public int getPaddingTop()
  int getPaddingTop() {
    return _id_getPaddingTop(this, const jni.jintType(), []);
  }

  static final _id_getPaddingBottom = _class.instanceMethodId(
    r"getPaddingBottom",
    r"()I",
  );

  /// from: public int getPaddingBottom()
  int getPaddingBottom() {
    return _id_getPaddingBottom(this, const jni.jintType(), []);
  }

  static final _id_getPaddingLeft = _class.instanceMethodId(
    r"getPaddingLeft",
    r"()I",
  );

  /// from: public int getPaddingLeft()
  int getPaddingLeft() {
    return _id_getPaddingLeft(this, const jni.jintType(), []);
  }

  static final _id_getPaddingStart = _class.instanceMethodId(
    r"getPaddingStart",
    r"()I",
  );

  /// from: public int getPaddingStart()
  int getPaddingStart() {
    return _id_getPaddingStart(this, const jni.jintType(), []);
  }

  static final _id_getPaddingRight = _class.instanceMethodId(
    r"getPaddingRight",
    r"()I",
  );

  /// from: public int getPaddingRight()
  int getPaddingRight() {
    return _id_getPaddingRight(this, const jni.jintType(), []);
  }

  static final _id_getPaddingEnd = _class.instanceMethodId(
    r"getPaddingEnd",
    r"()I",
  );

  /// from: public int getPaddingEnd()
  int getPaddingEnd() {
    return _id_getPaddingEnd(this, const jni.jintType(), []);
  }

  static final _id_isPaddingRelative = _class.instanceMethodId(
    r"isPaddingRelative",
    r"()Z",
  );

  /// from: public boolean isPaddingRelative()
  bool isPaddingRelative() {
    return _id_isPaddingRelative(this, const jni.jbooleanType(), []);
  }

  static final _id_setSelected = _class.instanceMethodId(
    r"setSelected",
    r"(Z)V",
  );

  /// from: public void setSelected(boolean z)
  void setSelected(
    bool z,
  ) {
    _id_setSelected(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_dispatchSetSelected = _class.instanceMethodId(
    r"dispatchSetSelected",
    r"(Z)V",
  );

  /// from: protected void dispatchSetSelected(boolean z)
  void dispatchSetSelected(
    bool z,
  ) {
    _id_dispatchSetSelected(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isSelected = _class.instanceMethodId(
    r"isSelected",
    r"()Z",
  );

  /// from: public boolean isSelected()
  bool isSelected() {
    return _id_isSelected(this, const jni.jbooleanType(), []);
  }

  static final _id_setActivated = _class.instanceMethodId(
    r"setActivated",
    r"(Z)V",
  );

  /// from: public void setActivated(boolean z)
  void setActivated(
    bool z,
  ) {
    _id_setActivated(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_dispatchSetActivated = _class.instanceMethodId(
    r"dispatchSetActivated",
    r"(Z)V",
  );

  /// from: protected void dispatchSetActivated(boolean z)
  void dispatchSetActivated(
    bool z,
  ) {
    _id_dispatchSetActivated(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isActivated = _class.instanceMethodId(
    r"isActivated",
    r"()Z",
  );

  /// from: public boolean isActivated()
  bool isActivated() {
    return _id_isActivated(this, const jni.jbooleanType(), []);
  }

  static final _id_getViewTreeObserver = _class.instanceMethodId(
    r"getViewTreeObserver",
    r"()Landroid/view/ViewTreeObserver;",
  );

  /// from: public android.view.ViewTreeObserver getViewTreeObserver()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getViewTreeObserver() {
    return _id_getViewTreeObserver(this, const jni.JObjectType(), []);
  }

  static final _id_getRootView = _class.instanceMethodId(
    r"getRootView",
    r"()Landroid/view/View;",
  );

  /// from: public android.view.View getRootView()
  /// The returned object must be released after use, by calling the [release] method.
  View getRootView() {
    return _id_getRootView(this, const $ViewType(), []);
  }

  static final _id_transformMatrixToGlobal = _class.instanceMethodId(
    r"transformMatrixToGlobal",
    r"(Landroid/graphics/Matrix;)V",
  );

  /// from: public void transformMatrixToGlobal(android.graphics.Matrix matrix)
  void transformMatrixToGlobal(
    jni.JObject matrix,
  ) {
    _id_transformMatrixToGlobal(
        this, const jni.jvoidType(), [matrix.reference.pointer]);
  }

  static final _id_transformMatrixToLocal = _class.instanceMethodId(
    r"transformMatrixToLocal",
    r"(Landroid/graphics/Matrix;)V",
  );

  /// from: public void transformMatrixToLocal(android.graphics.Matrix matrix)
  void transformMatrixToLocal(
    jni.JObject matrix,
  ) {
    _id_transformMatrixToLocal(
        this, const jni.jvoidType(), [matrix.reference.pointer]);
  }

  static final _id_getLocationOnScreen = _class.instanceMethodId(
    r"getLocationOnScreen",
    r"([I)V",
  );

  /// from: public void getLocationOnScreen(int[] is)
  void getLocationOnScreen(
    jni.JArray<jni.jint> is0,
  ) {
    _id_getLocationOnScreen(
        this, const jni.jvoidType(), [is0.reference.pointer]);
  }

  static final _id_getLocationInWindow = _class.instanceMethodId(
    r"getLocationInWindow",
    r"([I)V",
  );

  /// from: public void getLocationInWindow(int[] is)
  void getLocationInWindow(
    jni.JArray<jni.jint> is0,
  ) {
    _id_getLocationInWindow(
        this, const jni.jvoidType(), [is0.reference.pointer]);
  }

  static final _id_findViewById = _class.instanceMethodId(
    r"findViewById",
    r"(I)Landroid/view/View;",
  );

  /// from: public final T findViewById(int i)
  /// The returned object must be released after use, by calling the [release] method.
  $T findViewById<$T extends jni.JObject>(
    int i, {
    required jni.JObjType<$T> T,
  }) {
    return _id_findViewById(this, T, [jni.JValueInt(i)]);
  }

  static final _id_requireViewById = _class.instanceMethodId(
    r"requireViewById",
    r"(I)Landroid/view/View;",
  );

  /// from: public final T requireViewById(int i)
  /// The returned object must be released after use, by calling the [release] method.
  $T requireViewById<$T extends jni.JObject>(
    int i, {
    required jni.JObjType<$T> T,
  }) {
    return _id_requireViewById(this, T, [jni.JValueInt(i)]);
  }

  static final _id_findViewWithTag = _class.instanceMethodId(
    r"findViewWithTag",
    r"(Ljava/lang/Object;)Landroid/view/View;",
  );

  /// from: public final T findViewWithTag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  $T findViewWithTag<$T extends jni.JObject>(
    jni.JObject object, {
    required jni.JObjType<$T> T,
  }) {
    return _id_findViewWithTag(this, T, [object.reference.pointer]);
  }

  static final _id_setId = _class.instanceMethodId(
    r"setId",
    r"(I)V",
  );

  /// from: public void setId(int i)
  void setId(
    int i,
  ) {
    _id_setId(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getId = _class.instanceMethodId(
    r"getId",
    r"()I",
  );

  /// from: public int getId()
  int getId() {
    return _id_getId(this, const jni.jintType(), []);
  }

  static final _id_getUniqueDrawingId = _class.instanceMethodId(
    r"getUniqueDrawingId",
    r"()J",
  );

  /// from: public long getUniqueDrawingId()
  int getUniqueDrawingId() {
    return _id_getUniqueDrawingId(this, const jni.jlongType(), []);
  }

  static final _id_getTag = _class.instanceMethodId(
    r"getTag",
    r"()Ljava/lang/Object;",
  );

  /// from: public java.lang.Object getTag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTag() {
    return _id_getTag(this, const jni.JObjectType(), []);
  }

  static final _id_setTag = _class.instanceMethodId(
    r"setTag",
    r"(Ljava/lang/Object;)V",
  );

  /// from: public void setTag(java.lang.Object object)
  void setTag(
    jni.JObject object,
  ) {
    _id_setTag(this, const jni.jvoidType(), [object.reference.pointer]);
  }

  static final _id_getTag1 = _class.instanceMethodId(
    r"getTag",
    r"(I)Ljava/lang/Object;",
  );

  /// from: public java.lang.Object getTag(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTag1(
    int i,
  ) {
    return _id_getTag1(this, const jni.JObjectType(), [jni.JValueInt(i)]);
  }

  static final _id_setTag1 = _class.instanceMethodId(
    r"setTag",
    r"(ILjava/lang/Object;)V",
  );

  /// from: public void setTag(int i, java.lang.Object object)
  void setTag1(
    int i,
    jni.JObject object,
  ) {
    _id_setTag1(this, const jni.jvoidType(),
        [jni.JValueInt(i), object.reference.pointer]);
  }

  static final _id_getBaseline = _class.instanceMethodId(
    r"getBaseline",
    r"()I",
  );

  /// from: public int getBaseline()
  int getBaseline() {
    return _id_getBaseline(this, const jni.jintType(), []);
  }

  static final _id_isInLayout = _class.instanceMethodId(
    r"isInLayout",
    r"()Z",
  );

  /// from: public boolean isInLayout()
  bool isInLayout() {
    return _id_isInLayout(this, const jni.jbooleanType(), []);
  }

  static final _id_requestLayout = _class.instanceMethodId(
    r"requestLayout",
    r"()V",
  );

  /// from: public void requestLayout()
  void requestLayout() {
    _id_requestLayout(this, const jni.jvoidType(), []);
  }

  static final _id_forceLayout = _class.instanceMethodId(
    r"forceLayout",
    r"()V",
  );

  /// from: public void forceLayout()
  void forceLayout() {
    _id_forceLayout(this, const jni.jvoidType(), []);
  }

  static final _id_measure = _class.instanceMethodId(
    r"measure",
    r"(II)V",
  );

  /// from: public final void measure(int i, int i1)
  void measure(
    int i,
    int i1,
  ) {
    _id_measure(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_onMeasure = _class.instanceMethodId(
    r"onMeasure",
    r"(II)V",
  );

  /// from: protected void onMeasure(int i, int i1)
  void onMeasure(
    int i,
    int i1,
  ) {
    _id_onMeasure(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_setMeasuredDimension = _class.instanceMethodId(
    r"setMeasuredDimension",
    r"(II)V",
  );

  /// from: protected final void setMeasuredDimension(int i, int i1)
  void setMeasuredDimension(
    int i,
    int i1,
  ) {
    _id_setMeasuredDimension(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_combineMeasuredStates = _class.staticMethodId(
    r"combineMeasuredStates",
    r"(II)I",
  );

  /// from: static public int combineMeasuredStates(int i, int i1)
  static int combineMeasuredStates(
    int i,
    int i1,
  ) {
    return _id_combineMeasuredStates(
        _class, const jni.jintType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_resolveSize = _class.staticMethodId(
    r"resolveSize",
    r"(II)I",
  );

  /// from: static public int resolveSize(int i, int i1)
  static int resolveSize(
    int i,
    int i1,
  ) {
    return _id_resolveSize(
        _class, const jni.jintType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_resolveSizeAndState = _class.staticMethodId(
    r"resolveSizeAndState",
    r"(III)I",
  );

  /// from: static public int resolveSizeAndState(int i, int i1, int i2)
  static int resolveSizeAndState(
    int i,
    int i1,
    int i2,
  ) {
    return _id_resolveSizeAndState(_class, const jni.jintType(),
        [jni.JValueInt(i), jni.JValueInt(i1), jni.JValueInt(i2)]);
  }

  static final _id_getDefaultSize = _class.staticMethodId(
    r"getDefaultSize",
    r"(II)I",
  );

  /// from: static public int getDefaultSize(int i, int i1)
  static int getDefaultSize(
    int i,
    int i1,
  ) {
    return _id_getDefaultSize(
        _class, const jni.jintType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_getSuggestedMinimumHeight = _class.instanceMethodId(
    r"getSuggestedMinimumHeight",
    r"()I",
  );

  /// from: protected int getSuggestedMinimumHeight()
  int getSuggestedMinimumHeight() {
    return _id_getSuggestedMinimumHeight(this, const jni.jintType(), []);
  }

  static final _id_getSuggestedMinimumWidth = _class.instanceMethodId(
    r"getSuggestedMinimumWidth",
    r"()I",
  );

  /// from: protected int getSuggestedMinimumWidth()
  int getSuggestedMinimumWidth() {
    return _id_getSuggestedMinimumWidth(this, const jni.jintType(), []);
  }

  static final _id_getMinimumHeight = _class.instanceMethodId(
    r"getMinimumHeight",
    r"()I",
  );

  /// from: public int getMinimumHeight()
  int getMinimumHeight() {
    return _id_getMinimumHeight(this, const jni.jintType(), []);
  }

  static final _id_setMinimumHeight = _class.instanceMethodId(
    r"setMinimumHeight",
    r"(I)V",
  );

  /// from: public void setMinimumHeight(int i)
  void setMinimumHeight(
    int i,
  ) {
    _id_setMinimumHeight(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getMinimumWidth = _class.instanceMethodId(
    r"getMinimumWidth",
    r"()I",
  );

  /// from: public int getMinimumWidth()
  int getMinimumWidth() {
    return _id_getMinimumWidth(this, const jni.jintType(), []);
  }

  static final _id_setMinimumWidth = _class.instanceMethodId(
    r"setMinimumWidth",
    r"(I)V",
  );

  /// from: public void setMinimumWidth(int i)
  void setMinimumWidth(
    int i,
  ) {
    _id_setMinimumWidth(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getAnimation = _class.instanceMethodId(
    r"getAnimation",
    r"()Landroid/view/animation/Animation;",
  );

  /// from: public android.view.animation.Animation getAnimation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAnimation() {
    return _id_getAnimation(this, const jni.JObjectType(), []);
  }

  static final _id_startAnimation = _class.instanceMethodId(
    r"startAnimation",
    r"(Landroid/view/animation/Animation;)V",
  );

  /// from: public void startAnimation(android.view.animation.Animation animation)
  void startAnimation(
    jni.JObject animation,
  ) {
    _id_startAnimation(
        this, const jni.jvoidType(), [animation.reference.pointer]);
  }

  static final _id_clearAnimation = _class.instanceMethodId(
    r"clearAnimation",
    r"()V",
  );

  /// from: public void clearAnimation()
  void clearAnimation() {
    _id_clearAnimation(this, const jni.jvoidType(), []);
  }

  static final _id_setAnimation = _class.instanceMethodId(
    r"setAnimation",
    r"(Landroid/view/animation/Animation;)V",
  );

  /// from: public void setAnimation(android.view.animation.Animation animation)
  void setAnimation(
    jni.JObject animation,
  ) {
    _id_setAnimation(
        this, const jni.jvoidType(), [animation.reference.pointer]);
  }

  static final _id_onAnimationStart = _class.instanceMethodId(
    r"onAnimationStart",
    r"()V",
  );

  /// from: protected void onAnimationStart()
  void onAnimationStart() {
    _id_onAnimationStart(this, const jni.jvoidType(), []);
  }

  static final _id_onAnimationEnd = _class.instanceMethodId(
    r"onAnimationEnd",
    r"()V",
  );

  /// from: protected void onAnimationEnd()
  void onAnimationEnd() {
    _id_onAnimationEnd(this, const jni.jvoidType(), []);
  }

  static final _id_onSetAlpha = _class.instanceMethodId(
    r"onSetAlpha",
    r"(I)Z",
  );

  /// from: protected boolean onSetAlpha(int i)
  bool onSetAlpha(
    int i,
  ) {
    return _id_onSetAlpha(this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_gatherTransparentRegion = _class.instanceMethodId(
    r"gatherTransparentRegion",
    r"(Landroid/graphics/Region;)Z",
  );

  /// from: public boolean gatherTransparentRegion(android.graphics.Region region)
  bool gatherTransparentRegion(
    jni.JObject region,
  ) {
    return _id_gatherTransparentRegion(
        this, const jni.jbooleanType(), [region.reference.pointer]);
  }

  static final _id_playSoundEffect = _class.instanceMethodId(
    r"playSoundEffect",
    r"(I)V",
  );

  /// from: public void playSoundEffect(int i)
  void playSoundEffect(
    int i,
  ) {
    _id_playSoundEffect(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_performHapticFeedback = _class.instanceMethodId(
    r"performHapticFeedback",
    r"(I)Z",
  );

  /// from: public boolean performHapticFeedback(int i)
  bool performHapticFeedback(
    int i,
  ) {
    return _id_performHapticFeedback(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_performHapticFeedback1 = _class.instanceMethodId(
    r"performHapticFeedback",
    r"(II)Z",
  );

  /// from: public boolean performHapticFeedback(int i, int i1)
  bool performHapticFeedback1(
    int i,
    int i1,
  ) {
    return _id_performHapticFeedback1(
        this, const jni.jbooleanType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_setSystemUiVisibility = _class.instanceMethodId(
    r"setSystemUiVisibility",
    r"(I)V",
  );

  /// from: public void setSystemUiVisibility(int i)
  void setSystemUiVisibility(
    int i,
  ) {
    _id_setSystemUiVisibility(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getSystemUiVisibility = _class.instanceMethodId(
    r"getSystemUiVisibility",
    r"()I",
  );

  /// from: public int getSystemUiVisibility()
  int getSystemUiVisibility() {
    return _id_getSystemUiVisibility(this, const jni.jintType(), []);
  }

  static final _id_getWindowSystemUiVisibility = _class.instanceMethodId(
    r"getWindowSystemUiVisibility",
    r"()I",
  );

  /// from: public int getWindowSystemUiVisibility()
  int getWindowSystemUiVisibility() {
    return _id_getWindowSystemUiVisibility(this, const jni.jintType(), []);
  }

  static final _id_onWindowSystemUiVisibilityChanged = _class.instanceMethodId(
    r"onWindowSystemUiVisibilityChanged",
    r"(I)V",
  );

  /// from: public void onWindowSystemUiVisibilityChanged(int i)
  void onWindowSystemUiVisibilityChanged(
    int i,
  ) {
    _id_onWindowSystemUiVisibilityChanged(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_dispatchWindowSystemUiVisiblityChanged =
      _class.instanceMethodId(
    r"dispatchWindowSystemUiVisiblityChanged",
    r"(I)V",
  );

  /// from: public void dispatchWindowSystemUiVisiblityChanged(int i)
  void dispatchWindowSystemUiVisiblityChanged(
    int i,
  ) {
    _id_dispatchWindowSystemUiVisiblityChanged(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setOnSystemUiVisibilityChangeListener =
      _class.instanceMethodId(
    r"setOnSystemUiVisibilityChangeListener",
    r"(Landroid/view/View$OnSystemUiVisibilityChangeListener;)V",
  );

  /// from: public void setOnSystemUiVisibilityChangeListener(android.view.View$OnSystemUiVisibilityChangeListener onSystemUiVisibilityChangeListener)
  void setOnSystemUiVisibilityChangeListener(
    View_OnSystemUiVisibilityChangeListener onSystemUiVisibilityChangeListener,
  ) {
    _id_setOnSystemUiVisibilityChangeListener(this, const jni.jvoidType(),
        [onSystemUiVisibilityChangeListener.reference.pointer]);
  }

  static final _id_dispatchSystemUiVisibilityChanged = _class.instanceMethodId(
    r"dispatchSystemUiVisibilityChanged",
    r"(I)V",
  );

  /// from: public void dispatchSystemUiVisibilityChanged(int i)
  void dispatchSystemUiVisibilityChanged(
    int i,
  ) {
    _id_dispatchSystemUiVisibilityChanged(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_startDrag = _class.instanceMethodId(
    r"startDrag",
    r"(Landroid/content/ClipData;Landroid/view/View$DragShadowBuilder;Ljava/lang/Object;I)Z",
  );

  /// from: public final boolean startDrag(android.content.ClipData clipData, android.view.View$DragShadowBuilder dragShadowBuilder, java.lang.Object object, int i)
  bool startDrag(
    jni.JObject clipData,
    View_DragShadowBuilder dragShadowBuilder,
    jni.JObject object,
    int i,
  ) {
    return _id_startDrag(this, const jni.jbooleanType(), [
      clipData.reference.pointer,
      dragShadowBuilder.reference.pointer,
      object.reference.pointer,
      jni.JValueInt(i)
    ]);
  }

  static final _id_startDragAndDrop = _class.instanceMethodId(
    r"startDragAndDrop",
    r"(Landroid/content/ClipData;Landroid/view/View$DragShadowBuilder;Ljava/lang/Object;I)Z",
  );

  /// from: public final boolean startDragAndDrop(android.content.ClipData clipData, android.view.View$DragShadowBuilder dragShadowBuilder, java.lang.Object object, int i)
  bool startDragAndDrop(
    jni.JObject clipData,
    View_DragShadowBuilder dragShadowBuilder,
    jni.JObject object,
    int i,
  ) {
    return _id_startDragAndDrop(this, const jni.jbooleanType(), [
      clipData.reference.pointer,
      dragShadowBuilder.reference.pointer,
      object.reference.pointer,
      jni.JValueInt(i)
    ]);
  }

  static final _id_cancelDragAndDrop = _class.instanceMethodId(
    r"cancelDragAndDrop",
    r"()V",
  );

  /// from: public final void cancelDragAndDrop()
  void cancelDragAndDrop() {
    _id_cancelDragAndDrop(this, const jni.jvoidType(), []);
  }

  static final _id_updateDragShadow = _class.instanceMethodId(
    r"updateDragShadow",
    r"(Landroid/view/View$DragShadowBuilder;)V",
  );

  /// from: public final void updateDragShadow(android.view.View$DragShadowBuilder dragShadowBuilder)
  void updateDragShadow(
    View_DragShadowBuilder dragShadowBuilder,
  ) {
    _id_updateDragShadow(
        this, const jni.jvoidType(), [dragShadowBuilder.reference.pointer]);
  }

  static final _id_onDragEvent = _class.instanceMethodId(
    r"onDragEvent",
    r"(Landroid/view/DragEvent;)Z",
  );

  /// from: public boolean onDragEvent(android.view.DragEvent dragEvent)
  bool onDragEvent(
    jni.JObject dragEvent,
  ) {
    return _id_onDragEvent(
        this, const jni.jbooleanType(), [dragEvent.reference.pointer]);
  }

  static final _id_dispatchDragEvent = _class.instanceMethodId(
    r"dispatchDragEvent",
    r"(Landroid/view/DragEvent;)Z",
  );

  /// from: public boolean dispatchDragEvent(android.view.DragEvent dragEvent)
  bool dispatchDragEvent(
    jni.JObject dragEvent,
  ) {
    return _id_dispatchDragEvent(
        this, const jni.jbooleanType(), [dragEvent.reference.pointer]);
  }

  static final _id_inflate = _class.staticMethodId(
    r"inflate",
    r"(Landroid/content/Context;ILandroid/view/ViewGroup;)Landroid/view/View;",
  );

  /// from: static public android.view.View inflate(android.content.Context context, int i, android.view.ViewGroup viewGroup)
  /// The returned object must be released after use, by calling the [release] method.
  static View inflate(
    jni.JObject context,
    int i,
    jni.JObject viewGroup,
  ) {
    return _id_inflate(_class, const $ViewType(), [
      context.reference.pointer,
      jni.JValueInt(i),
      viewGroup.reference.pointer
    ]);
  }

  static final _id_overScrollBy = _class.instanceMethodId(
    r"overScrollBy",
    r"(IIIIIIIIZ)Z",
  );

  /// from: protected boolean overScrollBy(int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7, boolean z)
  bool overScrollBy(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
    bool z,
  ) {
    return _id_overScrollBy(this, const jni.jbooleanType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3),
      jni.JValueInt(i4),
      jni.JValueInt(i5),
      jni.JValueInt(i6),
      jni.JValueInt(i7),
      z ? 1 : 0
    ]);
  }

  static final _id_onOverScrolled = _class.instanceMethodId(
    r"onOverScrolled",
    r"(IIZZ)V",
  );

  /// from: protected void onOverScrolled(int i, int i1, boolean z, boolean z1)
  void onOverScrolled(
    int i,
    int i1,
    bool z,
    bool z1,
  ) {
    _id_onOverScrolled(this, const jni.jvoidType(),
        [jni.JValueInt(i), jni.JValueInt(i1), z ? 1 : 0, z1 ? 1 : 0]);
  }

  static final _id_getOverScrollMode = _class.instanceMethodId(
    r"getOverScrollMode",
    r"()I",
  );

  /// from: public int getOverScrollMode()
  int getOverScrollMode() {
    return _id_getOverScrollMode(this, const jni.jintType(), []);
  }

  static final _id_setOverScrollMode = _class.instanceMethodId(
    r"setOverScrollMode",
    r"(I)V",
  );

  /// from: public void setOverScrollMode(int i)
  void setOverScrollMode(
    int i,
  ) {
    _id_setOverScrollMode(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setNestedScrollingEnabled = _class.instanceMethodId(
    r"setNestedScrollingEnabled",
    r"(Z)V",
  );

  /// from: public void setNestedScrollingEnabled(boolean z)
  void setNestedScrollingEnabled(
    bool z,
  ) {
    _id_setNestedScrollingEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isNestedScrollingEnabled = _class.instanceMethodId(
    r"isNestedScrollingEnabled",
    r"()Z",
  );

  /// from: public boolean isNestedScrollingEnabled()
  bool isNestedScrollingEnabled() {
    return _id_isNestedScrollingEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_startNestedScroll = _class.instanceMethodId(
    r"startNestedScroll",
    r"(I)Z",
  );

  /// from: public boolean startNestedScroll(int i)
  bool startNestedScroll(
    int i,
  ) {
    return _id_startNestedScroll(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_stopNestedScroll = _class.instanceMethodId(
    r"stopNestedScroll",
    r"()V",
  );

  /// from: public void stopNestedScroll()
  void stopNestedScroll() {
    _id_stopNestedScroll(this, const jni.jvoidType(), []);
  }

  static final _id_hasNestedScrollingParent = _class.instanceMethodId(
    r"hasNestedScrollingParent",
    r"()Z",
  );

  /// from: public boolean hasNestedScrollingParent()
  bool hasNestedScrollingParent() {
    return _id_hasNestedScrollingParent(this, const jni.jbooleanType(), []);
  }

  static final _id_dispatchNestedScroll = _class.instanceMethodId(
    r"dispatchNestedScroll",
    r"(IIII[I)Z",
  );

  /// from: public boolean dispatchNestedScroll(int i, int i1, int i2, int i3, int[] is)
  bool dispatchNestedScroll(
    int i,
    int i1,
    int i2,
    int i3,
    jni.JArray<jni.jint> is0,
  ) {
    return _id_dispatchNestedScroll(this, const jni.jbooleanType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3),
      is0.reference.pointer
    ]);
  }

  static final _id_dispatchNestedPreScroll = _class.instanceMethodId(
    r"dispatchNestedPreScroll",
    r"(II[I[I)Z",
  );

  /// from: public boolean dispatchNestedPreScroll(int i, int i1, int[] is, int[] is1)
  bool dispatchNestedPreScroll(
    int i,
    int i1,
    jni.JArray<jni.jint> is0,
    jni.JArray<jni.jint> is1,
  ) {
    return _id_dispatchNestedPreScroll(this, const jni.jbooleanType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      is0.reference.pointer,
      is1.reference.pointer
    ]);
  }

  static final _id_dispatchNestedFling = _class.instanceMethodId(
    r"dispatchNestedFling",
    r"(FFZ)Z",
  );

  /// from: public boolean dispatchNestedFling(float f, float f1, boolean z)
  bool dispatchNestedFling(
    double f,
    double f1,
    bool z,
  ) {
    return _id_dispatchNestedFling(this, const jni.jbooleanType(),
        [jni.JValueFloat(f), jni.JValueFloat(f1), z ? 1 : 0]);
  }

  static final _id_dispatchNestedPreFling = _class.instanceMethodId(
    r"dispatchNestedPreFling",
    r"(FF)Z",
  );

  /// from: public boolean dispatchNestedPreFling(float f, float f1)
  bool dispatchNestedPreFling(
    double f,
    double f1,
  ) {
    return _id_dispatchNestedPreFling(this, const jni.jbooleanType(),
        [jni.JValueFloat(f), jni.JValueFloat(f1)]);
  }

  static final _id_setTextDirection = _class.instanceMethodId(
    r"setTextDirection",
    r"(I)V",
  );

  /// from: public void setTextDirection(int i)
  void setTextDirection(
    int i,
  ) {
    _id_setTextDirection(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getTextDirection = _class.instanceMethodId(
    r"getTextDirection",
    r"()I",
  );

  /// from: public int getTextDirection()
  int getTextDirection() {
    return _id_getTextDirection(this, const jni.jintType(), []);
  }

  static final _id_canResolveTextDirection = _class.instanceMethodId(
    r"canResolveTextDirection",
    r"()Z",
  );

  /// from: public boolean canResolveTextDirection()
  bool canResolveTextDirection() {
    return _id_canResolveTextDirection(this, const jni.jbooleanType(), []);
  }

  static final _id_isTextDirectionResolved = _class.instanceMethodId(
    r"isTextDirectionResolved",
    r"()Z",
  );

  /// from: public boolean isTextDirectionResolved()
  bool isTextDirectionResolved() {
    return _id_isTextDirectionResolved(this, const jni.jbooleanType(), []);
  }

  static final _id_setTextAlignment = _class.instanceMethodId(
    r"setTextAlignment",
    r"(I)V",
  );

  /// from: public void setTextAlignment(int i)
  void setTextAlignment(
    int i,
  ) {
    _id_setTextAlignment(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_getTextAlignment = _class.instanceMethodId(
    r"getTextAlignment",
    r"()I",
  );

  /// from: public int getTextAlignment()
  int getTextAlignment() {
    return _id_getTextAlignment(this, const jni.jintType(), []);
  }

  static final _id_canResolveTextAlignment = _class.instanceMethodId(
    r"canResolveTextAlignment",
    r"()Z",
  );

  /// from: public boolean canResolveTextAlignment()
  bool canResolveTextAlignment() {
    return _id_canResolveTextAlignment(this, const jni.jbooleanType(), []);
  }

  static final _id_isTextAlignmentResolved = _class.instanceMethodId(
    r"isTextAlignmentResolved",
    r"()Z",
  );

  /// from: public boolean isTextAlignmentResolved()
  bool isTextAlignmentResolved() {
    return _id_isTextAlignmentResolved(this, const jni.jbooleanType(), []);
  }

  static final _id_generateViewId = _class.staticMethodId(
    r"generateViewId",
    r"()I",
  );

  /// from: static public int generateViewId()
  static int generateViewId() {
    return _id_generateViewId(_class, const jni.jintType(), []);
  }

  static final _id_onResolvePointerIcon = _class.instanceMethodId(
    r"onResolvePointerIcon",
    r"(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;",
  );

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent motionEvent, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onResolvePointerIcon(
    jni.JObject motionEvent,
    int i,
  ) {
    return _id_onResolvePointerIcon(this, const jni.JObjectType(),
        [motionEvent.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_setPointerIcon = _class.instanceMethodId(
    r"setPointerIcon",
    r"(Landroid/view/PointerIcon;)V",
  );

  /// from: public void setPointerIcon(android.view.PointerIcon pointerIcon)
  void setPointerIcon(
    jni.JObject pointerIcon,
  ) {
    _id_setPointerIcon(
        this, const jni.jvoidType(), [pointerIcon.reference.pointer]);
  }

  static final _id_getPointerIcon = _class.instanceMethodId(
    r"getPointerIcon",
    r"()Landroid/view/PointerIcon;",
  );

  /// from: public android.view.PointerIcon getPointerIcon()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getPointerIcon() {
    return _id_getPointerIcon(this, const jni.JObjectType(), []);
  }

  static final _id_hasPointerCapture = _class.instanceMethodId(
    r"hasPointerCapture",
    r"()Z",
  );

  /// from: public boolean hasPointerCapture()
  bool hasPointerCapture() {
    return _id_hasPointerCapture(this, const jni.jbooleanType(), []);
  }

  static final _id_requestPointerCapture = _class.instanceMethodId(
    r"requestPointerCapture",
    r"()V",
  );

  /// from: public void requestPointerCapture()
  void requestPointerCapture() {
    _id_requestPointerCapture(this, const jni.jvoidType(), []);
  }

  static final _id_releasePointerCapture = _class.instanceMethodId(
    r"releasePointerCapture",
    r"()V",
  );

  /// from: public void releasePointerCapture()
  void releasePointerCapture() {
    _id_releasePointerCapture(this, const jni.jvoidType(), []);
  }

  static final _id_onPointerCaptureChange = _class.instanceMethodId(
    r"onPointerCaptureChange",
    r"(Z)V",
  );

  /// from: public void onPointerCaptureChange(boolean z)
  void onPointerCaptureChange(
    bool z,
  ) {
    _id_onPointerCaptureChange(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_dispatchPointerCaptureChanged = _class.instanceMethodId(
    r"dispatchPointerCaptureChanged",
    r"(Z)V",
  );

  /// from: public void dispatchPointerCaptureChanged(boolean z)
  void dispatchPointerCaptureChanged(
    bool z,
  ) {
    _id_dispatchPointerCaptureChanged(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_onCapturedPointerEvent = _class.instanceMethodId(
    r"onCapturedPointerEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onCapturedPointerEvent(android.view.MotionEvent motionEvent)
  bool onCapturedPointerEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onCapturedPointerEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_setOnCapturedPointerListener = _class.instanceMethodId(
    r"setOnCapturedPointerListener",
    r"(Landroid/view/View$OnCapturedPointerListener;)V",
  );

  /// from: public void setOnCapturedPointerListener(android.view.View$OnCapturedPointerListener onCapturedPointerListener)
  void setOnCapturedPointerListener(
    View_OnCapturedPointerListener onCapturedPointerListener,
  ) {
    _id_setOnCapturedPointerListener(this, const jni.jvoidType(),
        [onCapturedPointerListener.reference.pointer]);
  }

  static final _id_animate = _class.instanceMethodId(
    r"animate",
    r"()Landroid/view/ViewPropertyAnimator;",
  );

  /// from: public android.view.ViewPropertyAnimator animate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject animate() {
    return _id_animate(this, const jni.JObjectType(), []);
  }

  static final _id_setTransitionName = _class.instanceMethodId(
    r"setTransitionName",
    r"(Ljava/lang/String;)V",
  );

  /// from: public final void setTransitionName(java.lang.String string)
  void setTransitionName(
    jni.JString string,
  ) {
    _id_setTransitionName(
        this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_getTransitionName = _class.instanceMethodId(
    r"getTransitionName",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getTransitionName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTransitionName() {
    return _id_getTransitionName(this, const jni.JStringType(), []);
  }

  static final _id_getScrollCaptureHint = _class.instanceMethodId(
    r"getScrollCaptureHint",
    r"()I",
  );

  /// from: public int getScrollCaptureHint()
  int getScrollCaptureHint() {
    return _id_getScrollCaptureHint(this, const jni.jintType(), []);
  }

  static final _id_setScrollCaptureHint = _class.instanceMethodId(
    r"setScrollCaptureHint",
    r"(I)V",
  );

  /// from: public void setScrollCaptureHint(int i)
  void setScrollCaptureHint(
    int i,
  ) {
    _id_setScrollCaptureHint(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setScrollCaptureCallback = _class.instanceMethodId(
    r"setScrollCaptureCallback",
    r"(Landroid/view/ScrollCaptureCallback;)V",
  );

  /// from: public final void setScrollCaptureCallback(android.view.ScrollCaptureCallback scrollCaptureCallback)
  void setScrollCaptureCallback(
    jni.JObject scrollCaptureCallback,
  ) {
    _id_setScrollCaptureCallback(
        this, const jni.jvoidType(), [scrollCaptureCallback.reference.pointer]);
  }

  static final _id_dispatchScrollCaptureSearch = _class.instanceMethodId(
    r"dispatchScrollCaptureSearch",
    r"(Landroid/graphics/Rect;Landroid/graphics/Point;Ljava/util/function/Consumer;)V",
  );

  /// from: public void dispatchScrollCaptureSearch(android.graphics.Rect rect, android.graphics.Point point, java.util.function.Consumer consumer)
  void dispatchScrollCaptureSearch(
    jni.JObject rect,
    jni.JObject point,
    jni.JObject consumer,
  ) {
    _id_dispatchScrollCaptureSearch(this, const jni.jvoidType(), [
      rect.reference.pointer,
      point.reference.pointer,
      consumer.reference.pointer
    ]);
  }

  static final _id_onScrollCaptureSearch = _class.instanceMethodId(
    r"onScrollCaptureSearch",
    r"(Landroid/graphics/Rect;Landroid/graphics/Point;Ljava/util/function/Consumer;)V",
  );

  /// from: public void onScrollCaptureSearch(android.graphics.Rect rect, android.graphics.Point point, java.util.function.Consumer consumer)
  void onScrollCaptureSearch(
    jni.JObject rect,
    jni.JObject point,
    jni.JObject consumer,
  ) {
    _id_onScrollCaptureSearch(this, const jni.jvoidType(), [
      rect.reference.pointer,
      point.reference.pointer,
      consumer.reference.pointer
    ]);
  }

  static final _id_setTooltipText = _class.instanceMethodId(
    r"setTooltipText",
    r"(Ljava/lang/CharSequence;)V",
  );

  /// from: public void setTooltipText(java.lang.CharSequence charSequence)
  void setTooltipText(
    jni.JObject charSequence,
  ) {
    _id_setTooltipText(
        this, const jni.jvoidType(), [charSequence.reference.pointer]);
  }

  static final _id_getTooltipText = _class.instanceMethodId(
    r"getTooltipText",
    r"()Ljava/lang/CharSequence;",
  );

  /// from: public java.lang.CharSequence getTooltipText()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTooltipText() {
    return _id_getTooltipText(this, const jni.JObjectType(), []);
  }

  static final _id_addOnUnhandledKeyEventListener = _class.instanceMethodId(
    r"addOnUnhandledKeyEventListener",
    r"(Landroid/view/View$OnUnhandledKeyEventListener;)V",
  );

  /// from: public void addOnUnhandledKeyEventListener(android.view.View$OnUnhandledKeyEventListener onUnhandledKeyEventListener)
  void addOnUnhandledKeyEventListener(
    View_OnUnhandledKeyEventListener onUnhandledKeyEventListener,
  ) {
    _id_addOnUnhandledKeyEventListener(this, const jni.jvoidType(),
        [onUnhandledKeyEventListener.reference.pointer]);
  }

  static final _id_removeOnUnhandledKeyEventListener = _class.instanceMethodId(
    r"removeOnUnhandledKeyEventListener",
    r"(Landroid/view/View$OnUnhandledKeyEventListener;)V",
  );

  /// from: public void removeOnUnhandledKeyEventListener(android.view.View$OnUnhandledKeyEventListener onUnhandledKeyEventListener)
  void removeOnUnhandledKeyEventListener(
    View_OnUnhandledKeyEventListener onUnhandledKeyEventListener,
  ) {
    _id_removeOnUnhandledKeyEventListener(this, const jni.jvoidType(),
        [onUnhandledKeyEventListener.reference.pointer]);
  }

  static final _id_setIsCredential = _class.instanceMethodId(
    r"setIsCredential",
    r"(Z)V",
  );

  /// from: public void setIsCredential(boolean z)
  void setIsCredential(
    bool z,
  ) {
    _id_setIsCredential(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isCredential = _class.instanceMethodId(
    r"isCredential",
    r"()Z",
  );

  /// from: public boolean isCredential()
  bool isCredential() {
    return _id_isCredential(this, const jni.jbooleanType(), []);
  }

  static final _id_setAutoHandwritingEnabled = _class.instanceMethodId(
    r"setAutoHandwritingEnabled",
    r"(Z)V",
  );

  /// from: public void setAutoHandwritingEnabled(boolean z)
  void setAutoHandwritingEnabled(
    bool z,
  ) {
    _id_setAutoHandwritingEnabled(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_isAutoHandwritingEnabled = _class.instanceMethodId(
    r"isAutoHandwritingEnabled",
    r"()Z",
  );

  /// from: public boolean isAutoHandwritingEnabled()
  bool isAutoHandwritingEnabled() {
    return _id_isAutoHandwritingEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_onCreateViewTranslationRequest = _class.instanceMethodId(
    r"onCreateViewTranslationRequest",
    r"([ILjava/util/function/Consumer;)V",
  );

  /// from: public void onCreateViewTranslationRequest(java.lang.Object[] is, java.util.function.Consumer consumer)
  void onCreateViewTranslationRequest(
    jni.JArray<jni.jint> is0,
    jni.JObject consumer,
  ) {
    _id_onCreateViewTranslationRequest(this, const jni.jvoidType(),
        [is0.reference.pointer, consumer.reference.pointer]);
  }

  static final _id_onCreateVirtualViewTranslationRequests =
      _class.instanceMethodId(
    r"onCreateVirtualViewTranslationRequests",
    r"([J[ILjava/util/function/Consumer;)V",
  );

  /// from: public void onCreateVirtualViewTranslationRequests(java.lang.Object[] js, java.lang.Object[] is, java.util.function.Consumer consumer)
  void onCreateVirtualViewTranslationRequests(
    jni.JArray<jni.jlong> js,
    jni.JArray<jni.jint> is0,
    jni.JObject consumer,
  ) {
    _id_onCreateVirtualViewTranslationRequests(this, const jni.jvoidType(), [
      js.reference.pointer,
      is0.reference.pointer,
      consumer.reference.pointer
    ]);
  }

  static final _id_setViewTranslationCallback = _class.instanceMethodId(
    r"setViewTranslationCallback",
    r"(Landroid/view/translation/ViewTranslationCallback;)V",
  );

  /// from: public void setViewTranslationCallback(android.view.translation.ViewTranslationCallback viewTranslationCallback)
  void setViewTranslationCallback(
    jni.JObject viewTranslationCallback,
  ) {
    _id_setViewTranslationCallback(this, const jni.jvoidType(),
        [viewTranslationCallback.reference.pointer]);
  }

  static final _id_clearViewTranslationCallback = _class.instanceMethodId(
    r"clearViewTranslationCallback",
    r"()V",
  );

  /// from: public void clearViewTranslationCallback()
  void clearViewTranslationCallback() {
    _id_clearViewTranslationCallback(this, const jni.jvoidType(), []);
  }

  static final _id_getViewTranslationResponse = _class.instanceMethodId(
    r"getViewTranslationResponse",
    r"()Landroid/view/translation/ViewTranslationResponse;",
  );

  /// from: public android.view.translation.ViewTranslationResponse getViewTranslationResponse()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getViewTranslationResponse() {
    return _id_getViewTranslationResponse(this, const jni.JObjectType(), []);
  }

  static final _id_onViewTranslationResponse = _class.instanceMethodId(
    r"onViewTranslationResponse",
    r"(Landroid/view/translation/ViewTranslationResponse;)V",
  );

  /// from: public void onViewTranslationResponse(android.view.translation.ViewTranslationResponse viewTranslationResponse)
  void onViewTranslationResponse(
    jni.JObject viewTranslationResponse,
  ) {
    _id_onViewTranslationResponse(this, const jni.jvoidType(),
        [viewTranslationResponse.reference.pointer]);
  }

  static final _id_onVirtualViewTranslationResponses = _class.instanceMethodId(
    r"onVirtualViewTranslationResponses",
    r"(Landroid/util/LongSparseArray;)V",
  );

  /// from: public void onVirtualViewTranslationResponses(android.util.LongSparseArray longSparseArray)
  void onVirtualViewTranslationResponses(
    jni.JObject longSparseArray,
  ) {
    _id_onVirtualViewTranslationResponses(
        this, const jni.jvoidType(), [longSparseArray.reference.pointer]);
  }

  static final _id_dispatchCreateViewTranslationRequest =
      _class.instanceMethodId(
    r"dispatchCreateViewTranslationRequest",
    r"(Ljava/util/Map;[ILandroid/view/translation/TranslationCapability;Ljava/util/List;)V",
  );

  /// from: public void dispatchCreateViewTranslationRequest(java.util.Map map, java.lang.Object[] is, android.view.translation.TranslationCapability translationCapability, java.util.List list)
  void dispatchCreateViewTranslationRequest(
    jni.JMap<jni.JObject, jni.JArray<jni.jlong>> map,
    jni.JArray<jni.jint> is0,
    jni.JObject translationCapability,
    jni.JList<jni.JObject> list,
  ) {
    _id_dispatchCreateViewTranslationRequest(this, const jni.jvoidType(), [
      map.reference.pointer,
      is0.reference.pointer,
      translationCapability.reference.pointer,
      list.reference.pointer
    ]);
  }

  static final _id_generateDisplayHash = _class.instanceMethodId(
    r"generateDisplayHash",
    r"(Ljava/lang/String;Landroid/graphics/Rect;Ljava/util/concurrent/Executor;Landroid/view/displayhash/DisplayHashResultCallback;)V",
  );

  /// from: public void generateDisplayHash(java.lang.String string, android.graphics.Rect rect, java.util.concurrent.Executor executor, android.view.displayhash.DisplayHashResultCallback displayHashResultCallback)
  void generateDisplayHash(
    jni.JString string,
    jni.JObject rect,
    jni.JObject executor,
    jni.JObject displayHashResultCallback,
  ) {
    _id_generateDisplayHash(this, const jni.jvoidType(), [
      string.reference.pointer,
      rect.reference.pointer,
      executor.reference.pointer,
      displayHashResultCallback.reference.pointer
    ]);
  }

  static final _id_getRootSurfaceControl = _class.instanceMethodId(
    r"getRootSurfaceControl",
    r"()Landroid/view/AttachedSurfaceControl;",
  );

  /// from: public android.view.AttachedSurfaceControl getRootSurfaceControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRootSurfaceControl() {
    return _id_getRootSurfaceControl(this, const jni.JObjectType(), []);
  }
}

final class $ViewType extends jni.JObjType<View> {
  const $ViewType();

  @override
  String get signature => r"Landroid/view/View;";

  @override
  View fromReference(jni.JReference reference) => View.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ViewType) && other is $ViewType;
  }
}

/// from: android.webkit.WebView$FindListener
class WebView_FindListener extends jni.JObject {
  @override
  late final jni.JObjType<WebView_FindListener> $type = type;

  WebView_FindListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/webkit/WebView$FindListener");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_FindListenerType();
  static final _id_onFindResultReceived = _class.instanceMethodId(
    r"onFindResultReceived",
    r"(IIZ)V",
  );

  /// from: public abstract void onFindResultReceived(int i, int i1, boolean z)
  void onFindResultReceived(
    int i,
    int i1,
    bool z,
  ) {
    _id_onFindResultReceived(this, const jni.jvoidType(),
        [jni.JValueInt(i), jni.JValueInt(i1), z ? 1 : 0]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebView_FindListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFindResultReceived(IIZ)V") {
        _$impls[$p]!.onFindResultReceived(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory WebView_FindListener.implement(
    $WebView_FindListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebView_FindListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.webkit.WebView$FindListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $WebView_FindListenerImpl {
  factory $WebView_FindListenerImpl({
    required void Function(int i, int i1, bool z) onFindResultReceived,
  }) = _$WebView_FindListenerImpl;

  void onFindResultReceived(int i, int i1, bool z);
}

class _$WebView_FindListenerImpl implements $WebView_FindListenerImpl {
  _$WebView_FindListenerImpl({
    required void Function(int i, int i1, bool z) onFindResultReceived,
  }) : _onFindResultReceived = onFindResultReceived;

  final void Function(int i, int i1, bool z) _onFindResultReceived;

  void onFindResultReceived(int i, int i1, bool z) {
    return _onFindResultReceived(i, i1, z);
  }
}

final class $WebView_FindListenerType
    extends jni.JObjType<WebView_FindListener> {
  const $WebView_FindListenerType();

  @override
  String get signature => r"Landroid/webkit/WebView$FindListener;";

  @override
  WebView_FindListener fromReference(jni.JReference reference) =>
      WebView_FindListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_FindListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_FindListenerType) &&
        other is $WebView_FindListenerType;
  }
}

/// from: android.webkit.WebView$HitTestResult
class WebView_HitTestResult extends jni.JObject {
  @override
  late final jni.JObjType<WebView_HitTestResult> $type = type;

  WebView_HitTestResult.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/webkit/WebView$HitTestResult");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_HitTestResultType();

  /// from: static public final int ANCHOR_TYPE
  static const ANCHOR_TYPE = 1;

  /// from: static public final int EDIT_TEXT_TYPE
  static const EDIT_TEXT_TYPE = 9;

  /// from: static public final int EMAIL_TYPE
  static const EMAIL_TYPE = 4;

  /// from: static public final int GEO_TYPE
  static const GEO_TYPE = 3;

  /// from: static public final int IMAGE_ANCHOR_TYPE
  static const IMAGE_ANCHOR_TYPE = 6;

  /// from: static public final int IMAGE_TYPE
  static const IMAGE_TYPE = 5;

  /// from: static public final int PHONE_TYPE
  static const PHONE_TYPE = 2;

  /// from: static public final int SRC_ANCHOR_TYPE
  static const SRC_ANCHOR_TYPE = 7;

  /// from: static public final int SRC_IMAGE_ANCHOR_TYPE
  static const SRC_IMAGE_ANCHOR_TYPE = 8;

  /// from: static public final int UNKNOWN_TYPE
  static const UNKNOWN_TYPE = 0;
  static final _id_getType = _class.instanceMethodId(
    r"getType",
    r"()I",
  );

  /// from: public int getType()
  int getType() {
    return _id_getType(this, const jni.jintType(), []);
  }

  static final _id_getExtra = _class.instanceMethodId(
    r"getExtra",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getExtra()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getExtra() {
    return _id_getExtra(this, const jni.JStringType(), []);
  }
}

final class $WebView_HitTestResultType
    extends jni.JObjType<WebView_HitTestResult> {
  const $WebView_HitTestResultType();

  @override
  String get signature => r"Landroid/webkit/WebView$HitTestResult;";

  @override
  WebView_HitTestResult fromReference(jni.JReference reference) =>
      WebView_HitTestResult.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_HitTestResultType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_HitTestResultType) &&
        other is $WebView_HitTestResultType;
  }
}

/// from: android.webkit.WebView$PictureListener
class WebView_PictureListener extends jni.JObject {
  @override
  late final jni.JObjType<WebView_PictureListener> $type = type;

  WebView_PictureListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/webkit/WebView$PictureListener");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_PictureListenerType();
  static final _id_onNewPicture = _class.instanceMethodId(
    r"onNewPicture",
    r"(Landroid/webkit/WebView;Landroid/graphics/Picture;)V",
  );

  /// from: public abstract void onNewPicture(android.webkit.WebView webView, android.graphics.Picture picture)
  void onNewPicture(
    WebView webView,
    jni.JObject picture,
  ) {
    _id_onNewPicture(this, const jni.jvoidType(),
        [webView.reference.pointer, picture.reference.pointer]);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebView_PictureListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onNewPicture(Landroid/webkit/WebView;Landroid/graphics/Picture;)V") {
        _$impls[$p]!.onNewPicture(
          $a[0].castTo(const $WebViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory WebView_PictureListener.implement(
    $WebView_PictureListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebView_PictureListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"android.webkit.WebView$PictureListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $WebView_PictureListenerImpl {
  factory $WebView_PictureListenerImpl({
    required void Function(WebView webView, jni.JObject picture) onNewPicture,
  }) = _$WebView_PictureListenerImpl;

  void onNewPicture(WebView webView, jni.JObject picture);
}

class _$WebView_PictureListenerImpl implements $WebView_PictureListenerImpl {
  _$WebView_PictureListenerImpl({
    required void Function(WebView webView, jni.JObject picture) onNewPicture,
  }) : _onNewPicture = onNewPicture;

  final void Function(WebView webView, jni.JObject picture) _onNewPicture;

  void onNewPicture(WebView webView, jni.JObject picture) {
    return _onNewPicture(webView, picture);
  }
}

final class $WebView_PictureListenerType
    extends jni.JObjType<WebView_PictureListener> {
  const $WebView_PictureListenerType();

  @override
  String get signature => r"Landroid/webkit/WebView$PictureListener;";

  @override
  WebView_PictureListener fromReference(jni.JReference reference) =>
      WebView_PictureListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_PictureListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_PictureListenerType) &&
        other is $WebView_PictureListenerType;
  }
}

/// from: android.webkit.WebView$VisualStateCallback
class WebView_VisualStateCallback extends jni.JObject {
  @override
  late final jni.JObjType<WebView_VisualStateCallback> $type = type;

  WebView_VisualStateCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/webkit/WebView$VisualStateCallback");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_VisualStateCallbackType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView_VisualStateCallback() {
    return WebView_VisualStateCallback.fromReference(
        _id_new0(_class, referenceType, []));
  }

  static final _id_onComplete = _class.instanceMethodId(
    r"onComplete",
    r"(J)V",
  );

  /// from: public abstract void onComplete(long j)
  void onComplete(
    int j,
  ) {
    _id_onComplete(this, const jni.jvoidType(), [j]);
  }
}

final class $WebView_VisualStateCallbackType
    extends jni.JObjType<WebView_VisualStateCallback> {
  const $WebView_VisualStateCallbackType();

  @override
  String get signature => r"Landroid/webkit/WebView$VisualStateCallback;";

  @override
  WebView_VisualStateCallback fromReference(jni.JReference reference) =>
      WebView_VisualStateCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_VisualStateCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_VisualStateCallbackType) &&
        other is $WebView_VisualStateCallbackType;
  }
}

/// from: android.webkit.WebView$WebViewTransport
class WebView_WebViewTransport extends jni.JObject {
  @override
  late final jni.JObjType<WebView_WebViewTransport> $type = type;

  WebView_WebViewTransport.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"android/webkit/WebView$WebViewTransport");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_WebViewTransportType();
  static final _id_new0 = _class.constructorId(
    r"(Landroid/webkit/WebView;)V",
  );

  /// from: public void <init>(android.webkit.WebView webView)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView_WebViewTransport(
    WebView webView,
  ) {
    return WebView_WebViewTransport.fromReference(
        _id_new0(_class, referenceType, [webView.reference.pointer]));
  }

  static final _id_setWebView = _class.instanceMethodId(
    r"setWebView",
    r"(Landroid/webkit/WebView;)V",
  );

  /// from: public void setWebView(android.webkit.WebView webView)
  void setWebView(
    WebView webView,
  ) {
    _id_setWebView(this, const jni.jvoidType(), [webView.reference.pointer]);
  }

  static final _id_getWebView = _class.instanceMethodId(
    r"getWebView",
    r"()Landroid/webkit/WebView;",
  );

  /// from: public android.webkit.WebView getWebView()
  /// The returned object must be released after use, by calling the [release] method.
  WebView getWebView() {
    return _id_getWebView(this, const $WebViewType(), []);
  }
}

final class $WebView_WebViewTransportType
    extends jni.JObjType<WebView_WebViewTransport> {
  const $WebView_WebViewTransportType();

  @override
  String get signature => r"Landroid/webkit/WebView$WebViewTransport;";

  @override
  WebView_WebViewTransport fromReference(jni.JReference reference) =>
      WebView_WebViewTransport.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_WebViewTransportType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_WebViewTransportType) &&
        other is $WebView_WebViewTransportType;
  }
}

/// from: android.webkit.WebView
class WebView extends jni.JObject {
  @override
  late final jni.JObjType<WebView> $type = type;

  WebView.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"android/webkit/WebView");

  /// The type which includes information such as the signature of this class.
  static const type = $WebViewType();

  /// from: static public final int RENDERER_PRIORITY_BOUND
  static const RENDERER_PRIORITY_BOUND = 1;

  /// from: static public final int RENDERER_PRIORITY_IMPORTANT
  static const RENDERER_PRIORITY_IMPORTANT = 2;

  /// from: static public final int RENDERER_PRIORITY_WAIVED
  static const RENDERER_PRIORITY_WAIVED = 0;
  static final _id_SCHEME_GEO = _class.staticFieldId(
    r"SCHEME_GEO",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String SCHEME_GEO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEME_GEO =>
      _id_SCHEME_GEO.get(_class, const jni.JStringType());

  static final _id_SCHEME_MAILTO = _class.staticFieldId(
    r"SCHEME_MAILTO",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String SCHEME_MAILTO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEME_MAILTO =>
      _id_SCHEME_MAILTO.get(_class, const jni.JStringType());

  static final _id_SCHEME_TEL = _class.staticFieldId(
    r"SCHEME_TEL",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String SCHEME_TEL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEME_TEL =>
      _id_SCHEME_TEL.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r"(Landroid/content/Context;)V",
  );

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView(
    jni.JObject context,
  ) {
    return WebView.fromReference(
        _id_new0(_class, referenceType, [context.reference.pointer]));
  }

  static final _id_new1 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new1(
    jni.JObject context,
    jni.JObject attributeSet,
  ) {
    return WebView.fromReference(_id_new1(_class, referenceType,
        [context.reference.pointer, attributeSet.reference.pointer]));
  }

  static final _id_new2 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;I)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new2(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
  ) {
    return WebView.fromReference(_id_new2(_class, referenceType, [
      context.reference.pointer,
      attributeSet.reference.pointer,
      jni.JValueInt(i)
    ]));
  }

  static final _id_new3 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;II)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new3(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    int i1,
  ) {
    return WebView.fromReference(_id_new3(_class, referenceType, [
      context.reference.pointer,
      attributeSet.reference.pointer,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]));
  }

  static final _id_new4 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;IZ)V",
  );

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new4(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    bool z,
  ) {
    return WebView.fromReference(_id_new4(_class, referenceType, [
      context.reference.pointer,
      attributeSet.reference.pointer,
      jni.JValueInt(i),
      z ? 1 : 0
    ]));
  }

  static final _id_setHorizontalScrollbarOverlay = _class.instanceMethodId(
    r"setHorizontalScrollbarOverlay",
    r"(Z)V",
  );

  /// from: public void setHorizontalScrollbarOverlay(boolean z)
  void setHorizontalScrollbarOverlay(
    bool z,
  ) {
    _id_setHorizontalScrollbarOverlay(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setVerticalScrollbarOverlay = _class.instanceMethodId(
    r"setVerticalScrollbarOverlay",
    r"(Z)V",
  );

  /// from: public void setVerticalScrollbarOverlay(boolean z)
  void setVerticalScrollbarOverlay(
    bool z,
  ) {
    _id_setVerticalScrollbarOverlay(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_overlayHorizontalScrollbar = _class.instanceMethodId(
    r"overlayHorizontalScrollbar",
    r"()Z",
  );

  /// from: public boolean overlayHorizontalScrollbar()
  bool overlayHorizontalScrollbar() {
    return _id_overlayHorizontalScrollbar(this, const jni.jbooleanType(), []);
  }

  static final _id_overlayVerticalScrollbar = _class.instanceMethodId(
    r"overlayVerticalScrollbar",
    r"()Z",
  );

  /// from: public boolean overlayVerticalScrollbar()
  bool overlayVerticalScrollbar() {
    return _id_overlayVerticalScrollbar(this, const jni.jbooleanType(), []);
  }

  static final _id_getCertificate = _class.instanceMethodId(
    r"getCertificate",
    r"()Landroid/net/http/SslCertificate;",
  );

  /// from: public android.net.http.SslCertificate getCertificate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCertificate() {
    return _id_getCertificate(this, const jni.JObjectType(), []);
  }

  static final _id_setCertificate = _class.instanceMethodId(
    r"setCertificate",
    r"(Landroid/net/http/SslCertificate;)V",
  );

  /// from: public void setCertificate(android.net.http.SslCertificate sslCertificate)
  void setCertificate(
    jni.JObject sslCertificate,
  ) {
    _id_setCertificate(
        this, const jni.jvoidType(), [sslCertificate.reference.pointer]);
  }

  static final _id_savePassword = _class.instanceMethodId(
    r"savePassword",
    r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V",
  );

  /// from: public void savePassword(java.lang.String string, java.lang.String string1, java.lang.String string2)
  void savePassword(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    _id_savePassword(this, const jni.jvoidType(), [
      string.reference.pointer,
      string1.reference.pointer,
      string2.reference.pointer
    ]);
  }

  static final _id_setHttpAuthUsernamePassword = _class.instanceMethodId(
    r"setHttpAuthUsernamePassword",
    r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V",
  );

  /// from: public void setHttpAuthUsernamePassword(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)
  void setHttpAuthUsernamePassword(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
  ) {
    _id_setHttpAuthUsernamePassword(this, const jni.jvoidType(), [
      string.reference.pointer,
      string1.reference.pointer,
      string2.reference.pointer,
      string3.reference.pointer
    ]);
  }

  static final _id_getHttpAuthUsernamePassword = _class.instanceMethodId(
    r"getHttpAuthUsernamePassword",
    r"(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;",
  );

  /// from: public java.lang.String[] getHttpAuthUsernamePassword(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getHttpAuthUsernamePassword(
    jni.JString string,
    jni.JString string1,
  ) {
    return _id_getHttpAuthUsernamePassword(
        this,
        const jni.JArrayType(jni.JStringType()),
        [string.reference.pointer, string1.reference.pointer]);
  }

  static final _id_destroy = _class.instanceMethodId(
    r"destroy",
    r"()V",
  );

  /// from: public void destroy()
  void destroy() {
    _id_destroy(this, const jni.jvoidType(), []);
  }

  static final _id_setNetworkAvailable = _class.instanceMethodId(
    r"setNetworkAvailable",
    r"(Z)V",
  );

  /// from: public void setNetworkAvailable(boolean z)
  void setNetworkAvailable(
    bool z,
  ) {
    _id_setNetworkAvailable(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_saveState = _class.instanceMethodId(
    r"saveState",
    r"(Landroid/os/Bundle;)Landroid/webkit/WebBackForwardList;",
  );

  /// from: public android.webkit.WebBackForwardList saveState(android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject saveState(
    jni.JObject bundle,
  ) {
    return _id_saveState(
        this, const jni.JObjectType(), [bundle.reference.pointer]);
  }

  static final _id_restoreState = _class.instanceMethodId(
    r"restoreState",
    r"(Landroid/os/Bundle;)Landroid/webkit/WebBackForwardList;",
  );

  /// from: public android.webkit.WebBackForwardList restoreState(android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject restoreState(
    jni.JObject bundle,
  ) {
    return _id_restoreState(
        this, const jni.JObjectType(), [bundle.reference.pointer]);
  }

  static final _id_loadUrl = _class.instanceMethodId(
    r"loadUrl",
    r"(Ljava/lang/String;Ljava/util/Map;)V",
  );

  /// from: public void loadUrl(java.lang.String string, java.util.Map map)
  void loadUrl(
    jni.JString string,
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    _id_loadUrl(this, const jni.jvoidType(),
        [string.reference.pointer, map.reference.pointer]);
  }

  static final _id_loadUrl1 = _class.instanceMethodId(
    r"loadUrl",
    r"(Ljava/lang/String;)V",
  );

  /// from: public void loadUrl(java.lang.String string)
  void loadUrl1(
    jni.JString string,
  ) {
    _id_loadUrl1(this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_postUrl = _class.instanceMethodId(
    r"postUrl",
    r"(Ljava/lang/String;[B)V",
  );

  /// from: public void postUrl(java.lang.String string, byte[] bs)
  void postUrl(
    jni.JString string,
    jni.JArray<jni.jbyte> bs,
  ) {
    _id_postUrl(this, const jni.jvoidType(),
        [string.reference.pointer, bs.reference.pointer]);
  }

  static final _id_loadData = _class.instanceMethodId(
    r"loadData",
    r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V",
  );

  /// from: public void loadData(java.lang.String string, java.lang.String string1, java.lang.String string2)
  void loadData(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    _id_loadData(this, const jni.jvoidType(), [
      string.reference.pointer,
      string1.reference.pointer,
      string2.reference.pointer
    ]);
  }

  static final _id_loadDataWithBaseURL = _class.instanceMethodId(
    r"loadDataWithBaseURL",
    r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V",
  );

  /// from: public void loadDataWithBaseURL(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4)
  void loadDataWithBaseURL(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
  ) {
    _id_loadDataWithBaseURL(this, const jni.jvoidType(), [
      string.reference.pointer,
      string1.reference.pointer,
      string2.reference.pointer,
      string3.reference.pointer,
      string4.reference.pointer
    ]);
  }

  static final _id_evaluateJavascript = _class.instanceMethodId(
    r"evaluateJavascript",
    r"(Ljava/lang/String;Landroid/webkit/ValueCallback;)V",
  );

  /// from: public void evaluateJavascript(java.lang.String string, android.webkit.ValueCallback valueCallback)
  void evaluateJavascript(
    jni.JString string,
    jni.JObject valueCallback,
  ) {
    _id_evaluateJavascript(this, const jni.jvoidType(),
        [string.reference.pointer, valueCallback.reference.pointer]);
  }

  static final _id_saveWebArchive = _class.instanceMethodId(
    r"saveWebArchive",
    r"(Ljava/lang/String;)V",
  );

  /// from: public void saveWebArchive(java.lang.String string)
  void saveWebArchive(
    jni.JString string,
  ) {
    _id_saveWebArchive(this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_saveWebArchive1 = _class.instanceMethodId(
    r"saveWebArchive",
    r"(Ljava/lang/String;ZLandroid/webkit/ValueCallback;)V",
  );

  /// from: public void saveWebArchive(java.lang.String string, boolean z, android.webkit.ValueCallback valueCallback)
  void saveWebArchive1(
    jni.JString string,
    bool z,
    jni.JObject valueCallback,
  ) {
    _id_saveWebArchive1(this, const jni.jvoidType(),
        [string.reference.pointer, z ? 1 : 0, valueCallback.reference.pointer]);
  }

  static final _id_stopLoading = _class.instanceMethodId(
    r"stopLoading",
    r"()V",
  );

  /// from: public void stopLoading()
  void stopLoading() {
    _id_stopLoading(this, const jni.jvoidType(), []);
  }

  static final _id_reload = _class.instanceMethodId(
    r"reload",
    r"()V",
  );

  /// from: public void reload()
  void reload() {
    _id_reload(this, const jni.jvoidType(), []);
  }

  static final _id_canGoBack = _class.instanceMethodId(
    r"canGoBack",
    r"()Z",
  );

  /// from: public boolean canGoBack()
  bool canGoBack() {
    return _id_canGoBack(this, const jni.jbooleanType(), []);
  }

  static final _id_goBack = _class.instanceMethodId(
    r"goBack",
    r"()V",
  );

  /// from: public void goBack()
  void goBack() {
    _id_goBack(this, const jni.jvoidType(), []);
  }

  static final _id_canGoForward = _class.instanceMethodId(
    r"canGoForward",
    r"()Z",
  );

  /// from: public boolean canGoForward()
  bool canGoForward() {
    return _id_canGoForward(this, const jni.jbooleanType(), []);
  }

  static final _id_goForward = _class.instanceMethodId(
    r"goForward",
    r"()V",
  );

  /// from: public void goForward()
  void goForward() {
    _id_goForward(this, const jni.jvoidType(), []);
  }

  static final _id_canGoBackOrForward = _class.instanceMethodId(
    r"canGoBackOrForward",
    r"(I)Z",
  );

  /// from: public boolean canGoBackOrForward(int i)
  bool canGoBackOrForward(
    int i,
  ) {
    return _id_canGoBackOrForward(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_goBackOrForward = _class.instanceMethodId(
    r"goBackOrForward",
    r"(I)V",
  );

  /// from: public void goBackOrForward(int i)
  void goBackOrForward(
    int i,
  ) {
    _id_goBackOrForward(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_isPrivateBrowsingEnabled = _class.instanceMethodId(
    r"isPrivateBrowsingEnabled",
    r"()Z",
  );

  /// from: public boolean isPrivateBrowsingEnabled()
  bool isPrivateBrowsingEnabled() {
    return _id_isPrivateBrowsingEnabled(this, const jni.jbooleanType(), []);
  }

  static final _id_pageUp = _class.instanceMethodId(
    r"pageUp",
    r"(Z)Z",
  );

  /// from: public boolean pageUp(boolean z)
  bool pageUp(
    bool z,
  ) {
    return _id_pageUp(this, const jni.jbooleanType(), [z ? 1 : 0]);
  }

  static final _id_pageDown = _class.instanceMethodId(
    r"pageDown",
    r"(Z)Z",
  );

  /// from: public boolean pageDown(boolean z)
  bool pageDown(
    bool z,
  ) {
    return _id_pageDown(this, const jni.jbooleanType(), [z ? 1 : 0]);
  }

  static final _id_postVisualStateCallback = _class.instanceMethodId(
    r"postVisualStateCallback",
    r"(JLandroid/webkit/WebView$VisualStateCallback;)V",
  );

  /// from: public void postVisualStateCallback(long j, android.webkit.WebView$VisualStateCallback visualStateCallback)
  void postVisualStateCallback(
    int j,
    WebView_VisualStateCallback visualStateCallback,
  ) {
    _id_postVisualStateCallback(this, const jni.jvoidType(),
        [j, visualStateCallback.reference.pointer]);
  }

  static final _id_clearView = _class.instanceMethodId(
    r"clearView",
    r"()V",
  );

  /// from: public void clearView()
  void clearView() {
    _id_clearView(this, const jni.jvoidType(), []);
  }

  static final _id_capturePicture = _class.instanceMethodId(
    r"capturePicture",
    r"()Landroid/graphics/Picture;",
  );

  /// from: public android.graphics.Picture capturePicture()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject capturePicture() {
    return _id_capturePicture(this, const jni.JObjectType(), []);
  }

  static final _id_createPrintDocumentAdapter = _class.instanceMethodId(
    r"createPrintDocumentAdapter",
    r"()Landroid/print/PrintDocumentAdapter;",
  );

  /// from: public android.print.PrintDocumentAdapter createPrintDocumentAdapter()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createPrintDocumentAdapter() {
    return _id_createPrintDocumentAdapter(this, const jni.JObjectType(), []);
  }

  static final _id_createPrintDocumentAdapter1 = _class.instanceMethodId(
    r"createPrintDocumentAdapter",
    r"(Ljava/lang/String;)Landroid/print/PrintDocumentAdapter;",
  );

  /// from: public android.print.PrintDocumentAdapter createPrintDocumentAdapter(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createPrintDocumentAdapter1(
    jni.JString string,
  ) {
    return _id_createPrintDocumentAdapter1(
        this, const jni.JObjectType(), [string.reference.pointer]);
  }

  static final _id_getScale = _class.instanceMethodId(
    r"getScale",
    r"()F",
  );

  /// from: public float getScale()
  double getScale() {
    return _id_getScale(this, const jni.jfloatType(), []);
  }

  static final _id_setInitialScale = _class.instanceMethodId(
    r"setInitialScale",
    r"(I)V",
  );

  /// from: public void setInitialScale(int i)
  void setInitialScale(
    int i,
  ) {
    _id_setInitialScale(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_invokeZoomPicker = _class.instanceMethodId(
    r"invokeZoomPicker",
    r"()V",
  );

  /// from: public void invokeZoomPicker()
  void invokeZoomPicker() {
    _id_invokeZoomPicker(this, const jni.jvoidType(), []);
  }

  static final _id_getHitTestResult = _class.instanceMethodId(
    r"getHitTestResult",
    r"()Landroid/webkit/WebView$HitTestResult;",
  );

  /// from: public android.webkit.WebView$HitTestResult getHitTestResult()
  /// The returned object must be released after use, by calling the [release] method.
  WebView_HitTestResult getHitTestResult() {
    return _id_getHitTestResult(this, const $WebView_HitTestResultType(), []);
  }

  static final _id_requestFocusNodeHref = _class.instanceMethodId(
    r"requestFocusNodeHref",
    r"(Landroid/os/Message;)V",
  );

  /// from: public void requestFocusNodeHref(android.os.Message message)
  void requestFocusNodeHref(
    jni.JObject message,
  ) {
    _id_requestFocusNodeHref(
        this, const jni.jvoidType(), [message.reference.pointer]);
  }

  static final _id_requestImageRef = _class.instanceMethodId(
    r"requestImageRef",
    r"(Landroid/os/Message;)V",
  );

  /// from: public void requestImageRef(android.os.Message message)
  void requestImageRef(
    jni.JObject message,
  ) {
    _id_requestImageRef(
        this, const jni.jvoidType(), [message.reference.pointer]);
  }

  static final _id_getUrl = _class.instanceMethodId(
    r"getUrl",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() {
    return _id_getUrl(this, const jni.JStringType(), []);
  }

  static final _id_getOriginalUrl = _class.instanceMethodId(
    r"getOriginalUrl",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getOriginalUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOriginalUrl() {
    return _id_getOriginalUrl(this, const jni.JStringType(), []);
  }

  static final _id_getTitle = _class.instanceMethodId(
    r"getTitle",
    r"()Ljava/lang/String;",
  );

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _id_getTitle(this, const jni.JStringType(), []);
  }

  static final _id_getFavicon = _class.instanceMethodId(
    r"getFavicon",
    r"()Landroid/graphics/Bitmap;",
  );

  /// from: public android.graphics.Bitmap getFavicon()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFavicon() {
    return _id_getFavicon(this, const jni.JObjectType(), []);
  }

  static final _id_getProgress = _class.instanceMethodId(
    r"getProgress",
    r"()I",
  );

  /// from: public int getProgress()
  int getProgress() {
    return _id_getProgress(this, const jni.jintType(), []);
  }

  static final _id_getContentHeight = _class.instanceMethodId(
    r"getContentHeight",
    r"()I",
  );

  /// from: public int getContentHeight()
  int getContentHeight() {
    return _id_getContentHeight(this, const jni.jintType(), []);
  }

  static final _id_pauseTimers = _class.instanceMethodId(
    r"pauseTimers",
    r"()V",
  );

  /// from: public void pauseTimers()
  void pauseTimers() {
    _id_pauseTimers(this, const jni.jvoidType(), []);
  }

  static final _id_resumeTimers = _class.instanceMethodId(
    r"resumeTimers",
    r"()V",
  );

  /// from: public void resumeTimers()
  void resumeTimers() {
    _id_resumeTimers(this, const jni.jvoidType(), []);
  }

  static final _id_onPause = _class.instanceMethodId(
    r"onPause",
    r"()V",
  );

  /// from: public void onPause()
  void onPause() {
    _id_onPause(this, const jni.jvoidType(), []);
  }

  static final _id_onResume = _class.instanceMethodId(
    r"onResume",
    r"()V",
  );

  /// from: public void onResume()
  void onResume() {
    _id_onResume(this, const jni.jvoidType(), []);
  }

  static final _id_freeMemory = _class.instanceMethodId(
    r"freeMemory",
    r"()V",
  );

  /// from: public void freeMemory()
  void freeMemory() {
    _id_freeMemory(this, const jni.jvoidType(), []);
  }

  static final _id_clearCache = _class.instanceMethodId(
    r"clearCache",
    r"(Z)V",
  );

  /// from: public void clearCache(boolean z)
  void clearCache(
    bool z,
  ) {
    _id_clearCache(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_clearFormData = _class.instanceMethodId(
    r"clearFormData",
    r"()V",
  );

  /// from: public void clearFormData()
  void clearFormData() {
    _id_clearFormData(this, const jni.jvoidType(), []);
  }

  static final _id_clearHistory = _class.instanceMethodId(
    r"clearHistory",
    r"()V",
  );

  /// from: public void clearHistory()
  void clearHistory() {
    _id_clearHistory(this, const jni.jvoidType(), []);
  }

  static final _id_clearSslPreferences = _class.instanceMethodId(
    r"clearSslPreferences",
    r"()V",
  );

  /// from: public void clearSslPreferences()
  void clearSslPreferences() {
    _id_clearSslPreferences(this, const jni.jvoidType(), []);
  }

  static final _id_clearClientCertPreferences = _class.staticMethodId(
    r"clearClientCertPreferences",
    r"(Ljava/lang/Runnable;)V",
  );

  /// from: static public void clearClientCertPreferences(java.lang.Runnable runnable)
  static void clearClientCertPreferences(
    jni.JObject runnable,
  ) {
    _id_clearClientCertPreferences(
        _class, const jni.jvoidType(), [runnable.reference.pointer]);
  }

  static final _id_startSafeBrowsing = _class.staticMethodId(
    r"startSafeBrowsing",
    r"(Landroid/content/Context;Landroid/webkit/ValueCallback;)V",
  );

  /// from: static public void startSafeBrowsing(android.content.Context context, android.webkit.ValueCallback valueCallback)
  static void startSafeBrowsing(
    jni.JObject context,
    jni.JObject valueCallback,
  ) {
    _id_startSafeBrowsing(_class, const jni.jvoidType(),
        [context.reference.pointer, valueCallback.reference.pointer]);
  }

  static final _id_setSafeBrowsingWhitelist = _class.staticMethodId(
    r"setSafeBrowsingWhitelist",
    r"(Ljava/util/List;Landroid/webkit/ValueCallback;)V",
  );

  /// from: static public void setSafeBrowsingWhitelist(java.util.List list, android.webkit.ValueCallback valueCallback)
  static void setSafeBrowsingWhitelist(
    jni.JList<jni.JString> list,
    jni.JObject valueCallback,
  ) {
    _id_setSafeBrowsingWhitelist(_class, const jni.jvoidType(),
        [list.reference.pointer, valueCallback.reference.pointer]);
  }

  static final _id_getSafeBrowsingPrivacyPolicyUrl = _class.staticMethodId(
    r"getSafeBrowsingPrivacyPolicyUrl",
    r"()Landroid/net/Uri;",
  );

  /// from: static public android.net.Uri getSafeBrowsingPrivacyPolicyUrl()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getSafeBrowsingPrivacyPolicyUrl() {
    return _id_getSafeBrowsingPrivacyPolicyUrl(
        _class, const jni.JObjectType(), []);
  }

  static final _id_copyBackForwardList = _class.instanceMethodId(
    r"copyBackForwardList",
    r"()Landroid/webkit/WebBackForwardList;",
  );

  /// from: public android.webkit.WebBackForwardList copyBackForwardList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject copyBackForwardList() {
    return _id_copyBackForwardList(this, const jni.JObjectType(), []);
  }

  static final _id_setFindListener = _class.instanceMethodId(
    r"setFindListener",
    r"(Landroid/webkit/WebView$FindListener;)V",
  );

  /// from: public void setFindListener(android.webkit.WebView$FindListener findListener)
  void setFindListener(
    WebView_FindListener findListener,
  ) {
    _id_setFindListener(
        this, const jni.jvoidType(), [findListener.reference.pointer]);
  }

  static final _id_findNext = _class.instanceMethodId(
    r"findNext",
    r"(Z)V",
  );

  /// from: public void findNext(boolean z)
  void findNext(
    bool z,
  ) {
    _id_findNext(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_findAll = _class.instanceMethodId(
    r"findAll",
    r"(Ljava/lang/String;)I",
  );

  /// from: public int findAll(java.lang.String string)
  int findAll(
    jni.JString string,
  ) {
    return _id_findAll(this, const jni.jintType(), [string.reference.pointer]);
  }

  static final _id_findAllAsync = _class.instanceMethodId(
    r"findAllAsync",
    r"(Ljava/lang/String;)V",
  );

  /// from: public void findAllAsync(java.lang.String string)
  void findAllAsync(
    jni.JString string,
  ) {
    _id_findAllAsync(this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_showFindDialog = _class.instanceMethodId(
    r"showFindDialog",
    r"(Ljava/lang/String;Z)Z",
  );

  /// from: public boolean showFindDialog(java.lang.String string, boolean z)
  bool showFindDialog(
    jni.JString string,
    bool z,
  ) {
    return _id_showFindDialog(
        this, const jni.jbooleanType(), [string.reference.pointer, z ? 1 : 0]);
  }

  static final _id_findAddress = _class.staticMethodId(
    r"findAddress",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  /// from: static public java.lang.String findAddress(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString findAddress(
    jni.JString string,
  ) {
    return _id_findAddress(
        _class, const jni.JStringType(), [string.reference.pointer]);
  }

  static final _id_enableSlowWholeDocumentDraw = _class.staticMethodId(
    r"enableSlowWholeDocumentDraw",
    r"()V",
  );

  /// from: static public void enableSlowWholeDocumentDraw()
  static void enableSlowWholeDocumentDraw() {
    _id_enableSlowWholeDocumentDraw(_class, const jni.jvoidType(), []);
  }

  static final _id_clearMatches = _class.instanceMethodId(
    r"clearMatches",
    r"()V",
  );

  /// from: public void clearMatches()
  void clearMatches() {
    _id_clearMatches(this, const jni.jvoidType(), []);
  }

  static final _id_documentHasImages = _class.instanceMethodId(
    r"documentHasImages",
    r"(Landroid/os/Message;)V",
  );

  /// from: public void documentHasImages(android.os.Message message)
  void documentHasImages(
    jni.JObject message,
  ) {
    _id_documentHasImages(
        this, const jni.jvoidType(), [message.reference.pointer]);
  }

  static final _id_setWebViewClient = _class.instanceMethodId(
    r"setWebViewClient",
    r"(Landroid/webkit/WebViewClient;)V",
  );

  /// from: public void setWebViewClient(android.webkit.WebViewClient webViewClient)
  void setWebViewClient(
    jni.JObject webViewClient,
  ) {
    _id_setWebViewClient(
        this, const jni.jvoidType(), [webViewClient.reference.pointer]);
  }

  static final _id_getWebViewClient = _class.instanceMethodId(
    r"getWebViewClient",
    r"()Landroid/webkit/WebViewClient;",
  );

  /// from: public android.webkit.WebViewClient getWebViewClient()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewClient() {
    return _id_getWebViewClient(this, const jni.JObjectType(), []);
  }

  static final _id_getWebViewRenderProcess = _class.instanceMethodId(
    r"getWebViewRenderProcess",
    r"()Landroid/webkit/WebViewRenderProcess;",
  );

  /// from: public android.webkit.WebViewRenderProcess getWebViewRenderProcess()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewRenderProcess() {
    return _id_getWebViewRenderProcess(this, const jni.JObjectType(), []);
  }

  static final _id_setWebViewRenderProcessClient = _class.instanceMethodId(
    r"setWebViewRenderProcessClient",
    r"(Ljava/util/concurrent/Executor;Landroid/webkit/WebViewRenderProcessClient;)V",
  );

  /// from: public void setWebViewRenderProcessClient(java.util.concurrent.Executor executor, android.webkit.WebViewRenderProcessClient webViewRenderProcessClient)
  void setWebViewRenderProcessClient(
    jni.JObject executor,
    jni.JObject webViewRenderProcessClient,
  ) {
    _id_setWebViewRenderProcessClient(this, const jni.jvoidType(), [
      executor.reference.pointer,
      webViewRenderProcessClient.reference.pointer
    ]);
  }

  static final _id_setWebViewRenderProcessClient1 = _class.instanceMethodId(
    r"setWebViewRenderProcessClient",
    r"(Landroid/webkit/WebViewRenderProcessClient;)V",
  );

  /// from: public void setWebViewRenderProcessClient(android.webkit.WebViewRenderProcessClient webViewRenderProcessClient)
  void setWebViewRenderProcessClient1(
    jni.JObject webViewRenderProcessClient,
  ) {
    _id_setWebViewRenderProcessClient1(this, const jni.jvoidType(),
        [webViewRenderProcessClient.reference.pointer]);
  }

  static final _id_getWebViewRenderProcessClient = _class.instanceMethodId(
    r"getWebViewRenderProcessClient",
    r"()Landroid/webkit/WebViewRenderProcessClient;",
  );

  /// from: public android.webkit.WebViewRenderProcessClient getWebViewRenderProcessClient()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewRenderProcessClient() {
    return _id_getWebViewRenderProcessClient(this, const jni.JObjectType(), []);
  }

  static final _id_setDownloadListener = _class.instanceMethodId(
    r"setDownloadListener",
    r"(Landroid/webkit/DownloadListener;)V",
  );

  /// from: public void setDownloadListener(android.webkit.DownloadListener downloadListener)
  void setDownloadListener(
    jni.JObject downloadListener,
  ) {
    _id_setDownloadListener(
        this, const jni.jvoidType(), [downloadListener.reference.pointer]);
  }

  static final _id_setWebChromeClient = _class.instanceMethodId(
    r"setWebChromeClient",
    r"(Landroid/webkit/WebChromeClient;)V",
  );

  /// from: public void setWebChromeClient(android.webkit.WebChromeClient webChromeClient)
  void setWebChromeClient(
    jni.JObject webChromeClient,
  ) {
    _id_setWebChromeClient(
        this, const jni.jvoidType(), [webChromeClient.reference.pointer]);
  }

  static final _id_getWebChromeClient = _class.instanceMethodId(
    r"getWebChromeClient",
    r"()Landroid/webkit/WebChromeClient;",
  );

  /// from: public android.webkit.WebChromeClient getWebChromeClient()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebChromeClient() {
    return _id_getWebChromeClient(this, const jni.JObjectType(), []);
  }

  static final _id_setPictureListener = _class.instanceMethodId(
    r"setPictureListener",
    r"(Landroid/webkit/WebView$PictureListener;)V",
  );

  /// from: public void setPictureListener(android.webkit.WebView$PictureListener pictureListener)
  void setPictureListener(
    WebView_PictureListener pictureListener,
  ) {
    _id_setPictureListener(
        this, const jni.jvoidType(), [pictureListener.reference.pointer]);
  }

  static final _id_addJavascriptInterface = _class.instanceMethodId(
    r"addJavascriptInterface",
    r"(Ljava/lang/Object;Ljava/lang/String;)V",
  );

  /// from: public void addJavascriptInterface(java.lang.Object object, java.lang.String string)
  void addJavascriptInterface(
    jni.JObject object,
    jni.JString string,
  ) {
    _id_addJavascriptInterface(this, const jni.jvoidType(),
        [object.reference.pointer, string.reference.pointer]);
  }

  static final _id_removeJavascriptInterface = _class.instanceMethodId(
    r"removeJavascriptInterface",
    r"(Ljava/lang/String;)V",
  );

  /// from: public void removeJavascriptInterface(java.lang.String string)
  void removeJavascriptInterface(
    jni.JString string,
  ) {
    _id_removeJavascriptInterface(
        this, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_createWebMessageChannel = _class.instanceMethodId(
    r"createWebMessageChannel",
    r"()[Landroid/webkit/WebMessagePort;",
  );

  /// from: public android.webkit.WebMessagePort[] createWebMessageChannel()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> createWebMessageChannel() {
    return _id_createWebMessageChannel(
        this, const jni.JArrayType(jni.JObjectType()), []);
  }

  static final _id_postWebMessage = _class.instanceMethodId(
    r"postWebMessage",
    r"(Landroid/webkit/WebMessage;Landroid/net/Uri;)V",
  );

  /// from: public void postWebMessage(android.webkit.WebMessage webMessage, android.net.Uri uri)
  void postWebMessage(
    jni.JObject webMessage,
    jni.JObject uri,
  ) {
    _id_postWebMessage(this, const jni.jvoidType(),
        [webMessage.reference.pointer, uri.reference.pointer]);
  }

  static final _id_getSettings = _class.instanceMethodId(
    r"getSettings",
    r"()Landroid/webkit/WebSettings;",
  );

  /// from: public android.webkit.WebSettings getSettings()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSettings() {
    return _id_getSettings(this, const jni.JObjectType(), []);
  }

  static final _id_setWebContentsDebuggingEnabled = _class.staticMethodId(
    r"setWebContentsDebuggingEnabled",
    r"(Z)V",
  );

  /// from: static public void setWebContentsDebuggingEnabled(boolean z)
  static void setWebContentsDebuggingEnabled(
    bool z,
  ) {
    _id_setWebContentsDebuggingEnabled(
        _class, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_setDataDirectorySuffix = _class.staticMethodId(
    r"setDataDirectorySuffix",
    r"(Ljava/lang/String;)V",
  );

  /// from: static public void setDataDirectorySuffix(java.lang.String string)
  static void setDataDirectorySuffix(
    jni.JString string,
  ) {
    _id_setDataDirectorySuffix(
        _class, const jni.jvoidType(), [string.reference.pointer]);
  }

  static final _id_disableWebView = _class.staticMethodId(
    r"disableWebView",
    r"()V",
  );

  /// from: static public void disableWebView()
  static void disableWebView() {
    _id_disableWebView(_class, const jni.jvoidType(), []);
  }

  static final _id_onChildViewAdded = _class.instanceMethodId(
    r"onChildViewAdded",
    r"(Landroid/view/View;Landroid/view/View;)V",
  );

  /// from: public void onChildViewAdded(android.view.View view, android.view.View view1)
  void onChildViewAdded(
    View view,
    View view1,
  ) {
    _id_onChildViewAdded(this, const jni.jvoidType(),
        [view.reference.pointer, view1.reference.pointer]);
  }

  static final _id_onChildViewRemoved = _class.instanceMethodId(
    r"onChildViewRemoved",
    r"(Landroid/view/View;Landroid/view/View;)V",
  );

  /// from: public void onChildViewRemoved(android.view.View view, android.view.View view1)
  void onChildViewRemoved(
    View view,
    View view1,
  ) {
    _id_onChildViewRemoved(this, const jni.jvoidType(),
        [view.reference.pointer, view1.reference.pointer]);
  }

  static final _id_onGlobalFocusChanged = _class.instanceMethodId(
    r"onGlobalFocusChanged",
    r"(Landroid/view/View;Landroid/view/View;)V",
  );

  /// from: public void onGlobalFocusChanged(android.view.View view, android.view.View view1)
  void onGlobalFocusChanged(
    View view,
    View view1,
  ) {
    _id_onGlobalFocusChanged(this, const jni.jvoidType(),
        [view.reference.pointer, view1.reference.pointer]);
  }

  static final _id_setMapTrackballToArrowKeys = _class.instanceMethodId(
    r"setMapTrackballToArrowKeys",
    r"(Z)V",
  );

  /// from: public void setMapTrackballToArrowKeys(boolean z)
  void setMapTrackballToArrowKeys(
    bool z,
  ) {
    _id_setMapTrackballToArrowKeys(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_flingScroll = _class.instanceMethodId(
    r"flingScroll",
    r"(II)V",
  );

  /// from: public void flingScroll(int i, int i1)
  void flingScroll(
    int i,
    int i1,
  ) {
    _id_flingScroll(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_canZoomIn = _class.instanceMethodId(
    r"canZoomIn",
    r"()Z",
  );

  /// from: public boolean canZoomIn()
  bool canZoomIn() {
    return _id_canZoomIn(this, const jni.jbooleanType(), []);
  }

  static final _id_canZoomOut = _class.instanceMethodId(
    r"canZoomOut",
    r"()Z",
  );

  /// from: public boolean canZoomOut()
  bool canZoomOut() {
    return _id_canZoomOut(this, const jni.jbooleanType(), []);
  }

  static final _id_zoomBy = _class.instanceMethodId(
    r"zoomBy",
    r"(F)V",
  );

  /// from: public void zoomBy(float f)
  void zoomBy(
    double f,
  ) {
    _id_zoomBy(this, const jni.jvoidType(), [jni.JValueFloat(f)]);
  }

  static final _id_zoomIn = _class.instanceMethodId(
    r"zoomIn",
    r"()Z",
  );

  /// from: public boolean zoomIn()
  bool zoomIn() {
    return _id_zoomIn(this, const jni.jbooleanType(), []);
  }

  static final _id_zoomOut = _class.instanceMethodId(
    r"zoomOut",
    r"()Z",
  );

  /// from: public boolean zoomOut()
  bool zoomOut() {
    return _id_zoomOut(this, const jni.jbooleanType(), []);
  }

  static final _id_setRendererPriorityPolicy = _class.instanceMethodId(
    r"setRendererPriorityPolicy",
    r"(IZ)V",
  );

  /// from: public void setRendererPriorityPolicy(int i, boolean z)
  void setRendererPriorityPolicy(
    int i,
    bool z,
  ) {
    _id_setRendererPriorityPolicy(
        this, const jni.jvoidType(), [jni.JValueInt(i), z ? 1 : 0]);
  }

  static final _id_getRendererRequestedPriority = _class.instanceMethodId(
    r"getRendererRequestedPriority",
    r"()I",
  );

  /// from: public int getRendererRequestedPriority()
  int getRendererRequestedPriority() {
    return _id_getRendererRequestedPriority(this, const jni.jintType(), []);
  }

  static final _id_getRendererPriorityWaivedWhenNotVisible =
      _class.instanceMethodId(
    r"getRendererPriorityWaivedWhenNotVisible",
    r"()Z",
  );

  /// from: public boolean getRendererPriorityWaivedWhenNotVisible()
  bool getRendererPriorityWaivedWhenNotVisible() {
    return _id_getRendererPriorityWaivedWhenNotVisible(
        this, const jni.jbooleanType(), []);
  }

  static final _id_setTextClassifier = _class.instanceMethodId(
    r"setTextClassifier",
    r"(Landroid/view/textclassifier/TextClassifier;)V",
  );

  /// from: public void setTextClassifier(android.view.textclassifier.TextClassifier textClassifier)
  void setTextClassifier(
    jni.JObject textClassifier,
  ) {
    _id_setTextClassifier(
        this, const jni.jvoidType(), [textClassifier.reference.pointer]);
  }

  static final _id_getTextClassifier = _class.instanceMethodId(
    r"getTextClassifier",
    r"()Landroid/view/textclassifier/TextClassifier;",
  );

  /// from: public android.view.textclassifier.TextClassifier getTextClassifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTextClassifier() {
    return _id_getTextClassifier(this, const jni.JObjectType(), []);
  }

  static final _id_getWebViewClassLoader = _class.staticMethodId(
    r"getWebViewClassLoader",
    r"()Ljava/lang/ClassLoader;",
  );

  /// from: static public java.lang.ClassLoader getWebViewClassLoader()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getWebViewClassLoader() {
    return _id_getWebViewClassLoader(_class, const jni.JObjectType(), []);
  }

  static final _id_getWebViewLooper = _class.instanceMethodId(
    r"getWebViewLooper",
    r"()Landroid/os/Looper;",
  );

  /// from: public android.os.Looper getWebViewLooper()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewLooper() {
    return _id_getWebViewLooper(this, const jni.JObjectType(), []);
  }

  static final _id_onAttachedToWindow = _class.instanceMethodId(
    r"onAttachedToWindow",
    r"()V",
  );

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() {
    _id_onAttachedToWindow(this, const jni.jvoidType(), []);
  }

  static final _id_setLayoutParams = _class.instanceMethodId(
    r"setLayoutParams",
    r"(Landroid/view/ViewGroup$LayoutParams;)V",
  );

  /// from: public void setLayoutParams(android.view.ViewGroup$LayoutParams layoutParams)
  void setLayoutParams(
    jni.JObject layoutParams,
  ) {
    _id_setLayoutParams(
        this, const jni.jvoidType(), [layoutParams.reference.pointer]);
  }

  static final _id_setOverScrollMode = _class.instanceMethodId(
    r"setOverScrollMode",
    r"(I)V",
  );

  /// from: public void setOverScrollMode(int i)
  void setOverScrollMode(
    int i,
  ) {
    _id_setOverScrollMode(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setScrollBarStyle = _class.instanceMethodId(
    r"setScrollBarStyle",
    r"(I)V",
  );

  /// from: public void setScrollBarStyle(int i)
  void setScrollBarStyle(
    int i,
  ) {
    _id_setScrollBarStyle(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_computeHorizontalScrollRange = _class.instanceMethodId(
    r"computeHorizontalScrollRange",
    r"()I",
  );

  /// from: protected int computeHorizontalScrollRange()
  int computeHorizontalScrollRange() {
    return _id_computeHorizontalScrollRange(this, const jni.jintType(), []);
  }

  static final _id_computeHorizontalScrollOffset = _class.instanceMethodId(
    r"computeHorizontalScrollOffset",
    r"()I",
  );

  /// from: protected int computeHorizontalScrollOffset()
  int computeHorizontalScrollOffset() {
    return _id_computeHorizontalScrollOffset(this, const jni.jintType(), []);
  }

  static final _id_computeVerticalScrollRange = _class.instanceMethodId(
    r"computeVerticalScrollRange",
    r"()I",
  );

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange() {
    return _id_computeVerticalScrollRange(this, const jni.jintType(), []);
  }

  static final _id_computeVerticalScrollOffset = _class.instanceMethodId(
    r"computeVerticalScrollOffset",
    r"()I",
  );

  /// from: protected int computeVerticalScrollOffset()
  int computeVerticalScrollOffset() {
    return _id_computeVerticalScrollOffset(this, const jni.jintType(), []);
  }

  static final _id_computeVerticalScrollExtent = _class.instanceMethodId(
    r"computeVerticalScrollExtent",
    r"()I",
  );

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent() {
    return _id_computeVerticalScrollExtent(this, const jni.jintType(), []);
  }

  static final _id_computeScroll = _class.instanceMethodId(
    r"computeScroll",
    r"()V",
  );

  /// from: public void computeScroll()
  void computeScroll() {
    _id_computeScroll(this, const jni.jvoidType(), []);
  }

  static final _id_onHoverEvent = _class.instanceMethodId(
    r"onHoverEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onHoverEvent(android.view.MotionEvent motionEvent)
  bool onHoverEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onHoverEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r"onTouchEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onTouchEvent(android.view.MotionEvent motionEvent)
  bool onTouchEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onTouchEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onGenericMotionEvent = _class.instanceMethodId(
    r"onGenericMotionEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool onGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onGenericMotionEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onTrackballEvent = _class.instanceMethodId(
    r"onTrackballEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  /// from: public boolean onTrackballEvent(android.view.MotionEvent motionEvent)
  bool onTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return _id_onTrackballEvent(
        this, const jni.jbooleanType(), [motionEvent.reference.pointer]);
  }

  static final _id_onKeyDown = _class.instanceMethodId(
    r"onKeyDown",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyDown(int i, android.view.KeyEvent keyEvent)
  bool onKeyDown(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyDown(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onKeyUp = _class.instanceMethodId(
    r"onKeyUp",
    r"(ILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyUp(int i, android.view.KeyEvent keyEvent)
  bool onKeyUp(
    int i,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyUp(this, const jni.jbooleanType(),
        [jni.JValueInt(i), keyEvent.reference.pointer]);
  }

  static final _id_onKeyMultiple = _class.instanceMethodId(
    r"onKeyMultiple",
    r"(IILandroid/view/KeyEvent;)Z",
  );

  /// from: public boolean onKeyMultiple(int i, int i1, android.view.KeyEvent keyEvent)
  bool onKeyMultiple(
    int i,
    int i1,
    jni.JObject keyEvent,
  ) {
    return _id_onKeyMultiple(this, const jni.jbooleanType(),
        [jni.JValueInt(i), jni.JValueInt(i1), keyEvent.reference.pointer]);
  }

  static final _id_getAccessibilityNodeProvider = _class.instanceMethodId(
    r"getAccessibilityNodeProvider",
    r"()Landroid/view/accessibility/AccessibilityNodeProvider;",
  );

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityNodeProvider() {
    return _id_getAccessibilityNodeProvider(this, const jni.JObjectType(), []);
  }

  static final _id_shouldDelayChildPressedState = _class.instanceMethodId(
    r"shouldDelayChildPressedState",
    r"()Z",
  );

  /// from: public boolean shouldDelayChildPressedState()
  bool shouldDelayChildPressedState() {
    return _id_shouldDelayChildPressedState(this, const jni.jbooleanType(), []);
  }

  static final _id_getAccessibilityClassName = _class.instanceMethodId(
    r"getAccessibilityClassName",
    r"()Ljava/lang/CharSequence;",
  );

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityClassName() {
    return _id_getAccessibilityClassName(this, const jni.JObjectType(), []);
  }

  static final _id_onProvideVirtualStructure = _class.instanceMethodId(
    r"onProvideVirtualStructure",
    r"(Landroid/view/ViewStructure;)V",
  );

  /// from: public void onProvideVirtualStructure(android.view.ViewStructure viewStructure)
  void onProvideVirtualStructure(
    jni.JObject viewStructure,
  ) {
    _id_onProvideVirtualStructure(
        this, const jni.jvoidType(), [viewStructure.reference.pointer]);
  }

  static final _id_onProvideAutofillVirtualStructure = _class.instanceMethodId(
    r"onProvideAutofillVirtualStructure",
    r"(Landroid/view/ViewStructure;I)V",
  );

  /// from: public void onProvideAutofillVirtualStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideAutofillVirtualStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    _id_onProvideAutofillVirtualStructure(this, const jni.jvoidType(),
        [viewStructure.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_onProvideContentCaptureStructure = _class.instanceMethodId(
    r"onProvideContentCaptureStructure",
    r"(Landroid/view/ViewStructure;I)V",
  );

  /// from: public void onProvideContentCaptureStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideContentCaptureStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    _id_onProvideContentCaptureStructure(this, const jni.jvoidType(),
        [viewStructure.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_autofill = _class.instanceMethodId(
    r"autofill",
    r"(Landroid/util/SparseArray;)V",
  );

  /// from: public void autofill(android.util.SparseArray sparseArray)
  void autofill(
    jni.JObject sparseArray,
  ) {
    _id_autofill(this, const jni.jvoidType(), [sparseArray.reference.pointer]);
  }

  static final _id_isVisibleToUserForAutofill = _class.instanceMethodId(
    r"isVisibleToUserForAutofill",
    r"(I)Z",
  );

  /// from: public boolean isVisibleToUserForAutofill(int i)
  bool isVisibleToUserForAutofill(
    int i,
  ) {
    return _id_isVisibleToUserForAutofill(
        this, const jni.jbooleanType(), [jni.JValueInt(i)]);
  }

  static final _id_onCreateVirtualViewTranslationRequests =
      _class.instanceMethodId(
    r"onCreateVirtualViewTranslationRequests",
    r"([J[ILjava/util/function/Consumer;)V",
  );

  /// from: public void onCreateVirtualViewTranslationRequests(java.lang.Object[] js, java.lang.Object[] is, java.util.function.Consumer consumer)
  void onCreateVirtualViewTranslationRequests(
    jni.JArray<jni.jlong> js,
    jni.JArray<jni.jint> is0,
    jni.JObject consumer,
  ) {
    _id_onCreateVirtualViewTranslationRequests(this, const jni.jvoidType(), [
      js.reference.pointer,
      is0.reference.pointer,
      consumer.reference.pointer
    ]);
  }

  static final _id_dispatchCreateViewTranslationRequest =
      _class.instanceMethodId(
    r"dispatchCreateViewTranslationRequest",
    r"(Ljava/util/Map;[ILandroid/view/translation/TranslationCapability;Ljava/util/List;)V",
  );

  /// from: public void dispatchCreateViewTranslationRequest(java.util.Map map, java.lang.Object[] is, android.view.translation.TranslationCapability translationCapability, java.util.List list)
  void dispatchCreateViewTranslationRequest(
    jni.JMap<jni.JObject, jni.JArray<jni.jlong>> map,
    jni.JArray<jni.jint> is0,
    jni.JObject translationCapability,
    jni.JList<jni.JObject> list,
  ) {
    _id_dispatchCreateViewTranslationRequest(this, const jni.jvoidType(), [
      map.reference.pointer,
      is0.reference.pointer,
      translationCapability.reference.pointer,
      list.reference.pointer
    ]);
  }

  static final _id_onVirtualViewTranslationResponses = _class.instanceMethodId(
    r"onVirtualViewTranslationResponses",
    r"(Landroid/util/LongSparseArray;)V",
  );

  /// from: public void onVirtualViewTranslationResponses(android.util.LongSparseArray longSparseArray)
  void onVirtualViewTranslationResponses(
    jni.JObject longSparseArray,
  ) {
    _id_onVirtualViewTranslationResponses(
        this, const jni.jvoidType(), [longSparseArray.reference.pointer]);
  }

  static final _id_onOverScrolled = _class.instanceMethodId(
    r"onOverScrolled",
    r"(IIZZ)V",
  );

  /// from: protected void onOverScrolled(int i, int i1, boolean z, boolean z1)
  void onOverScrolled(
    int i,
    int i1,
    bool z,
    bool z1,
  ) {
    _id_onOverScrolled(this, const jni.jvoidType(),
        [jni.JValueInt(i), jni.JValueInt(i1), z ? 1 : 0, z1 ? 1 : 0]);
  }

  static final _id_onWindowVisibilityChanged = _class.instanceMethodId(
    r"onWindowVisibilityChanged",
    r"(I)V",
  );

  /// from: protected void onWindowVisibilityChanged(int i)
  void onWindowVisibilityChanged(
    int i,
  ) {
    _id_onWindowVisibilityChanged(
        this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_onDraw = _class.instanceMethodId(
    r"onDraw",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(
    jni.JObject canvas,
  ) {
    _id_onDraw(this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_performLongClick = _class.instanceMethodId(
    r"performLongClick",
    r"()Z",
  );

  /// from: public boolean performLongClick()
  bool performLongClick() {
    return _id_performLongClick(this, const jni.jbooleanType(), []);
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r"onConfigurationChanged",
    r"(Landroid/content/res/Configuration;)V",
  );

  /// from: protected void onConfigurationChanged(android.content.res.Configuration configuration)
  void onConfigurationChanged(
    jni.JObject configuration,
  ) {
    _id_onConfigurationChanged(
        this, const jni.jvoidType(), [configuration.reference.pointer]);
  }

  static final _id_onCreateInputConnection = _class.instanceMethodId(
    r"onCreateInputConnection",
    r"(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;",
  );

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo editorInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateInputConnection(
    jni.JObject editorInfo,
  ) {
    return _id_onCreateInputConnection(
        this, const jni.JObjectType(), [editorInfo.reference.pointer]);
  }

  static final _id_onDragEvent = _class.instanceMethodId(
    r"onDragEvent",
    r"(Landroid/view/DragEvent;)Z",
  );

  /// from: public boolean onDragEvent(android.view.DragEvent dragEvent)
  bool onDragEvent(
    jni.JObject dragEvent,
  ) {
    return _id_onDragEvent(
        this, const jni.jbooleanType(), [dragEvent.reference.pointer]);
  }

  static final _id_onVisibilityChanged = _class.instanceMethodId(
    r"onVisibilityChanged",
    r"(Landroid/view/View;I)V",
  );

  /// from: protected void onVisibilityChanged(android.view.View view, int i)
  void onVisibilityChanged(
    View view,
    int i,
  ) {
    _id_onVisibilityChanged(this, const jni.jvoidType(),
        [view.reference.pointer, jni.JValueInt(i)]);
  }

  static final _id_onWindowFocusChanged = _class.instanceMethodId(
    r"onWindowFocusChanged",
    r"(Z)V",
  );

  /// from: public void onWindowFocusChanged(boolean z)
  void onWindowFocusChanged(
    bool z,
  ) {
    _id_onWindowFocusChanged(this, const jni.jvoidType(), [z ? 1 : 0]);
  }

  static final _id_onFocusChanged = _class.instanceMethodId(
    r"onFocusChanged",
    r"(ZILandroid/graphics/Rect;)V",
  );

  /// from: protected void onFocusChanged(boolean z, int i, android.graphics.Rect rect)
  void onFocusChanged(
    bool z,
    int i,
    jni.JObject rect,
  ) {
    _id_onFocusChanged(this, const jni.jvoidType(),
        [z ? 1 : 0, jni.JValueInt(i), rect.reference.pointer]);
  }

  static final _id_onSizeChanged = _class.instanceMethodId(
    r"onSizeChanged",
    r"(IIII)V",
  );

  /// from: protected void onSizeChanged(int i, int i1, int i2, int i3)
  void onSizeChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_onSizeChanged(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_onScrollChanged = _class.instanceMethodId(
    r"onScrollChanged",
    r"(IIII)V",
  );

  /// from: protected void onScrollChanged(int i, int i1, int i2, int i3)
  void onScrollChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _id_onScrollChanged(this, const jni.jvoidType(), [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]);
  }

  static final _id_dispatchKeyEvent = _class.instanceMethodId(
    r"dispatchKeyEvent",
    r"(Landroid/view/KeyEvent;)Z",
  );

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyEvent(
    jni.JObject keyEvent,
  ) {
    return _id_dispatchKeyEvent(
        this, const jni.jbooleanType(), [keyEvent.reference.pointer]);
  }

  static final _id_requestFocus = _class.instanceMethodId(
    r"requestFocus",
    r"(ILandroid/graphics/Rect;)Z",
  );

  /// from: public boolean requestFocus(int i, android.graphics.Rect rect)
  bool requestFocus(
    int i,
    jni.JObject rect,
  ) {
    return _id_requestFocus(this, const jni.jbooleanType(),
        [jni.JValueInt(i), rect.reference.pointer]);
  }

  static final _id_onMeasure = _class.instanceMethodId(
    r"onMeasure",
    r"(II)V",
  );

  /// from: protected void onMeasure(int i, int i1)
  void onMeasure(
    int i,
    int i1,
  ) {
    _id_onMeasure(
        this, const jni.jvoidType(), [jni.JValueInt(i), jni.JValueInt(i1)]);
  }

  static final _id_requestChildRectangleOnScreen = _class.instanceMethodId(
    r"requestChildRectangleOnScreen",
    r"(Landroid/view/View;Landroid/graphics/Rect;Z)Z",
  );

  /// from: public boolean requestChildRectangleOnScreen(android.view.View view, android.graphics.Rect rect, boolean z)
  bool requestChildRectangleOnScreen(
    View view,
    jni.JObject rect,
    bool z,
  ) {
    return _id_requestChildRectangleOnScreen(this, const jni.jbooleanType(),
        [view.reference.pointer, rect.reference.pointer, z ? 1 : 0]);
  }

  static final _id_setBackgroundColor = _class.instanceMethodId(
    r"setBackgroundColor",
    r"(I)V",
  );

  /// from: public void setBackgroundColor(int i)
  void setBackgroundColor(
    int i,
  ) {
    _id_setBackgroundColor(this, const jni.jvoidType(), [jni.JValueInt(i)]);
  }

  static final _id_setLayerType = _class.instanceMethodId(
    r"setLayerType",
    r"(ILandroid/graphics/Paint;)V",
  );

  /// from: public void setLayerType(int i, android.graphics.Paint paint)
  void setLayerType(
    int i,
    jni.JObject paint,
  ) {
    _id_setLayerType(this, const jni.jvoidType(),
        [jni.JValueInt(i), paint.reference.pointer]);
  }

  static final _id_dispatchDraw = _class.instanceMethodId(
    r"dispatchDraw",
    r"(Landroid/graphics/Canvas;)V",
  );

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(
    jni.JObject canvas,
  ) {
    _id_dispatchDraw(this, const jni.jvoidType(), [canvas.reference.pointer]);
  }

  static final _id_onStartTemporaryDetach = _class.instanceMethodId(
    r"onStartTemporaryDetach",
    r"()V",
  );

  /// from: public void onStartTemporaryDetach()
  void onStartTemporaryDetach() {
    _id_onStartTemporaryDetach(this, const jni.jvoidType(), []);
  }

  static final _id_onFinishTemporaryDetach = _class.instanceMethodId(
    r"onFinishTemporaryDetach",
    r"()V",
  );

  /// from: public void onFinishTemporaryDetach()
  void onFinishTemporaryDetach() {
    _id_onFinishTemporaryDetach(this, const jni.jvoidType(), []);
  }

  static final _id_getHandler = _class.instanceMethodId(
    r"getHandler",
    r"()Landroid/os/Handler;",
  );

  /// from: public android.os.Handler getHandler()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHandler() {
    return _id_getHandler(this, const jni.JObjectType(), []);
  }

  static final _id_findFocus = _class.instanceMethodId(
    r"findFocus",
    r"()Landroid/view/View;",
  );

  /// from: public android.view.View findFocus()
  /// The returned object must be released after use, by calling the [release] method.
  View findFocus() {
    return _id_findFocus(this, const $ViewType(), []);
  }

  static final _id_getCurrentWebViewPackage = _class.staticMethodId(
    r"getCurrentWebViewPackage",
    r"()Landroid/content/pm/PackageInfo;",
  );

  /// from: static public android.content.pm.PackageInfo getCurrentWebViewPackage()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getCurrentWebViewPackage() {
    return _id_getCurrentWebViewPackage(_class, const jni.JObjectType(), []);
  }

  static final _id_onCheckIsTextEditor = _class.instanceMethodId(
    r"onCheckIsTextEditor",
    r"()Z",
  );

  /// from: public boolean onCheckIsTextEditor()
  bool onCheckIsTextEditor() {
    return _id_onCheckIsTextEditor(this, const jni.jbooleanType(), []);
  }

  static final _id_onApplyWindowInsets = _class.instanceMethodId(
    r"onApplyWindowInsets",
    r"(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;",
  );

  /// from: public android.view.WindowInsets onApplyWindowInsets(android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onApplyWindowInsets(
    jni.JObject windowInsets,
  ) {
    return _id_onApplyWindowInsets(
        this, const jni.JObjectType(), [windowInsets.reference.pointer]);
  }
}

final class $WebViewType extends jni.JObjType<WebView> {
  const $WebViewType();

  @override
  String get signature => r"Landroid/webkit/WebView;";

  @override
  WebView fromReference(jni.JReference reference) =>
      WebView.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebViewType) && other is $WebViewType;
  }
}
