// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: io.flutter.plugin.platform.PlatformView
///
/// A handle to an Android view to be embedded in the Flutter hierarchy.
class PlatformView extends jni.JObject {
  @override
  late final jni.JObjType<PlatformView> $type = type;

  PlatformView.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"io/flutter/plugin/platform/PlatformView");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewType();
  static final _id_getView = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getView", r"()Landroid/view/View;");

  /// from: public abstract android.view.View getView()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the Android view to be embedded in the Flutter hierarchy.
  View getView() {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getView, jni.JniCallType.objectType, []).object);
  }

  static final _id_onFlutterViewAttached = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onFlutterViewAttached", r"(Landroid/view/View;)V");

  /// from: default public void onFlutterViewAttached(android.view.View flutterView)
  ///
  /// Called by the io.flutter.embedding.engine.FlutterEngine that owns this {@code
  /// PlatformView} when the Android View responsible for rendering a Flutter UI is
  /// associated with the io.flutter.embedding.engine.FlutterEngine.
  ///
  /// This means that our associated io.flutter.embedding.engine.FlutterEngine can now
  /// render a UI and interact with the user.
  ///
  /// Some platform views may have unusual dependencies on the View that renders Flutter
  /// UIs, such as unique keyboard interactions. That View is provided here for those
  /// purposes. Use of this View should be avoided if it is not absolutely necessary, because
  /// depending on this View will tend to make platform view code more brittle to future
  /// changes.
  void onFlutterViewAttached(
    View flutterView,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onFlutterViewAttached,
        jni.JniCallType.voidType,
        [flutterView.reference]).check();
  }

  static final _id_onFlutterViewDetached = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onFlutterViewDetached", r"()V");

  /// from: default public void onFlutterViewDetached()
  ///
  /// Called by the io.flutter.embedding.engine.FlutterEngine that owns this {@code
  /// PlatformView} when the Android View responsible for rendering a Flutter UI is detached
  /// and disassociated from the io.flutter.embedding.engine.FlutterEngine.
  ///
  /// This means that our associated io.flutter.embedding.engine.FlutterEngine no longer
  /// has a rendering surface, or a user interaction surface of any kind.
  ///
  /// This platform view must release any references related to the Android View that was
  /// provided in \#onFlutterViewAttached(View).
  void onFlutterViewDetached() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onFlutterViewDetached, jni.JniCallType.voidType, []).check();
  }

  static final _id_dispose =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"dispose", r"()V");

  /// from: public abstract void dispose()
  ///
  /// Dispose this platform view.
  ///
  /// The PlatformView object is unusable after this method is called.
  ///
  /// Plugins implementing PlatformView must clear all references to the View object and
  /// the PlatformView after this method is called. Failing to do so will result in a memory leak.
  ///
  /// References related to the Android View attached in \#onFlutterViewAttached(View) must be released in {@code dispose()} to avoid memory leaks.
  void dispose() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dispose, jni.JniCallType.voidType, []).check();
  }

  static final _id_onInputConnectionLocked = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onInputConnectionLocked", r"()V");

  /// from: default public void onInputConnectionLocked()
  ///
  /// Callback fired when the platform's input connection is locked, or should be used.
  ///
  /// This hook only exists for rare cases where the plugin relies on the state of the input
  /// connection. This probably doesn't need to be implemented.
  void onInputConnectionLocked() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onInputConnectionLocked, jni.JniCallType.voidType, []).check();
  }

  static final _id_onInputConnectionUnlocked = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onInputConnectionUnlocked", r"()V");

  /// from: default public void onInputConnectionUnlocked()
  ///
  /// Callback fired when the platform input connection has been unlocked.
  ///
  /// This hook only exists for rare cases where the plugin relies on the state of the input
  /// connection. This probably doesn't need to be implemented.
  void onInputConnectionUnlocked() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onInputConnectionUnlocked, jni.JniCallType.voidType, []).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"getView()Landroid/view/View;") {
        final $r = _$impls[$p]!.getView();
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d == r"onFlutterViewAttached(Landroid/view/View;)V") {
        _$impls[$p]!.onFlutterViewAttached(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onFlutterViewDetached()V") {
        _$impls[$p]!.onFlutterViewDetached();
        return jni.nullptr;
      }
      if ($d == r"dispose()V") {
        _$impls[$p]!.dispose();
        return jni.nullptr;
      }
      if ($d == r"onInputConnectionLocked()V") {
        _$impls[$p]!.onInputConnectionLocked();
        return jni.nullptr;
      }
      if ($d == r"onInputConnectionUnlocked()V") {
        _$impls[$p]!.onInputConnectionUnlocked();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformView.implement(
    $PlatformViewImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformView.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.plugin.platform.PlatformView",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $PlatformViewImpl {
  factory $PlatformViewImpl({
    required View Function() getView,
    required void Function(View flutterView) onFlutterViewAttached,
    required void Function() onFlutterViewDetached,
    required void Function() dispose,
    required void Function() onInputConnectionLocked,
    required void Function() onInputConnectionUnlocked,
  }) = _$PlatformViewImpl;

  View getView();
  void onFlutterViewAttached(View flutterView);
  void onFlutterViewDetached();
  void dispose();
  void onInputConnectionLocked();
  void onInputConnectionUnlocked();
}

class _$PlatformViewImpl implements $PlatformViewImpl {
  _$PlatformViewImpl({
    required View Function() getView,
    required void Function(View flutterView) onFlutterViewAttached,
    required void Function() onFlutterViewDetached,
    required void Function() dispose,
    required void Function() onInputConnectionLocked,
    required void Function() onInputConnectionUnlocked,
  })  : _getView = getView,
        _onFlutterViewAttached = onFlutterViewAttached,
        _onFlutterViewDetached = onFlutterViewDetached,
        _dispose = dispose,
        _onInputConnectionLocked = onInputConnectionLocked,
        _onInputConnectionUnlocked = onInputConnectionUnlocked;

  final View Function() _getView;
  final void Function(View flutterView) _onFlutterViewAttached;
  final void Function() _onFlutterViewDetached;
  final void Function() _dispose;
  final void Function() _onInputConnectionLocked;
  final void Function() _onInputConnectionUnlocked;

  View getView() {
    return _getView();
  }

  void onFlutterViewAttached(View flutterView) {
    return _onFlutterViewAttached(flutterView);
  }

  void onFlutterViewDetached() {
    return _onFlutterViewDetached();
  }

  void dispose() {
    return _dispose();
  }

  void onInputConnectionLocked() {
    return _onInputConnectionLocked();
  }

  void onInputConnectionUnlocked() {
    return _onInputConnectionUnlocked();
  }
}

final class $PlatformViewType extends jni.JObjType<PlatformView> {
  const $PlatformViewType();

  @override
  String get signature => r"Lio/flutter/plugin/platform/PlatformView;";

  @override
  PlatformView fromRef(jni.JObjectPtr ref) => PlatformView.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewType) &&
        other is $PlatformViewType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel
///
/// System channel that sends 2-way communication between Flutter and Android to facilitate embedding
/// of Android Views within a Flutter application.
///
/// Register a PlatformViewsHandler to implement the Android side of this channel.
class PlatformViewsChannel extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel> $type = type;

  PlatformViewsChannel.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannelType();
  static final _id_invokeViewFocused = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"invokeViewFocused", r"(I)V");

  /// from: public void invokeViewFocused(int viewId)
  void invokeViewFocused(
    int viewId,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_invokeViewFocused,
        jni.JniCallType.voidType,
        [jni.JValueInt(viewId)]).check();
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lio/flutter/embedding/engine/dart/DartExecutor;)V");

  /// from: public void <init>(io.flutter.embedding.engine.dart.DartExecutor dartExecutor)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructs a {@code PlatformViewsChannel} that connects Android to the Dart code running in
  /// {@code dartExecutor}.
  ///
  /// The given {@code dartExecutor} is permitted to be idle or executing code.
  ///
  /// See DartExecutor.
  factory PlatformViewsChannel(
    jni.JObject dartExecutor,
  ) {
    return PlatformViewsChannel.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [dartExecutor.reference]).object);
  }

  static final _id_setPlatformViewsHandler = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setPlatformViewsHandler",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewsHandler;)V");

  /// from: public void setPlatformViewsHandler(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewsHandler handler)
  ///
  /// Sets the PlatformViewsHandler which receives all events and requests that are parsed
  /// from the underlying platform views channel.
  void setPlatformViewsHandler(
    PlatformViewsChannel_PlatformViewsHandler handler,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setPlatformViewsHandler,
        jni.JniCallType.voidType,
        [handler.reference]).check();
  }
}

final class $PlatformViewsChannelType
    extends jni.JObjType<PlatformViewsChannel> {
  const $PlatformViewsChannelType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel;";

  @override
  PlatformViewsChannel fromRef(jni.JObjectPtr ref) =>
      PlatformViewsChannel.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsChannelType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewsChannelType) &&
        other is $PlatformViewsChannelType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewTouch
///
/// The state of a touch event in Flutter within a platform view.
class PlatformViewsChannel_PlatformViewTouch extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewTouch> $type = type;

  PlatformViewsChannel_PlatformViewTouch.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewTouchType();
  static final _id_viewId = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"viewId",
    r"I",
  );

  /// from: public final int viewId
  ///
  /// The ID of the platform view as seen by the Flutter side.
  int get viewId => jni.Jni.accessors
      .getField(reference, _id_viewId, jni.JniCallType.intType)
      .integer;

  static final _id_downTime = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"downTime",
    r"Ljava/lang/Number;",
  );

  /// from: public final java.lang.Number downTime
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The amount of time that the touch has been pressed.
  jni.JNumber get downTime => const jni.JNumberType().fromRef(jni.Jni.accessors
      .getField(reference, _id_downTime, jni.JniCallType.objectType)
      .object);

  static final _id_eventTime = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"eventTime",
    r"Ljava/lang/Number;",
  );

  /// from: public final java.lang.Number eventTime
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// TODO(mattcarroll): javadoc
  jni.JNumber get eventTime => const jni.JNumberType().fromRef(jni.Jni.accessors
      .getField(reference, _id_eventTime, jni.JniCallType.objectType)
      .object);

  static final _id_action = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"action",
    r"I",
  );

  /// from: public final int action
  int get action => jni.Jni.accessors
      .getField(reference, _id_action, jni.JniCallType.intType)
      .integer;

  static final _id_pointerCount = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"pointerCount",
    r"I",
  );

  /// from: public final int pointerCount
  ///
  /// The number of pointers (e.g, fingers) involved in the touch event.
  int get pointerCount => jni.Jni.accessors
      .getField(reference, _id_pointerCount, jni.JniCallType.intType)
      .integer;

  static final _id_rawPointerPropertiesList = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"rawPointerPropertiesList",
    r"Ljava/lang/Object;",
  );

  /// from: public final java.lang.Object rawPointerPropertiesList
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Properties for each pointer, encoded in a raw format.
  jni.JObject get rawPointerPropertiesList =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getField(reference, _id_rawPointerPropertiesList,
              jni.JniCallType.objectType)
          .object);

  static final _id_rawPointerCoords = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"rawPointerCoords",
    r"Ljava/lang/Object;",
  );

  /// from: public final java.lang.Object rawPointerCoords
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Coordinates for each pointer, encoded in a raw format.
  jni.JObject get rawPointerCoords =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getField(reference, _id_rawPointerCoords, jni.JniCallType.objectType)
          .object);

  static final _id_metaState = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"metaState",
    r"I",
  );

  /// from: public final int metaState
  ///
  /// TODO(mattcarroll): javadoc
  int get metaState => jni.Jni.accessors
      .getField(reference, _id_metaState, jni.JniCallType.intType)
      .integer;

  static final _id_buttonState = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"buttonState",
    r"I",
  );

  /// from: public final int buttonState
  ///
  /// TODO(mattcarroll): javadoc
  int get buttonState => jni.Jni.accessors
      .getField(reference, _id_buttonState, jni.JniCallType.intType)
      .integer;

  static final _id_xPrecision = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"xPrecision",
    r"F",
  );

  /// from: public final float xPrecision
  ///
  /// Coordinate precision along the x-axis.
  double get xPrecision => jni.Jni.accessors
      .getField(reference, _id_xPrecision, jni.JniCallType.floatType)
      .float;

  static final _id_yPrecision = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"yPrecision",
    r"F",
  );

  /// from: public final float yPrecision
  ///
  /// Coordinate precision along the y-axis.
  double get yPrecision => jni.Jni.accessors
      .getField(reference, _id_yPrecision, jni.JniCallType.floatType)
      .float;

  static final _id_deviceId = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"deviceId",
    r"I",
  );

  /// from: public final int deviceId
  ///
  /// TODO(mattcarroll): javadoc
  int get deviceId => jni.Jni.accessors
      .getField(reference, _id_deviceId, jni.JniCallType.intType)
      .integer;

  static final _id_edgeFlags = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"edgeFlags",
    r"I",
  );

  /// from: public final int edgeFlags
  ///
  /// TODO(mattcarroll): javadoc
  int get edgeFlags => jni.Jni.accessors
      .getField(reference, _id_edgeFlags, jni.JniCallType.intType)
      .integer;

  static final _id_source = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"source",
    r"I",
  );

  /// from: public final int source
  ///
  /// TODO(mattcarroll): javadoc
  int get source => jni.Jni.accessors
      .getField(reference, _id_source, jni.JniCallType.intType)
      .integer;

  static final _id_flags = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"flags",
    r"I",
  );

  /// from: public final int flags
  ///
  /// TODO(mattcarroll): javadoc
  int get flags => jni.Jni.accessors
      .getField(reference, _id_flags, jni.JniCallType.intType)
      .integer;

  static final _id_motionEventId = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"motionEventId",
    r"J",
  );

  /// from: public final long motionEventId
  ///
  /// TODO(iskakaushik): javadoc
  int get motionEventId => jni.Jni.accessors
      .getField(reference, _id_motionEventId, jni.JniCallType.longType)
      .long;

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(ILjava/lang/Number;Ljava/lang/Number;IILjava/lang/Object;Ljava/lang/Object;IIFFIIIIJ)V");

  /// from: public void <init>(int viewId, java.lang.Number downTime, java.lang.Number eventTime, int action, int pointerCount, java.lang.Object rawPointerPropertiesList, java.lang.Object rawPointerCoords, int metaState, int buttonState, float xPrecision, float yPrecision, int deviceId, int edgeFlags, int source, int flags, long motionEventId)
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsChannel_PlatformViewTouch(
    int viewId,
    jni.JNumber downTime,
    jni.JNumber eventTime,
    int action,
    int pointerCount,
    jni.JObject rawPointerPropertiesList,
    jni.JObject rawPointerCoords,
    int metaState,
    int buttonState,
    double xPrecision,
    double yPrecision,
    int deviceId,
    int edgeFlags,
    int source,
    int flags,
    int motionEventId,
  ) {
    return PlatformViewsChannel_PlatformViewTouch.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      jni.JValueInt(viewId),
      downTime.reference,
      eventTime.reference,
      jni.JValueInt(action),
      jni.JValueInt(pointerCount),
      rawPointerPropertiesList.reference,
      rawPointerCoords.reference,
      jni.JValueInt(metaState),
      jni.JValueInt(buttonState),
      jni.JValueFloat(xPrecision),
      jni.JValueFloat(yPrecision),
      jni.JValueInt(deviceId),
      jni.JValueInt(edgeFlags),
      jni.JValueInt(source),
      jni.JValueInt(flags),
      motionEventId
    ]).object);
  }
}

final class $PlatformViewsChannel_PlatformViewTouchType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewTouch> {
  const $PlatformViewsChannel_PlatformViewTouchType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;";

  @override
  PlatformViewsChannel_PlatformViewTouch fromRef(jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewTouch.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsChannel_PlatformViewTouchType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewsChannel_PlatformViewTouchType) &&
        other is $PlatformViewsChannel_PlatformViewTouchType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized
///
/// Allows to notify when a platform view buffer has been resized.
class PlatformViewsChannel_PlatformViewBufferResized extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewBufferResized>
      $type = type;

  PlatformViewsChannel_PlatformViewBufferResized.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewBufferResizedType();
  static final _id_run = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"run",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize;)V");

  /// from: public abstract void run(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewBufferSize bufferSize)
  void run(
    PlatformViewsChannel_PlatformViewBufferSize bufferSize,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_run,
        jni.JniCallType.voidType, [bufferSize.reference]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewsChannel_PlatformViewBufferResizedImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"run(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize;)V") {
        _$impls[$p]!.run(
          $a[0].castTo(const $PlatformViewsChannel_PlatformViewBufferSizeType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformViewsChannel_PlatformViewBufferResized.implement(
    $PlatformViewsChannel_PlatformViewBufferResizedImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformViewsChannel_PlatformViewBufferResized.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $PlatformViewsChannel_PlatformViewBufferResizedImpl {
  factory $PlatformViewsChannel_PlatformViewBufferResizedImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewBufferSize bufferSize)
        run,
  }) = _$PlatformViewsChannel_PlatformViewBufferResizedImpl;

  void run(PlatformViewsChannel_PlatformViewBufferSize bufferSize);
}

class _$PlatformViewsChannel_PlatformViewBufferResizedImpl
    implements $PlatformViewsChannel_PlatformViewBufferResizedImpl {
  _$PlatformViewsChannel_PlatformViewBufferResizedImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewBufferSize bufferSize)
        run,
  }) : _run = run;

  final void Function(PlatformViewsChannel_PlatformViewBufferSize bufferSize)
      _run;

  void run(PlatformViewsChannel_PlatformViewBufferSize bufferSize) {
    return _run(bufferSize);
  }
}

final class $PlatformViewsChannel_PlatformViewBufferResizedType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewBufferResized> {
  const $PlatformViewsChannel_PlatformViewBufferResizedType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized;";

  @override
  PlatformViewsChannel_PlatformViewBufferResized fromRef(jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewBufferResized.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewBufferResizedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewBufferResizedType) &&
        other is $PlatformViewsChannel_PlatformViewBufferResizedType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize
///
/// The platform view buffer size.
class PlatformViewsChannel_PlatformViewBufferSize extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewBufferSize> $type =
      type;

  PlatformViewsChannel_PlatformViewBufferSize.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewBufferSizeType();
  static final _id_width = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"width",
    r"I",
  );

  /// from: public final int width
  ///
  /// The width of the screen buffer.
  int get width => jni.Jni.accessors
      .getField(reference, _id_width, jni.JniCallType.intType)
      .integer;

  static final _id_height = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"height",
    r"I",
  );

  /// from: public final int height
  ///
  /// The height of the screen buffer.
  int get height => jni.Jni.accessors
      .getField(reference, _id_height, jni.JniCallType.intType)
      .integer;

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"(II)V");

  /// from: public void <init>(int width, int height)
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsChannel_PlatformViewBufferSize(
    int width,
    int height,
  ) {
    return PlatformViewsChannel_PlatformViewBufferSize.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0,
            [jni.JValueInt(width), jni.JValueInt(height)]).object);
  }
}

final class $PlatformViewsChannel_PlatformViewBufferSizeType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewBufferSize> {
  const $PlatformViewsChannel_PlatformViewBufferSizeType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferSize;";

  @override
  PlatformViewsChannel_PlatformViewBufferSize fromRef(jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewBufferSize.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewBufferSizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewBufferSizeType) &&
        other is $PlatformViewsChannel_PlatformViewBufferSizeType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewResizeRequest
///
/// Request sent from Flutter to resize a platform view.
class PlatformViewsChannel_PlatformViewResizeRequest extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewResizeRequest>
      $type = type;

  PlatformViewsChannel_PlatformViewResizeRequest.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewResizeRequestType();
  static final _id_viewId = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"viewId",
    r"I",
  );

  /// from: public final int viewId
  ///
  /// The ID of the platform view as seen by the Flutter side.
  int get viewId => jni.Jni.accessors
      .getField(reference, _id_viewId, jni.JniCallType.intType)
      .integer;

  static final _id_newLogicalWidth = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"newLogicalWidth",
    r"D",
  );

  /// from: public final double newLogicalWidth
  ///
  /// The new density independent width to display the platform view.
  double get newLogicalWidth => jni.Jni.accessors
      .getField(reference, _id_newLogicalWidth, jni.JniCallType.doubleType)
      .doubleFloat;

  static final _id_newLogicalHeight = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"newLogicalHeight",
    r"D",
  );

  /// from: public final double newLogicalHeight
  ///
  /// The new density independent height to display the platform view.
  double get newLogicalHeight => jni.Jni.accessors
      .getField(reference, _id_newLogicalHeight, jni.JniCallType.doubleType)
      .doubleFloat;

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"(IDD)V");

  /// from: public void <init>(int viewId, double newLogicalWidth, double newLogicalHeight)
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsChannel_PlatformViewResizeRequest(
    int viewId,
    double newLogicalWidth,
    double newLogicalHeight,
  ) {
    return PlatformViewsChannel_PlatformViewResizeRequest.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0,
            [jni.JValueInt(viewId), newLogicalWidth, newLogicalHeight]).object);
  }
}

final class $PlatformViewsChannel_PlatformViewResizeRequestType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewResizeRequest> {
  const $PlatformViewsChannel_PlatformViewResizeRequestType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest;";

  @override
  PlatformViewsChannel_PlatformViewResizeRequest fromRef(jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewResizeRequest.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewResizeRequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewResizeRequestType) &&
        other is $PlatformViewsChannel_PlatformViewResizeRequestType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest
///
/// Request sent from Flutter to create a new platform view.
class PlatformViewsChannel_PlatformViewCreationRequest extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewCreationRequest>
      $type = type;

  PlatformViewsChannel_PlatformViewCreationRequest.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewCreationRequestType();
  static final _id_viewId = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"viewId",
    r"I",
  );

  /// from: public final int viewId
  ///
  /// The ID of the platform view as seen by the Flutter side.
  int get viewId => jni.Jni.accessors
      .getField(reference, _id_viewId, jni.JniCallType.intType)
      .integer;

  static final _id_viewType = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"viewType",
    r"Ljava/lang/String;",
  );

  /// from: public final java.lang.String viewType
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The type of Android {@code View} to create for this platform view.
  jni.JString get viewType => const jni.JStringType().fromRef(jni.Jni.accessors
      .getField(reference, _id_viewType, jni.JniCallType.objectType)
      .object);

  static final _id_logicalWidth = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"logicalWidth",
    r"D",
  );

  /// from: public final double logicalWidth
  ///
  /// The density independent width to display the platform view.
  double get logicalWidth => jni.Jni.accessors
      .getField(reference, _id_logicalWidth, jni.JniCallType.doubleType)
      .doubleFloat;

  static final _id_logicalHeight = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"logicalHeight",
    r"D",
  );

  /// from: public final double logicalHeight
  ///
  /// The density independent height to display the platform view.
  double get logicalHeight => jni.Jni.accessors
      .getField(reference, _id_logicalHeight, jni.JniCallType.doubleType)
      .doubleFloat;

  static final _id_logicalTop = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"logicalTop",
    r"D",
  );

  /// from: public final double logicalTop
  ///
  /// The density independent top position to display the platform view.
  double get logicalTop => jni.Jni.accessors
      .getField(reference, _id_logicalTop, jni.JniCallType.doubleType)
      .doubleFloat;

  static final _id_logicalLeft = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"logicalLeft",
    r"D",
  );

  /// from: public final double logicalLeft
  ///
  /// The density independent left position to display the platform view.
  double get logicalLeft => jni.Jni.accessors
      .getField(reference, _id_logicalLeft, jni.JniCallType.doubleType)
      .doubleFloat;

  static final _id_direction = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"direction",
    r"I",
  );

  /// from: public final int direction
  ///
  /// The layout direction of the new platform view.
  ///
  /// See android.view.View\#LAYOUT_DIRECTION_LTR and android.view.View\#LAYOUT_DIRECTION_RTL
  int get direction => jni.Jni.accessors
      .getField(reference, _id_direction, jni.JniCallType.intType)
      .integer;

  static final _id_displayMode = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"displayMode",
    r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;",
  );

  /// from: public final io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode displayMode
  /// The returned object must be released after use, by calling the [release] method.
  PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
      get displayMode =>
          const $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType()
              .fromRef(jni.Jni.accessors
                  .getField(
                      reference, _id_displayMode, jni.JniCallType.objectType)
                  .object);

  static final _id_params = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"params",
    r"Ljava/nio/ByteBuffer;",
  );

  /// from: public final java.nio.ByteBuffer params
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Custom parameters that are unique to the desired platform view.
  jni.JByteBuffer get params =>
      const jni.JByteBufferType().fromRef(jni.Jni.accessors
          .getField(reference, _id_params, jni.JniCallType.objectType)
          .object);

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(ILjava/lang/String;DDDDILjava/nio/ByteBuffer;)V");

  /// from: public void <init>(int viewId, java.lang.String viewType, double logicalTop, double logicalLeft, double logicalWidth, double logicalHeight, int direction, java.nio.ByteBuffer params)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a request to construct a platform view.
  factory PlatformViewsChannel_PlatformViewCreationRequest(
    int viewId,
    jni.JString viewType,
    double logicalTop,
    double logicalLeft,
    double logicalWidth,
    double logicalHeight,
    int direction,
    jni.JByteBuffer params,
  ) {
    return PlatformViewsChannel_PlatformViewCreationRequest.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      jni.JValueInt(viewId),
      viewType.reference,
      logicalTop,
      logicalLeft,
      logicalWidth,
      logicalHeight,
      jni.JValueInt(direction),
      params.reference
    ]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(ILjava/lang/String;DDDDILio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;Ljava/nio/ByteBuffer;)V");

  /// from: public void <init>(int viewId, java.lang.String viewType, double logicalTop, double logicalLeft, double logicalWidth, double logicalHeight, int direction, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode displayMode, java.nio.ByteBuffer params)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a request to construct a platform view with the given display mode.
  factory PlatformViewsChannel_PlatformViewCreationRequest.new1(
    int viewId,
    jni.JString viewType,
    double logicalTop,
    double logicalLeft,
    double logicalWidth,
    double logicalHeight,
    int direction,
    PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
        displayMode,
    jni.JByteBuffer params,
  ) {
    return PlatformViewsChannel_PlatformViewCreationRequest.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new1, [
      jni.JValueInt(viewId),
      viewType.reference,
      logicalTop,
      logicalLeft,
      logicalWidth,
      logicalHeight,
      jni.JValueInt(direction),
      displayMode.reference,
      params.reference
    ]).object);
  }
}

final class $PlatformViewsChannel_PlatformViewCreationRequestType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewCreationRequest> {
  const $PlatformViewsChannel_PlatformViewCreationRequestType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;";

  @override
  PlatformViewsChannel_PlatformViewCreationRequest fromRef(
          jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewCreationRequest.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewCreationRequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewCreationRequestType) &&
        other is $PlatformViewsChannel_PlatformViewCreationRequestType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode
///
/// Platform view display modes that can be requested at creation time.
class PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
    extends jni.JObject {
  @override
  late final jni.JObjType<
          PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode>
      $type = type;

  PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode");

  /// The type which includes information such as the signature of this class.
  static const type =
      $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType();
  static final _id_values = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"values",
      r"()[Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;");

  /// from: static public io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<
          PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode>
      values() {
    return const jni.JArrayType(
            $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType())
        .fromRef(jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
            _id_values, jni.JniCallType.objectType, []).object);
  }

  static final _id_valueOf = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"valueOf",
      r"(Ljava/lang/String;)Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;");

  /// from: static public io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest.RequestedDisplayMode valueOf(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  static PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
      valueOf(
    jni.JString name,
  ) {
    return const $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType()
        .fromRef(jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
            _id_valueOf, jni.JniCallType.objectType, [name.reference]).object);
  }
}

final class $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType
    extends jni.JObjType<
        PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode> {
  const $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode;";

  @override
  PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode fromRef(
          jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayMode
          .fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType)
          .hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType) &&
        other
            is $PlatformViewsChannel_PlatformViewCreationRequest_RequestedDisplayModeType;
  }
}

/// from: io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler
///
/// Handler that receives platform view messages sent from Flutter to Android through a given
/// PlatformViewsChannel.
///
/// To register a {@code PlatformViewsHandler} with a PlatformViewsChannel, see PlatformViewsChannel\#setPlatformViewsHandler(PlatformViewsHandler).
class PlatformViewsChannel_PlatformViewsHandler extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsChannel_PlatformViewsHandler> $type =
      type;

  PlatformViewsChannel_PlatformViewsHandler.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewsHandler");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsChannel_PlatformViewsHandlerType();

  /// from: static public final long NON_TEXTURE_FALLBACK
  static const NON_TEXTURE_FALLBACK = -2;

  static final _id_createForPlatformViewLayer = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createForPlatformViewLayer",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)V");

  /// from: public abstract void createForPlatformViewLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request)
  ///
  /// The Flutter application would like to display a new Android {@code View}, i.e., platform
  /// view.
  ///
  /// The Android View is added to the view hierarchy. This view is rendered in the Flutter
  /// framework by a PlatformViewLayer.
  ///@param request The metadata sent from the framework.
  void createForPlatformViewLayer(
    PlatformViewsChannel_PlatformViewCreationRequest request,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createForPlatformViewLayer,
        jni.JniCallType.voidType,
        [request.reference]).check();
  }

  static final _id_createForTextureLayer = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createForTextureLayer",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)J");

  /// from: public abstract long createForTextureLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request)
  ///
  /// The Flutter application would like to display a new Android {@code View}, i.e., platform
  /// view.
  ///
  /// The Android View is added to the view hierarchy. This view is rendered in the Flutter
  /// framework by a TextureLayer.
  ///@param request The metadata sent from the framework.
  ///@return The texture ID.
  int createForTextureLayer(
    PlatformViewsChannel_PlatformViewCreationRequest request,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createForTextureLayer,
        jni.JniCallType.longType,
        [request.reference]).long;
  }

  static final _id_dispose =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"dispose", r"(I)V");

  /// from: public abstract void dispose(int viewId)
  ///
  /// The Flutter application would like to dispose of an existing Android {@code View}.
  void dispose(
    int viewId,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_dispose,
        jni.JniCallType.voidType, [jni.JValueInt(viewId)]).check();
  }

  static final _id_resize = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"resize",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest;Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized;)V");

  /// from: public abstract void resize(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewResizeRequest request, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewBufferResized onComplete)
  ///
  /// The Flutter application would like to resize an existing Android {@code View}.
  ///@param request The request to resize the platform view.
  ///@param onComplete Once the resize is completed, this is the handler to notify the size of the
  ///     platform view buffer.
  void resize(
    PlatformViewsChannel_PlatformViewResizeRequest request,
    PlatformViewsChannel_PlatformViewBufferResized onComplete,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resize,
        jni.JniCallType.voidType,
        [request.reference, onComplete.reference]).check();
  }

  static final _id_offset =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"offset", r"(IDD)V");

  /// from: public abstract void offset(int viewId, double top, double left)
  ///
  /// The Flutter application would like to change the offset of an existing Android {@code View}.
  void offset(
    int viewId,
    double top,
    double left,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_offset,
        jni.JniCallType.voidType, [jni.JValueInt(viewId), top, left]).check();
  }

  static final _id_onTouch = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onTouch",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;)V");

  /// from: public abstract void onTouch(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewTouch touch)
  ///
  /// The user touched a platform view within Flutter.
  ///
  /// Touch data is reported in {@code touch}.
  void onTouch(
    PlatformViewsChannel_PlatformViewTouch touch,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onTouch,
        jni.JniCallType.voidType, [touch.reference]).check();
  }

  static final _id_setDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setDirection", r"(II)V");

  /// from: public abstract void setDirection(int viewId, int direction)
  ///
  /// The Flutter application would like to change the layout direction of an existing Android
  /// {@code View}, i.e., platform view.
  void setDirection(
    int viewId,
    int direction,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDirection,
        jni.JniCallType.voidType,
        [jni.JValueInt(viewId), jni.JValueInt(direction)]).check();
  }

  static final _id_clearFocus =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"clearFocus", r"(I)V");

  /// from: public abstract void clearFocus(int viewId)
  ///
  /// Clears the focus from the platform view with a give id if it is currently focused.
  void clearFocus(
    int viewId,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_clearFocus,
        jni.JniCallType.voidType, [jni.JValueInt(viewId)]).check();
  }

  static final _id_synchronizeToNativeViewHierarchy = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"synchronizeToNativeViewHierarchy", r"(Z)V");

  /// from: public abstract void synchronizeToNativeViewHierarchy(boolean yes)
  ///
  /// Whether the render surface of {@code FlutterView} should be converted to a {@code
  /// FlutterImageView} when a {@code PlatformView} is added.
  ///
  /// This is done to syncronize the rendering of the PlatformView and the FlutterView. Defaults
  /// to true.
  void synchronizeToNativeViewHierarchy(
    bool yes,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_synchronizeToNativeViewHierarchy,
        jni.JniCallType.voidType,
        [yes ? 1 : 0]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewsChannel_PlatformViewsHandlerImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"createForPlatformViewLayer(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)V") {
        _$impls[$p]!.createForPlatformViewLayer(
          $a[0].castTo(
              const $PlatformViewsChannel_PlatformViewCreationRequestType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"createForTextureLayer(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)J") {
        final $r = _$impls[$p]!.createForTextureLayer(
          $a[0].castTo(
              const $PlatformViewsChannel_PlatformViewCreationRequestType(),
              releaseOriginal: true),
        );
        return jni.JLong($r).toPointer();
      }
      if ($d == r"dispose(I)V") {
        _$impls[$p]!.dispose(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"resize(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewResizeRequest;Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewBufferResized;)V") {
        _$impls[$p]!.resize(
          $a[0].castTo(
              const $PlatformViewsChannel_PlatformViewResizeRequestType(),
              releaseOriginal: true),
          $a[1].castTo(
              const $PlatformViewsChannel_PlatformViewBufferResizedType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"offset(IDD)V") {
        _$impls[$p]!.offset(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"onTouch(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;)V") {
        _$impls[$p]!.onTouch(
          $a[0].castTo(const $PlatformViewsChannel_PlatformViewTouchType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"setDirection(II)V") {
        _$impls[$p]!.setDirection(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"clearFocus(I)V") {
        _$impls[$p]!.clearFocus(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"synchronizeToNativeViewHierarchy(Z)V") {
        _$impls[$p]!.synchronizeToNativeViewHierarchy(
          $a[0]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformViewsChannel_PlatformViewsHandler.implement(
    $PlatformViewsChannel_PlatformViewsHandlerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformViewsChannel_PlatformViewsHandler.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $PlatformViewsChannel_PlatformViewsHandlerImpl {
  factory $PlatformViewsChannel_PlatformViewsHandlerImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForPlatformViewLayer,
    required int Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForTextureLayer,
    required void Function(int viewId) dispose,
    required void Function(
            PlatformViewsChannel_PlatformViewResizeRequest request,
            PlatformViewsChannel_PlatformViewBufferResized onComplete)
        resize,
    required void Function(int viewId, double top, double left) offset,
    required void Function(PlatformViewsChannel_PlatformViewTouch touch)
        onTouch,
    required void Function(int viewId, int direction) setDirection,
    required void Function(int viewId) clearFocus,
    required void Function(bool yes) synchronizeToNativeViewHierarchy,
  }) = _$PlatformViewsChannel_PlatformViewsHandlerImpl;

  void createForPlatformViewLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request);
  int createForTextureLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request);
  void dispose(int viewId);
  void resize(PlatformViewsChannel_PlatformViewResizeRequest request,
      PlatformViewsChannel_PlatformViewBufferResized onComplete);
  void offset(int viewId, double top, double left);
  void onTouch(PlatformViewsChannel_PlatformViewTouch touch);
  void setDirection(int viewId, int direction);
  void clearFocus(int viewId);
  void synchronizeToNativeViewHierarchy(bool yes);
}

class _$PlatformViewsChannel_PlatformViewsHandlerImpl
    implements $PlatformViewsChannel_PlatformViewsHandlerImpl {
  _$PlatformViewsChannel_PlatformViewsHandlerImpl({
    required void Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForPlatformViewLayer,
    required int Function(
            PlatformViewsChannel_PlatformViewCreationRequest request)
        createForTextureLayer,
    required void Function(int viewId) dispose,
    required void Function(
            PlatformViewsChannel_PlatformViewResizeRequest request,
            PlatformViewsChannel_PlatformViewBufferResized onComplete)
        resize,
    required void Function(int viewId, double top, double left) offset,
    required void Function(PlatformViewsChannel_PlatformViewTouch touch)
        onTouch,
    required void Function(int viewId, int direction) setDirection,
    required void Function(int viewId) clearFocus,
    required void Function(bool yes) synchronizeToNativeViewHierarchy,
  })  : _createForPlatformViewLayer = createForPlatformViewLayer,
        _createForTextureLayer = createForTextureLayer,
        _dispose = dispose,
        _resize = resize,
        _offset = offset,
        _onTouch = onTouch,
        _setDirection = setDirection,
        _clearFocus = clearFocus,
        _synchronizeToNativeViewHierarchy = synchronizeToNativeViewHierarchy;

  final void Function(PlatformViewsChannel_PlatformViewCreationRequest request)
      _createForPlatformViewLayer;
  final int Function(PlatformViewsChannel_PlatformViewCreationRequest request)
      _createForTextureLayer;
  final void Function(int viewId) _dispose;
  final void Function(PlatformViewsChannel_PlatformViewResizeRequest request,
      PlatformViewsChannel_PlatformViewBufferResized onComplete) _resize;
  final void Function(int viewId, double top, double left) _offset;
  final void Function(PlatformViewsChannel_PlatformViewTouch touch) _onTouch;
  final void Function(int viewId, int direction) _setDirection;
  final void Function(int viewId) _clearFocus;
  final void Function(bool yes) _synchronizeToNativeViewHierarchy;

  void createForPlatformViewLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request) {
    return _createForPlatformViewLayer(request);
  }

  int createForTextureLayer(
      PlatformViewsChannel_PlatformViewCreationRequest request) {
    return _createForTextureLayer(request);
  }

  void dispose(int viewId) {
    return _dispose(viewId);
  }

  void resize(PlatformViewsChannel_PlatformViewResizeRequest request,
      PlatformViewsChannel_PlatformViewBufferResized onComplete) {
    return _resize(request, onComplete);
  }

  void offset(int viewId, double top, double left) {
    return _offset(viewId, top, left);
  }

  void onTouch(PlatformViewsChannel_PlatformViewTouch touch) {
    return _onTouch(touch);
  }

  void setDirection(int viewId, int direction) {
    return _setDirection(viewId, direction);
  }

  void clearFocus(int viewId) {
    return _clearFocus(viewId);
  }

  void synchronizeToNativeViewHierarchy(bool yes) {
    return _synchronizeToNativeViewHierarchy(yes);
  }
}

final class $PlatformViewsChannel_PlatformViewsHandlerType
    extends jni.JObjType<PlatformViewsChannel_PlatformViewsHandler> {
  const $PlatformViewsChannel_PlatformViewsHandlerType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewsHandler;";

  @override
  PlatformViewsChannel_PlatformViewsHandler fromRef(jni.JObjectPtr ref) =>
      PlatformViewsChannel_PlatformViewsHandler.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsChannel_PlatformViewsHandlerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PlatformViewsChannel_PlatformViewsHandlerType) &&
        other is $PlatformViewsChannel_PlatformViewsHandlerType;
  }
}

/// from: io.flutter.embedding.engine.plugins.FlutterPlugin
///
/// Interface to be implemented by all Flutter plugins.
///
/// A Flutter plugin allows Flutter developers to interact with a host platform, e.g., Android and
/// iOS, via Dart code. It includes platform code, as well as Dart code. A plugin author is
/// responsible for setting up an appropriate io.flutter.plugin.common.MethodChannel to
/// communicate between platform code and Dart code.
///
/// A Flutter plugin has a lifecycle. First, a developer must add a {@code FlutterPlugin} to an
/// instance of io.flutter.embedding.engine.FlutterEngine. To do this, obtain a PluginRegistry with FlutterEngine\#getPlugins(), then call PluginRegistry\#add(FlutterPlugin), passing the instance of the Flutter plugin. During the call
/// to PluginRegistry\#add(FlutterPlugin), the io.flutter.embedding.engine.FlutterEngine will invoke \#onAttachedToEngine(FlutterPluginBinding) on the given {@code FlutterPlugin}. If the {@code
/// FlutterPlugin} is removed from the io.flutter.embedding.engine.FlutterEngine via PluginRegistry\#remove(Class), or if the io.flutter.embedding.engine.FlutterEngine is
/// destroyed, the FlutterEngine will invoke FlutterPlugin\#onDetachedFromEngine(FlutterPluginBinding) on the given {@code FlutterPlugin}.
///
/// Once a {@code FlutterPlugin} is attached to a io.flutter.embedding.engine.FlutterEngine, the plugin's code is permitted to access and invoke
/// methods on resources within the FlutterPluginBinding that the io.flutter.embedding.engine.FlutterEngine gave to the {@code FlutterPlugin} in \#onAttachedToEngine(FlutterPluginBinding). This includes, for example, the application Context for the running app.
///
/// The FlutterPluginBinding provided in \#onAttachedToEngine(FlutterPluginBinding)
/// is no longer valid after the execution of \#onDetachedFromEngine(FlutterPluginBinding). Do
/// not access any properties of the FlutterPluginBinding after the completion of \#onDetachedFromEngine(FlutterPluginBinding).
///
/// To register a io.flutter.plugin.common.MethodChannel, obtain a BinaryMessenger
/// via the FlutterPluginBinding.
///
/// An Android Flutter plugin may require access to app resources or other artifacts that can only
/// be retrieved through a Context. Developers can access the application context via FlutterPluginBinding\#getApplicationContext().
///
/// Some plugins may require access to the {@code Activity} that is displaying a Flutter
/// experience, or may need to react to {@code Activity} lifecycle events, e.g., {@code onCreate()},
/// {@code onStart()}, {@code onResume()}, {@code onPause()}, {@code onStop()}, {@code onDestroy()}.
/// Any such plugin should implement io.flutter.embedding.engine.plugins.activity.ActivityAware in addition to implementing {@code
/// FlutterPlugin}. {@code ActivityAware} provides callback hooks that expose access to an associated
/// {@code Activity} and its {@code Lifecycle}. All plugins must respect the possibility that a
/// Flutter experience may never be associated with an {@code Activity}, e.g., when Flutter is used
/// for background behavior. Additionally, all plugins must respect that a {@code Activity}s may come
/// and go over time, thus requiring plugins to cleanup resources and recreate those resources as the
/// {@code Activity} comes and goes.
class FlutterPlugin extends jni.JObject {
  @override
  late final jni.JObjType<FlutterPlugin> $type = type;

  FlutterPlugin.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"io/flutter/embedding/engine/plugins/FlutterPlugin");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterPluginType();
  static final _id_onAttachedToEngine = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onAttachedToEngine",
      r"(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V");

  /// from: public abstract void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterPluginBinding binding)
  ///
  /// This {@code FlutterPlugin} has been associated with a io.flutter.embedding.engine.FlutterEngine instance.
  ///
  /// Relevant resources that this {@code FlutterPlugin} may need are provided via the {@code
  /// binding}. The {@code binding} may be cached and referenced until \#onDetachedFromEngine(FlutterPluginBinding) is invoked and returns.
  void onAttachedToEngine(
    FlutterPlugin_FlutterPluginBinding binding,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onAttachedToEngine,
        jni.JniCallType.voidType,
        [binding.reference]).check();
  }

  static final _id_onDetachedFromEngine = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onDetachedFromEngine",
      r"(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V");

  /// from: public abstract void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterPluginBinding binding)
  ///
  /// This {@code FlutterPlugin} has been removed from a io.flutter.embedding.engine.FlutterEngine instance.
  ///
  /// The {@code binding} passed to this method is the same instance that was passed in \#onAttachedToEngine(FlutterPluginBinding). It is provided again in this method as a
  /// convenience. The {@code binding} may be referenced during the execution of this method, but it
  /// must not be cached or referenced after this method returns.
  ///
  /// {@code FlutterPlugin}s should release all resources in this method.
  void onDetachedFromEngine(
    FlutterPlugin_FlutterPluginBinding binding,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onDetachedFromEngine,
        jni.JniCallType.voidType,
        [binding.reference]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FlutterPluginImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onAttachedToEngine(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V") {
        _$impls[$p]!.onAttachedToEngine(
          $a[0].castTo(const $FlutterPlugin_FlutterPluginBindingType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"onDetachedFromEngine(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V") {
        _$impls[$p]!.onDetachedFromEngine(
          $a[0].castTo(const $FlutterPlugin_FlutterPluginBindingType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory FlutterPlugin.implement(
    $FlutterPluginImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FlutterPlugin.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.plugins.FlutterPlugin",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $FlutterPluginImpl {
  factory $FlutterPluginImpl({
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onAttachedToEngine,
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onDetachedFromEngine,
  }) = _$FlutterPluginImpl;

  void onAttachedToEngine(FlutterPlugin_FlutterPluginBinding binding);
  void onDetachedFromEngine(FlutterPlugin_FlutterPluginBinding binding);
}

class _$FlutterPluginImpl implements $FlutterPluginImpl {
  _$FlutterPluginImpl({
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onAttachedToEngine,
    required void Function(FlutterPlugin_FlutterPluginBinding binding)
        onDetachedFromEngine,
  })  : _onAttachedToEngine = onAttachedToEngine,
        _onDetachedFromEngine = onDetachedFromEngine;

  final void Function(FlutterPlugin_FlutterPluginBinding binding)
      _onAttachedToEngine;
  final void Function(FlutterPlugin_FlutterPluginBinding binding)
      _onDetachedFromEngine;

  void onAttachedToEngine(FlutterPlugin_FlutterPluginBinding binding) {
    return _onAttachedToEngine(binding);
  }

  void onDetachedFromEngine(FlutterPlugin_FlutterPluginBinding binding) {
    return _onDetachedFromEngine(binding);
  }
}

final class $FlutterPluginType extends jni.JObjType<FlutterPlugin> {
  const $FlutterPluginType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/plugins/FlutterPlugin;";

  @override
  FlutterPlugin fromRef(jni.JObjectPtr ref) => FlutterPlugin.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterPluginType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterPluginType) &&
        other is $FlutterPluginType;
  }
}

/// from: io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterAssets
///
/// Provides Flutter plugins with access to Flutter asset information.
class FlutterPlugin_FlutterAssets extends jni.JObject {
  @override
  late final jni.JObjType<FlutterPlugin_FlutterAssets> $type = type;

  FlutterPlugin_FlutterAssets.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterPlugin_FlutterAssetsType();
  static final _id_getAssetFilePathByName = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAssetFilePathByName",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getAssetFilePathByName(java.lang.String assetFileName)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the relative file path to the Flutter asset with the given name, including the file's
  /// extension, e.g., {@code "myImage.jpg"}.
  ///
  /// The returned file path is relative to the Android app's standard assets directory.
  /// Therefore, the returned path is appropriate to pass to Android's {@code AssetManager}, but
  /// the path is not appropriate to load as an absolute path.
  jni.JString getAssetFilePathByName(
    jni.JString assetFileName,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAssetFilePathByName,
        jni.JniCallType.objectType,
        [assetFileName.reference]).object);
  }

  static final _id_getAssetFilePathByName1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAssetFilePathByName",
      r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getAssetFilePathByName(java.lang.String assetFileName, java.lang.String packageName)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#getAssetFilePathByName(String) but with added support for an explicit
  /// Android {@code packageName}.
  jni.JString getAssetFilePathByName1(
    jni.JString assetFileName,
    jni.JString packageName,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAssetFilePathByName1,
        jni.JniCallType.objectType,
        [assetFileName.reference, packageName.reference]).object);
  }

  static final _id_getAssetFilePathBySubpath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAssetFilePathBySubpath",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getAssetFilePathBySubpath(java.lang.String assetSubpath)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the relative file path to the Flutter asset with the given subpath, including the
  /// file's extension, e.g., {@code "/dir1/dir2/myImage.jpg"}.
  ///
  /// The returned file path is relative to the Android app's standard assets directory.
  /// Therefore, the returned path is appropriate to pass to Android's {@code AssetManager}, but
  /// the path is not appropriate to load as an absolute path.
  jni.JString getAssetFilePathBySubpath(
    jni.JString assetSubpath,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAssetFilePathBySubpath,
        jni.JniCallType.objectType,
        [assetSubpath.reference]).object);
  }

  static final _id_getAssetFilePathBySubpath1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAssetFilePathBySubpath",
      r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getAssetFilePathBySubpath(java.lang.String assetSubpath, java.lang.String packageName)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#getAssetFilePathBySubpath(String) but with added support for an explicit
  /// Android {@code packageName}.
  jni.JString getAssetFilePathBySubpath1(
    jni.JString assetSubpath,
    jni.JString packageName,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAssetFilePathBySubpath1,
        jni.JniCallType.objectType,
        [assetSubpath.reference, packageName.reference]).object);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FlutterPlugin_FlutterAssetsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"getAssetFilePathByName(Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathByName(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d ==
          r"getAssetFilePathByName(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathByName1(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d ==
          r"getAssetFilePathBySubpath(Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathBySubpath(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d ==
          r"getAssetFilePathBySubpath(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.getAssetFilePathBySubpath1(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory FlutterPlugin_FlutterAssets.implement(
    $FlutterPlugin_FlutterAssetsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FlutterPlugin_FlutterAssets.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterAssets",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $FlutterPlugin_FlutterAssetsImpl {
  factory $FlutterPlugin_FlutterAssetsImpl({
    required jni.JString Function(jni.JString assetFileName)
        getAssetFilePathByName,
    required jni.JString Function(
            jni.JString assetFileName, jni.JString packageName)
        getAssetFilePathByName1,
    required jni.JString Function(jni.JString assetSubpath)
        getAssetFilePathBySubpath,
    required jni.JString Function(
            jni.JString assetSubpath, jni.JString packageName)
        getAssetFilePathBySubpath1,
  }) = _$FlutterPlugin_FlutterAssetsImpl;

  jni.JString getAssetFilePathByName(jni.JString assetFileName);
  jni.JString getAssetFilePathByName1(
      jni.JString assetFileName, jni.JString packageName);
  jni.JString getAssetFilePathBySubpath(jni.JString assetSubpath);
  jni.JString getAssetFilePathBySubpath1(
      jni.JString assetSubpath, jni.JString packageName);
}

class _$FlutterPlugin_FlutterAssetsImpl
    implements $FlutterPlugin_FlutterAssetsImpl {
  _$FlutterPlugin_FlutterAssetsImpl({
    required jni.JString Function(jni.JString assetFileName)
        getAssetFilePathByName,
    required jni.JString Function(
            jni.JString assetFileName, jni.JString packageName)
        getAssetFilePathByName1,
    required jni.JString Function(jni.JString assetSubpath)
        getAssetFilePathBySubpath,
    required jni.JString Function(
            jni.JString assetSubpath, jni.JString packageName)
        getAssetFilePathBySubpath1,
  })  : _getAssetFilePathByName = getAssetFilePathByName,
        _getAssetFilePathByName1 = getAssetFilePathByName1,
        _getAssetFilePathBySubpath = getAssetFilePathBySubpath,
        _getAssetFilePathBySubpath1 = getAssetFilePathBySubpath1;

  final jni.JString Function(jni.JString assetFileName) _getAssetFilePathByName;
  final jni.JString Function(jni.JString assetFileName, jni.JString packageName)
      _getAssetFilePathByName1;
  final jni.JString Function(jni.JString assetSubpath)
      _getAssetFilePathBySubpath;
  final jni.JString Function(jni.JString assetSubpath, jni.JString packageName)
      _getAssetFilePathBySubpath1;

  jni.JString getAssetFilePathByName(jni.JString assetFileName) {
    return _getAssetFilePathByName(assetFileName);
  }

  jni.JString getAssetFilePathByName1(
      jni.JString assetFileName, jni.JString packageName) {
    return _getAssetFilePathByName1(assetFileName, packageName);
  }

  jni.JString getAssetFilePathBySubpath(jni.JString assetSubpath) {
    return _getAssetFilePathBySubpath(assetSubpath);
  }

  jni.JString getAssetFilePathBySubpath1(
      jni.JString assetSubpath, jni.JString packageName) {
    return _getAssetFilePathBySubpath1(assetSubpath, packageName);
  }
}

final class $FlutterPlugin_FlutterAssetsType
    extends jni.JObjType<FlutterPlugin_FlutterAssets> {
  const $FlutterPlugin_FlutterAssetsType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets;";

  @override
  FlutterPlugin_FlutterAssets fromRef(jni.JObjectPtr ref) =>
      FlutterPlugin_FlutterAssets.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterPlugin_FlutterAssetsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterPlugin_FlutterAssetsType) &&
        other is $FlutterPlugin_FlutterAssetsType;
  }
}

/// from: io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding
///
/// Resources made available to all plugins registered with a given io.flutter.embedding.engine.FlutterEngine.
///
/// The provided BinaryMessenger can be used to communicate with Dart code running in
/// the Flutter context associated with this plugin binding.
///
/// Plugins that need to respond to {@code Lifecycle} events should implement the additional
/// io.flutter.embedding.engine.plugins.activity.ActivityAware and/or io.flutter.embedding.engine.plugins.service.ServiceAware interfaces, where a Lifecycle
/// reference can be obtained.
class FlutterPlugin_FlutterPluginBinding extends jni.JObject {
  @override
  late final jni.JObjType<FlutterPlugin_FlutterPluginBinding> $type = type;

  FlutterPlugin_FlutterPluginBinding.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterPlugin_FlutterPluginBindingType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Landroid/content/Context;Lio/flutter/embedding/engine/FlutterEngine;Lio/flutter/plugin/common/BinaryMessenger;Lio/flutter/view/TextureRegistry;Lio/flutter/plugin/platform/PlatformViewRegistry;Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets;Lio/flutter/embedding/engine/FlutterEngineGroup;)V");

  /// from: public void <init>(android.content.Context applicationContext, io.flutter.embedding.engine.FlutterEngine flutterEngine, io.flutter.plugin.common.BinaryMessenger binaryMessenger, io.flutter.view.TextureRegistry textureRegistry, io.flutter.plugin.platform.PlatformViewRegistry platformViewRegistry, io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterAssets flutterAssets, io.flutter.embedding.engine.FlutterEngineGroup group)
  /// The returned object must be released after use, by calling the [release] method.
  factory FlutterPlugin_FlutterPluginBinding(
    jni.JObject applicationContext,
    FlutterEngine flutterEngine,
    jni.JObject binaryMessenger,
    jni.JObject textureRegistry,
    PlatformViewRegistry platformViewRegistry,
    FlutterPlugin_FlutterAssets flutterAssets,
    jni.JObject group,
  ) {
    return FlutterPlugin_FlutterPluginBinding.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      applicationContext.reference,
      flutterEngine.reference,
      binaryMessenger.reference,
      textureRegistry.reference,
      platformViewRegistry.reference,
      flutterAssets.reference,
      group.reference
    ]).object);
  }

  static final _id_getApplicationContext = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getApplicationContext",
      r"()Landroid/content/Context;");

  /// from: public android.content.Context getApplicationContext()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getApplicationContext() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getApplicationContext,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getFlutterEngine = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getFlutterEngine",
      r"()Lio/flutter/embedding/engine/FlutterEngine;");

  /// from: public io.flutter.embedding.engine.FlutterEngine getFlutterEngine()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// @deprecated Use {@code getBinaryMessenger()}, {@code getTextureRegistry()}, or {@code
  ///     getPlatformViewRegistry()} instead.
  FlutterEngine getFlutterEngine() {
    return const $FlutterEngineType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getFlutterEngine,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getBinaryMessenger = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getBinaryMessenger",
      r"()Lio/flutter/plugin/common/BinaryMessenger;");

  /// from: public io.flutter.plugin.common.BinaryMessenger getBinaryMessenger()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBinaryMessenger() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getBinaryMessenger,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getTextureRegistry = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getTextureRegistry",
      r"()Lio/flutter/view/TextureRegistry;");

  /// from: public io.flutter.view.TextureRegistry getTextureRegistry()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTextureRegistry() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getTextureRegistry,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getPlatformViewRegistry = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getPlatformViewRegistry",
      r"()Lio/flutter/plugin/platform/PlatformViewRegistry;");

  /// from: public io.flutter.plugin.platform.PlatformViewRegistry getPlatformViewRegistry()
  /// The returned object must be released after use, by calling the [release] method.
  PlatformViewRegistry getPlatformViewRegistry() {
    return const $PlatformViewRegistryType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getPlatformViewRegistry,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getFlutterAssets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getFlutterAssets",
      r"()Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterAssets;");

  /// from: public io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterAssets getFlutterAssets()
  /// The returned object must be released after use, by calling the [release] method.
  FlutterPlugin_FlutterAssets getFlutterAssets() {
    return const $FlutterPlugin_FlutterAssetsType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getFlutterAssets,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getEngineGroup = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getEngineGroup",
      r"()Lio/flutter/embedding/engine/FlutterEngineGroup;");

  /// from: public io.flutter.embedding.engine.FlutterEngineGroup getEngineGroup()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Accessor for the FlutterEngineGroup used to create the FlutterEngine for the
  /// app.
  ///
  /// This is useful in the rare case that a plugin has to spawn its own engine (for example,
  /// running an engine the background). The result is nullable since old versions of Flutter and
  /// custom setups may not have used a FlutterEngineGroup. Failing to use this when it is
  /// available will result in suboptimal performance and odd behaviors related to Dart isolate
  /// groups.
  jni.JObject getEngineGroup() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getEngineGroup, jni.JniCallType.objectType, []).object);
  }
}

final class $FlutterPlugin_FlutterPluginBindingType
    extends jni.JObjType<FlutterPlugin_FlutterPluginBinding> {
  const $FlutterPlugin_FlutterPluginBindingType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;";

  @override
  FlutterPlugin_FlutterPluginBinding fromRef(jni.JObjectPtr ref) =>
      FlutterPlugin_FlutterPluginBinding.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterPlugin_FlutterPluginBindingType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterPlugin_FlutterPluginBindingType) &&
        other is $FlutterPlugin_FlutterPluginBindingType;
  }
}

/// from: io.flutter.embedding.engine.FlutterEngine
///
/// A single Flutter execution environment.
///
/// The {@code FlutterEngine} is the container through which Dart code can be run in an Android
/// application.
///
/// Dart code in a {@code FlutterEngine} can execute in the background, or it can be render to the
/// screen by using the accompanying FlutterRenderer and Dart code using the Flutter
/// framework on the Dart side. Rendering can be started and stopped, thus allowing a {@code
/// FlutterEngine} to move from UI interaction to data-only processing and then back to UI
/// interaction.
///
/// Multiple {@code FlutterEngine}s may exist, execute Dart code, and render UIs within a single
/// Android app. For better memory performance characteristics, construct multiple {@code
/// FlutterEngine}s via io.flutter.embedding.engine.FlutterEngineGroup rather than via {@code
/// FlutterEngine}'s constructor directly.
///
/// To start running Dart and/or Flutter within this {@code FlutterEngine}, get a reference to
/// this engine's DartExecutor and then use DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint). The DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint) method must not be invoked twice
/// on the same {@code FlutterEngine}.
///
/// To start rendering Flutter content to the screen, use \#getRenderer() to obtain a
/// FlutterRenderer and then attach a RenderSurface. Consider using a io.flutter.embedding.android.FlutterView as a RenderSurface.
///
/// Instatiating the first {@code FlutterEngine} per process will also load the Flutter engine's
/// native library and start the Dart VM. Subsequent {@code FlutterEngine}s will run on the same VM
/// instance but will have their own Dart <a href="https://api.dartlang.org/stable/dart-isolate/Isolate-class.html">Isolate</a> when the
/// DartExecutor is run. Each Isolate is a self-contained Dart environment and cannot
/// communicate with each other except via Isolate ports.
class FlutterEngine extends jni.JObject {
  @override
  late final jni.JObjType<FlutterEngine> $type = type;

  FlutterEngine.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"io/flutter/embedding/engine/FlutterEngine");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterEngineType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructs a new {@code FlutterEngine}.
  ///
  /// A new {@code FlutterEngine} does not execute any Dart code automatically. See \#getDartExecutor() and DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint)
  /// to begin executing Dart code within this {@code FlutterEngine}.
  ///
  /// A new {@code FlutterEngine} will not display any UI until a RenderSurface is
  /// registered. See \#getRenderer() and FlutterRenderer\#startRenderingToSurface(Surface, boolean).
  ///
  /// A new {@code FlutterEngine} automatically attaches all plugins. See \#getPlugins().
  ///
  /// A new {@code FlutterEngine} does come with all default system channels attached.
  ///
  /// The first {@code FlutterEngine} instance constructed per process will also load the Flutter
  /// native library and start a Dart VM.
  ///
  /// In order to pass Dart VM initialization arguments (see io.flutter.embedding.engine.FlutterShellArgs) when creating the VM, manually set the
  /// initialization arguments by calling io.flutter.embedding.engine.loader.FlutterLoader\#startInitialization(Context) and io.flutter.embedding.engine.loader.FlutterLoader\#ensureInitializationComplete(Context,
  /// String[]) before constructing the engine.
  factory FlutterEngine(
    jni.JObject context,
  ) {
    return FlutterEngine.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [context.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;[Ljava/lang/String;)V");

  /// from: public void <init>(android.content.Context context, java.lang.String[] dartVmArgs)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context) with added support for passing Dart VM arguments.
  ///
  /// If the Dart VM has already started, the given arguments will have no effect.
  factory FlutterEngine.new1(
    jni.JObject context,
    jni.JArray<jni.JString> dartVmArgs,
  ) {
    return FlutterEngine.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [context.reference, dartVmArgs.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;[Ljava/lang/String;Z)V");

  /// from: public void <init>(android.content.Context context, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context) with added support for passing Dart VM arguments and
  /// avoiding automatic plugin registration.
  ///
  /// If the Dart VM has already started, the given arguments will have no effect.
  factory FlutterEngine.new2(
    jni.JObject context,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
  ) {
    return FlutterEngine.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new2, [
      context.reference,
      dartVmArgs.reference,
      automaticallyRegisterPlugins ? 1 : 0
    ]).object);
  }

  static final _id_new3 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;[Ljava/lang/String;ZZ)V");

  /// from: public void <init>(android.content.Context context, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, String[], boolean) with added support for configuring
  /// whether the engine will receive restoration data.
  ///
  /// The {@code waitForRestorationData} flag controls whether the engine delays responding to
  /// requests from the framework for restoration data until that data has been provided to the
  /// engine via {@code RestorationChannel.setRestorationData(byte[] data)}. If the flag is false,
  /// the framework may temporarily initialize itself to default values before the restoration data
  /// has been made available to the engine. Setting {@code waitForRestorationData} to true avoids
  /// this extra work by delaying initialization until the data is available.
  ///
  /// When {@code waitForRestorationData} is set, {@code
  /// RestorationChannel.setRestorationData(byte[] data)} must be called at a later point in time. If
  /// it later turns out that no restoration data is available to restore the framework from, that
  /// method must still be called with null as an argument to indicate "no data".
  ///
  /// If the framework never requests the restoration data, this flag has no effect.
  factory FlutterEngine.new3(
    jni.JObject context,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
    bool waitForRestorationData,
  ) {
    return FlutterEngine.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new3, [
      context.reference,
      dartVmArgs.reference,
      automaticallyRegisterPlugins ? 1 : 0,
      waitForRestorationData ? 1 : 0
    ]).object);
  }

  static final _id_new4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;)V");

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, FlutterLoader, FlutterJNI, String[], boolean) but with
  /// no Dart VM flags and automatically registers plugins.
  ///
  /// {@code flutterJNI} should be a new instance that has never been attached to an engine
  /// before.
  factory FlutterEngine.new4(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
  ) {
    return FlutterEngine.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new4, [
      context.reference,
      flutterLoader.reference,
      flutterJNI.reference
    ]).object);
  }

  static final _id_new5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;[Ljava/lang/String;Z)V");

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, FlutterLoader, FlutterJNI), plus Dart VM flags in
  /// {@code dartVmArgs}, and control over whether plugins are automatically registered with this
  /// {@code FlutterEngine} in {@code automaticallyRegisterPlugins}. If plugins are automatically
  /// registered, then they are registered during the execution of this constructor.
  factory FlutterEngine.new5(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
  ) {
    return FlutterEngine.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new5, [
      context.reference,
      flutterLoader.reference,
      flutterJNI.reference,
      dartVmArgs.reference,
      automaticallyRegisterPlugins ? 1 : 0
    ]).object);
  }

  static final _id_new6 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;Lio/flutter/plugin/platform/PlatformViewsController;[Ljava/lang/String;Z)V");

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, io.flutter.plugin.platform.PlatformViewsController platformViewsController, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Same as \#FlutterEngine(Context, FlutterLoader, FlutterJNI, String[], boolean), plus the
  /// ability to provide a custom {@code PlatformViewsController}.
  factory FlutterEngine.new6(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    PlatformViewsController platformViewsController,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
  ) {
    return FlutterEngine.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new6, [
      context.reference,
      flutterLoader.reference,
      flutterJNI.reference,
      platformViewsController.reference,
      dartVmArgs.reference,
      automaticallyRegisterPlugins ? 1 : 0
    ]).object);
  }

  static final _id_new7 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;Lio/flutter/plugin/platform/PlatformViewsController;[Ljava/lang/String;ZZ)V");

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, io.flutter.plugin.platform.PlatformViewsController platformViewsController, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Fully configurable {@code FlutterEngine} constructor.
  factory FlutterEngine.new7(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    PlatformViewsController platformViewsController,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
    bool waitForRestorationData,
  ) {
    return FlutterEngine.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new7, [
      context.reference,
      flutterLoader.reference,
      flutterJNI.reference,
      platformViewsController.reference,
      dartVmArgs.reference,
      automaticallyRegisterPlugins ? 1 : 0,
      waitForRestorationData ? 1 : 0
    ]).object);
  }

  static final _id_new8 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Landroid/content/Context;Lio/flutter/embedding/engine/loader/FlutterLoader;Lio/flutter/embedding/engine/FlutterJNI;Lio/flutter/plugin/platform/PlatformViewsController;[Ljava/lang/String;ZZLio/flutter/embedding/engine/FlutterEngineGroup;)V");

  /// from: public void <init>(android.content.Context context, io.flutter.embedding.engine.loader.FlutterLoader flutterLoader, io.flutter.embedding.engine.FlutterJNI flutterJNI, io.flutter.plugin.platform.PlatformViewsController platformViewsController, java.lang.String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData, io.flutter.embedding.engine.FlutterEngineGroup group)
  /// The returned object must be released after use, by calling the [release] method.
  factory FlutterEngine.new8(
    jni.JObject context,
    jni.JObject flutterLoader,
    jni.JObject flutterJNI,
    PlatformViewsController platformViewsController,
    jni.JArray<jni.JString> dartVmArgs,
    bool automaticallyRegisterPlugins,
    bool waitForRestorationData,
    jni.JObject group,
  ) {
    return FlutterEngine.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new8, [
      context.reference,
      flutterLoader.reference,
      flutterJNI.reference,
      platformViewsController.reference,
      dartVmArgs.reference,
      automaticallyRegisterPlugins ? 1 : 0,
      waitForRestorationData ? 1 : 0,
      group.reference
    ]).object);
  }

  static final _id_destroy =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"destroy", r"()V");

  /// from: public void destroy()
  ///
  /// Cleans up all components within this {@code FlutterEngine} and destroys the associated Dart
  /// Isolate. All state held by the Dart Isolate, such as the Flutter Elements tree, is lost.
  ///
  /// This {@code FlutterEngine} instance should be discarded after invoking this method.
  void destroy() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_destroy, jni.JniCallType.voidType, []).check();
  }

  static final _id_addEngineLifecycleListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addEngineLifecycleListener",
      r"(Lio/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener;)V");

  /// from: public void addEngineLifecycleListener(io.flutter.embedding.engine.FlutterEngine.EngineLifecycleListener listener)
  ///
  /// Adds a {@code listener} to be notified of Flutter engine lifecycle events, e.g., {@code
  /// onPreEngineStart()}.
  void addEngineLifecycleListener(
    FlutterEngine_EngineLifecycleListener listener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addEngineLifecycleListener,
        jni.JniCallType.voidType,
        [listener.reference]).check();
  }

  static final _id_removeEngineLifecycleListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeEngineLifecycleListener",
      r"(Lio/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener;)V");

  /// from: public void removeEngineLifecycleListener(io.flutter.embedding.engine.FlutterEngine.EngineLifecycleListener listener)
  ///
  /// Removes a {@code listener} that was previously added with \#addEngineLifecycleListener(EngineLifecycleListener).
  void removeEngineLifecycleListener(
    FlutterEngine_EngineLifecycleListener listener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeEngineLifecycleListener,
        jni.JniCallType.voidType,
        [listener.reference]).check();
  }

  static final _id_getDartExecutor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getDartExecutor",
      r"()Lio/flutter/embedding/engine/dart/DartExecutor;");

  /// from: public io.flutter.embedding.engine.dart.DartExecutor getDartExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The Dart execution context associated with this {@code FlutterEngine}.
  ///
  /// The DartExecutor can be used to start executing Dart code from a given entrypoint.
  /// See DartExecutor\#executeDartEntrypoint(DartExecutor.DartEntrypoint).
  ///
  /// Use the DartExecutor to connect any desired message channels and method channels to
  /// facilitate communication between Android and Dart/Flutter.
  jni.JObject getDartExecutor() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getDartExecutor, jni.JniCallType.objectType, []).object);
  }

  static final _id_getRenderer = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getRenderer",
      r"()Lio/flutter/embedding/engine/renderer/FlutterRenderer;");

  /// from: public io.flutter.embedding.engine.renderer.FlutterRenderer getRenderer()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The rendering system associated with this {@code FlutterEngine}.
  ///
  /// To render a Flutter UI that is produced by this {@code FlutterEngine}'s Dart code, attach a
  /// RenderSurface to this FlutterRenderer.
  jni.JObject getRenderer() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRenderer, jni.JniCallType.objectType, []).object);
  }

  static final _id_getAccessibilityChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAccessibilityChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/AccessibilityChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.AccessibilityChannel getAccessibilityChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends accessibility requests and events from Flutter to Android.
  jni.JObject getAccessibilityChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getLifecycleChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getLifecycleChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/LifecycleChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.LifecycleChannel getLifecycleChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends Android lifecycle events to Flutter.
  jni.JObject getLifecycleChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLifecycleChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getLocalizationChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getLocalizationChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/LocalizationChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.LocalizationChannel getLocalizationChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends locale data from Android to Flutter.
  jni.JObject getLocalizationChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLocalizationChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getNavigationChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getNavigationChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/NavigationChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.NavigationChannel getNavigationChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends Flutter navigation commands from Android to Flutter.
  jni.JObject getNavigationChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getNavigationChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getPlatformChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getPlatformChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/PlatformChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.PlatformChannel getPlatformChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends platform-oriented requests and information to Flutter, e.g., requests
  /// to play sounds, requests for haptics, system chrome settings, etc.
  jni.JObject getPlatformChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getPlatformChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getProcessTextChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getProcessTextChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/ProcessTextChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.ProcessTextChannel getProcessTextChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends text processing requests from Flutter to Android.
  jni.JObject getProcessTextChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getProcessTextChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getRestorationChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getRestorationChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/RestorationChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.RestorationChannel getRestorationChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel to exchange restoration data between framework and engine.
  ///
  /// The engine can obtain the current restoration data from the framework via this channel to
  /// store it on disk and - when the app is relaunched - provide the stored data back to the
  /// framework to recreate the original state of the app.
  jni.JObject getRestorationChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getRestorationChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getSettingsChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getSettingsChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/SettingsChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.SettingsChannel getSettingsChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends platform/user settings from Android to Flutter, e.g., time format,
  /// scale factor, etc.
  jni.JObject getSettingsChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getSettingsChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getDeferredComponentChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getDeferredComponentChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/DeferredComponentChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.DeferredComponentChannel getDeferredComponentChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that allows manual installation and state querying of deferred components.
  jni.JObject getDeferredComponentChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDeferredComponentChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getSystemChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getSystemChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/SystemChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.SystemChannel getSystemChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends memory pressure warnings from Android to Flutter.
  jni.JObject getSystemChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getSystemChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getMouseCursorChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getMouseCursorChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/MouseCursorChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.MouseCursorChannel getMouseCursorChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends and receives text input requests and state.
  jni.JObject getMouseCursorChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getMouseCursorChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getTextInputChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getTextInputChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/TextInputChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.TextInputChannel getTextInputChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends and receives text input requests and state.
  jni.JObject getTextInputChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getTextInputChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getSpellCheckChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getSpellCheckChannel",
      r"()Lio/flutter/embedding/engine/systemchannels/SpellCheckChannel;");

  /// from: public io.flutter.embedding.engine.systemchannels.SpellCheckChannel getSpellCheckChannel()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// System channel that sends and receives spell check requests and results.
  jni.JObject getSpellCheckChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getSpellCheckChannel,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getPlugins = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getPlugins",
      r"()Lio/flutter/embedding/engine/plugins/PluginRegistry;");

  /// from: public io.flutter.embedding.engine.plugins.PluginRegistry getPlugins()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Plugin registry, which registers plugins that want to be applied to this {@code FlutterEngine}.
  jni.JObject getPlugins() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPlugins, jni.JniCallType.objectType, []).object);
  }

  static final _id_getLocalizationPlugin = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getLocalizationPlugin",
      r"()Lio/flutter/plugin/localization/LocalizationPlugin;");

  /// from: public io.flutter.plugin.localization.LocalizationPlugin getLocalizationPlugin()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The LocalizationPlugin this FlutterEngine created.
  jni.JObject getLocalizationPlugin() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLocalizationPlugin,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getPlatformViewsController = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getPlatformViewsController",
      r"()Lio/flutter/plugin/platform/PlatformViewsController;");

  /// from: public io.flutter.plugin.platform.PlatformViewsController getPlatformViewsController()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// {@code PlatformViewsController}, which controls all platform views running within this {@code
  /// FlutterEngine}.
  PlatformViewsController getPlatformViewsController() {
    return const $PlatformViewsControllerType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getPlatformViewsController,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getActivityControlSurface = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getActivityControlSurface",
      r"()Lio/flutter/embedding/engine/plugins/activity/ActivityControlSurface;");

  /// from: public io.flutter.embedding.engine.plugins.activity.ActivityControlSurface getActivityControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getActivityControlSurface() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getActivityControlSurface,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getServiceControlSurface = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getServiceControlSurface",
      r"()Lio/flutter/embedding/engine/plugins/service/ServiceControlSurface;");

  /// from: public io.flutter.embedding.engine.plugins.service.ServiceControlSurface getServiceControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getServiceControlSurface() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getServiceControlSurface,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getBroadcastReceiverControlSurface = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBroadcastReceiverControlSurface",
          r"()Lio/flutter/embedding/engine/plugins/broadcastreceiver/BroadcastReceiverControlSurface;");

  /// from: public io.flutter.embedding.engine.plugins.broadcastreceiver.BroadcastReceiverControlSurface getBroadcastReceiverControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBroadcastReceiverControlSurface() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getBroadcastReceiverControlSurface,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getContentProviderControlSurface = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getContentProviderControlSurface",
          r"()Lio/flutter/embedding/engine/plugins/contentprovider/ContentProviderControlSurface;");

  /// from: public io.flutter.embedding.engine.plugins.contentprovider.ContentProviderControlSurface getContentProviderControlSurface()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentProviderControlSurface() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getContentProviderControlSurface,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_updateDisplayMetrics = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"updateDisplayMetrics", r"(FFF)V");

  /// from: public void updateDisplayMetrics(float width, float height, float density)
  void updateDisplayMetrics(
    double width,
    double height,
    double density,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_updateDisplayMetrics, jni.JniCallType.voidType, [
      jni.JValueFloat(width),
      jni.JValueFloat(height),
      jni.JValueFloat(density)
    ]).check();
  }
}

final class $FlutterEngineType extends jni.JObjType<FlutterEngine> {
  const $FlutterEngineType();

  @override
  String get signature => r"Lio/flutter/embedding/engine/FlutterEngine;";

  @override
  FlutterEngine fromRef(jni.JObjectPtr ref) => FlutterEngine.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterEngineType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterEngineType) &&
        other is $FlutterEngineType;
  }
}

/// from: io.flutter.embedding.engine.FlutterEngine$EngineLifecycleListener
///
/// Lifecycle callbacks for Flutter engine lifecycle events.
class FlutterEngine_EngineLifecycleListener extends jni.JObject {
  @override
  late final jni.JObjType<FlutterEngine_EngineLifecycleListener> $type = type;

  FlutterEngine_EngineLifecycleListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"io/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener");

  /// The type which includes information such as the signature of this class.
  static const type = $FlutterEngine_EngineLifecycleListenerType();
  static final _id_onPreEngineRestart = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onPreEngineRestart", r"()V");

  /// from: public abstract void onPreEngineRestart()
  ///
  /// Lifecycle callback invoked before a hot restart of the Flutter engine.
  void onPreEngineRestart() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onPreEngineRestart, jni.JniCallType.voidType, []).check();
  }

  static final _id_onEngineWillDestroy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onEngineWillDestroy", r"()V");

  /// from: public abstract void onEngineWillDestroy()
  ///
  /// Lifecycle callback invoked before the Flutter engine is destroyed.
  ///
  /// For the duration of the call, the Flutter engine is still valid.
  void onEngineWillDestroy() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onEngineWillDestroy, jni.JniCallType.voidType, []).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FlutterEngine_EngineLifecycleListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onPreEngineRestart()V") {
        _$impls[$p]!.onPreEngineRestart();
        return jni.nullptr;
      }
      if ($d == r"onEngineWillDestroy()V") {
        _$impls[$p]!.onEngineWillDestroy();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory FlutterEngine_EngineLifecycleListener.implement(
    $FlutterEngine_EngineLifecycleListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FlutterEngine_EngineLifecycleListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.embedding.engine.FlutterEngine$EngineLifecycleListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $FlutterEngine_EngineLifecycleListenerImpl {
  factory $FlutterEngine_EngineLifecycleListenerImpl({
    required void Function() onPreEngineRestart,
    required void Function() onEngineWillDestroy,
  }) = _$FlutterEngine_EngineLifecycleListenerImpl;

  void onPreEngineRestart();
  void onEngineWillDestroy();
}

class _$FlutterEngine_EngineLifecycleListenerImpl
    implements $FlutterEngine_EngineLifecycleListenerImpl {
  _$FlutterEngine_EngineLifecycleListenerImpl({
    required void Function() onPreEngineRestart,
    required void Function() onEngineWillDestroy,
  })  : _onPreEngineRestart = onPreEngineRestart,
        _onEngineWillDestroy = onEngineWillDestroy;

  final void Function() _onPreEngineRestart;
  final void Function() _onEngineWillDestroy;

  void onPreEngineRestart() {
    return _onPreEngineRestart();
  }

  void onEngineWillDestroy() {
    return _onEngineWillDestroy();
  }
}

final class $FlutterEngine_EngineLifecycleListenerType
    extends jni.JObjType<FlutterEngine_EngineLifecycleListener> {
  const $FlutterEngine_EngineLifecycleListenerType();

  @override
  String get signature =>
      r"Lio/flutter/embedding/engine/FlutterEngine$EngineLifecycleListener;";

  @override
  FlutterEngine_EngineLifecycleListener fromRef(jni.JObjectPtr ref) =>
      FlutterEngine_EngineLifecycleListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FlutterEngine_EngineLifecycleListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FlutterEngine_EngineLifecycleListenerType) &&
        other is $FlutterEngine_EngineLifecycleListenerType;
  }
}

/// from: io.flutter.plugin.platform.PlatformViewsController
///
/// Manages platform views.
///
/// Each io.flutter.embedding.engine.FlutterEngine or io.flutter.app.FlutterPluginRegistry has a single platform views controller. A platform views
/// controller can be attached to at most one Flutter view.
class PlatformViewsController extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewsController> $type = type;

  PlatformViewsController.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"io/flutter/plugin/platform/PlatformViewsController");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewsControllerType();
  static final _id_createPlatformView = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createPlatformView",
      r"(Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;Z)Lio/flutter/plugin/platform/PlatformView;");

  /// from: public io.flutter.plugin.platform.PlatformView createPlatformView(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request, boolean wrapContext)
  /// The returned object must be released after use, by calling the [release] method.
  PlatformView createPlatformView(
    PlatformViewsChannel_PlatformViewCreationRequest request,
    bool wrapContext,
  ) {
    return const $PlatformViewType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_createPlatformView,
            jni.JniCallType.objectType,
            [request.reference, wrapContext ? 1 : 0]).object);
  }

  static final _id_configureForTextureLayerComposition = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"configureForTextureLayerComposition",
          r"(Lio/flutter/plugin/platform/PlatformView;Lio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewCreationRequest;)J");

  /// from: public long configureForTextureLayerComposition(io.flutter.plugin.platform.PlatformView platformView, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewCreationRequest request)
  int configureForTextureLayerComposition(
    PlatformView platformView,
    PlatformViewsChannel_PlatformViewCreationRequest request,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_configureForTextureLayerComposition,
        jni.JniCallType.longType,
        [platformView.reference, request.reference]).long;
  }

  static final _id_toMotionEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"toMotionEvent",
      r"(FLio/flutter/embedding/engine/systemchannels/PlatformViewsChannel$PlatformViewTouch;Z)Landroid/view/MotionEvent;");

  /// from: public android.view.MotionEvent toMotionEvent(float density, io.flutter.embedding.engine.systemchannels.PlatformViewsChannel.PlatformViewTouch touch, boolean usingVirtualDiplay)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toMotionEvent(
    double density,
    PlatformViewsChannel_PlatformViewTouch touch,
    bool usingVirtualDiplay,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toMotionEvent, jni.JniCallType.objectType, [
      jni.JValueFloat(density),
      touch.reference,
      usingVirtualDiplay ? 1 : 0
    ]).object);
  }

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory PlatformViewsController() {
    return PlatformViewsController.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_attach = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"attach",
      r"(Landroid/content/Context;Lio/flutter/view/TextureRegistry;Lio/flutter/embedding/engine/dart/DartExecutor;)V");

  /// from: public void attach(android.content.Context context, io.flutter.view.TextureRegistry textureRegistry, io.flutter.embedding.engine.dart.DartExecutor dartExecutor)
  ///
  /// Attaches this platform views controller to its input and output channels.
  ///@param context The base context that will be passed to embedded views created by this
  ///     controller. This should be the context of the Activity hosting the Flutter application.
  ///@param textureRegistry The texture registry which provides the output textures into which the
  ///     embedded views will be rendered.
  ///@param dartExecutor The dart execution context, which is used to set up a system channel.
  void attach(
    jni.JObject context,
    jni.JObject textureRegistry,
    jni.JObject dartExecutor,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_attach, jni.JniCallType.voidType, [
      context.reference,
      textureRegistry.reference,
      dartExecutor.reference
    ]).check();
  }

  static final _id_setSoftwareRendering = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSoftwareRendering", r"(Z)V");

  /// from: public void setSoftwareRendering(boolean useSoftwareRendering)
  ///
  /// Sets whether Flutter uses software rendering.
  ///
  /// When software rendering is used, no GL context is available on the raster thread. When this
  /// is set to true, there's no Flutter composition of Android views and Flutter widgets since GL
  /// textures cannot be used.
  ///
  /// Software rendering is only used for testing in emulators, and it should never be set to true
  /// in a production environment.
  ///@param useSoftwareRendering Whether software rendering is used.
  void setSoftwareRendering(
    bool useSoftwareRendering,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setSoftwareRendering,
        jni.JniCallType.voidType,
        [useSoftwareRendering ? 1 : 0]).check();
  }

  static final _id_detach =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"detach", r"()V");

  /// from: public void detach()
  ///
  /// Detaches this platform views controller.
  ///
  /// This is typically called when a Flutter applications moves to run in the background, or is
  /// destroyed. After calling this the platform views controller will no longer listen to it's
  /// previous messenger, and will not maintain references to the texture registry, context, and
  /// messenger passed to the previous attach call.
  void detach() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_detach, jni.JniCallType.voidType, []).check();
  }

  static final _id_attachToView = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"attachToView",
      r"(Lio/flutter/embedding/android/FlutterView;)V");

  /// from: public void attachToView(io.flutter.embedding.android.FlutterView newFlutterView)
  ///
  /// Attaches the controller to a FlutterView.
  ///
  /// When io.flutter.embedding.android.FlutterFragment is used, this method is called
  /// after the device rotates since the FlutterView is recreated after a rotation.
  void attachToView(
    jni.JObject newFlutterView,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_attachToView,
        jni.JniCallType.voidType, [newFlutterView.reference]).check();
  }

  static final _id_detachFromView = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"detachFromView", r"()V");

  /// from: public void detachFromView()
  ///
  /// Detaches the controller from FlutterView.
  ///
  /// When io.flutter.embedding.android.FlutterFragment is used, this method is called
  /// when the device rotates since the FlutterView is detached from the fragment. The next time the
  /// fragment needs to be displayed, a new Flutter view is created, so attachToView is called again.
  void detachFromView() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_detachFromView, jni.JniCallType.voidType, []).check();
  }

  static final _id_attachAccessibilityBridge = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"attachAccessibilityBridge",
      r"(Lio/flutter/view/AccessibilityBridge;)V");

  /// from: public void attachAccessibilityBridge(io.flutter.view.AccessibilityBridge accessibilityBridge)
  void attachAccessibilityBridge(
    jni.JObject accessibilityBridge,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_attachAccessibilityBridge,
        jni.JniCallType.voidType,
        [accessibilityBridge.reference]).check();
  }

  static final _id_detachAccessibilityBridge = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"detachAccessibilityBridge", r"()V");

  /// from: public void detachAccessibilityBridge()
  void detachAccessibilityBridge() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_detachAccessibilityBridge, jni.JniCallType.voidType, []).check();
  }

  static final _id_attachTextInputPlugin = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"attachTextInputPlugin",
      r"(Lio/flutter/plugin/editing/TextInputPlugin;)V");

  /// from: public void attachTextInputPlugin(io.flutter.plugin.editing.TextInputPlugin textInputPlugin)
  ///
  /// Attaches this controller to a text input plugin.
  ///
  /// While a text input plugin is available, the platform views controller interacts with it to
  /// facilitate delegation of text input connections to platform views.
  ///
  /// A platform views controller should be attached to a text input plugin whenever it is
  /// possible for the Flutter framework to receive text input.
  void attachTextInputPlugin(
    jni.JObject textInputPlugin,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_attachTextInputPlugin,
        jni.JniCallType.voidType,
        [textInputPlugin.reference]).check();
  }

  static final _id_detachTextInputPlugin = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"detachTextInputPlugin", r"()V");

  /// from: public void detachTextInputPlugin()
  ///
  /// Detaches this controller from the currently attached text input plugin.
  void detachTextInputPlugin() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_detachTextInputPlugin, jni.JniCallType.voidType, []).check();
  }

  static final _id_checkInputConnectionProxy = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"checkInputConnectionProxy",
      r"(Landroid/view/View;)Z");

  /// from: public boolean checkInputConnectionProxy(android.view.View view)
  ///
  /// Returns true if Flutter should perform input connection proxying for the view.
  ///
  /// If the view is a platform view managed by this platform views controller returns true. Else
  /// if the view was created in a platform view's VD, delegates the decision to the platform view's
  /// View\#checkInputConnectionProxy(View) method. Else returns false.
  bool checkInputConnectionProxy(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_checkInputConnectionProxy,
        jni.JniCallType.booleanType,
        [view.reference]).boolean;
  }

  static final _id_getRegistry = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getRegistry",
      r"()Lio/flutter/plugin/platform/PlatformViewRegistry;");

  /// from: public io.flutter.plugin.platform.PlatformViewRegistry getRegistry()
  /// The returned object must be released after use, by calling the [release] method.
  PlatformViewRegistry getRegistry() {
    return const $PlatformViewRegistryType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_getRegistry, jni.JniCallType.objectType, []).object);
  }

  static final _id_onAttachedToJNI = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onAttachedToJNI", r"()V");

  /// from: public void onAttachedToJNI()
  ///
  /// Invoked when the io.flutter.embedding.engine.FlutterEngine that owns this PlatformViewsController attaches to JNI.
  void onAttachedToJNI() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onAttachedToJNI, jni.JniCallType.voidType, []).check();
  }

  static final _id_onDetachedFromJNI = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onDetachedFromJNI", r"()V");

  /// from: public void onDetachedFromJNI()
  ///
  /// Invoked when the io.flutter.embedding.engine.FlutterEngine that owns this PlatformViewsController detaches from JNI.
  void onDetachedFromJNI() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onDetachedFromJNI, jni.JniCallType.voidType, []).check();
  }

  static final _id_onPreEngineRestart = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onPreEngineRestart", r"()V");

  /// from: public void onPreEngineRestart()
  void onPreEngineRestart() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onPreEngineRestart, jni.JniCallType.voidType, []).check();
  }

  static final _id_getPlatformViewById = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getPlatformViewById", r"(I)Landroid/view/View;");

  /// from: public android.view.View getPlatformViewById(int viewId)
  /// The returned object must be released after use, by calling the [release] method.
  View getPlatformViewById(
    int viewId,
  ) {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getPlatformViewById,
        jni.JniCallType.objectType,
        [jni.JValueInt(viewId)]).object);
  }

  static final _id_usesVirtualDisplay = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"usesVirtualDisplay", r"(I)Z");

  /// from: public boolean usesVirtualDisplay(int id)
  bool usesVirtualDisplay(
    int id,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_usesVirtualDisplay,
        jni.JniCallType.booleanType,
        [jni.JValueInt(id)]).boolean;
  }

  static final _id_disposePlatformView = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"disposePlatformView", r"(I)V");

  /// from: public void disposePlatformView(int viewId)
  ///
  /// Disposes a single
  ///@param viewId the PlatformView ID.
  void disposePlatformView(
    int viewId,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_disposePlatformView,
        jni.JniCallType.voidType,
        [jni.JValueInt(viewId)]).check();
  }

  static final _id_attachToFlutterRenderer = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"attachToFlutterRenderer",
      r"(Lio/flutter/embedding/engine/renderer/FlutterRenderer;)V");

  /// from: public void attachToFlutterRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer flutterRenderer)
  void attachToFlutterRenderer(
    jni.JObject flutterRenderer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_attachToFlutterRenderer,
        jni.JniCallType.voidType,
        [flutterRenderer.reference]).check();
  }

  static final _id_onDisplayPlatformView = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onDisplayPlatformView",
      r"(IIIIIIILio/flutter/embedding/engine/mutatorsstack/FlutterMutatorsStack;)V");

  /// from: public void onDisplayPlatformView(int viewId, int x, int y, int width, int height, int viewWidth, int viewHeight, io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack mutatorsStack)
  ///
  /// Called when a platform view id displayed in the current frame.
  ///@param viewId The ID of the platform view.
  ///@param x The left position relative to {@code FlutterView}.
  ///@param y The top position relative to {@code FlutterView}.
  ///@param width The width of the platform view.
  ///@param height The height of the platform view.
  ///@param viewWidth The original width of the platform view before applying the mutator stack.
  ///@param viewHeight The original height of the platform view before applying the mutator stack.
  ///@param mutatorsStack The mutator stack. This member is not intended for public use, and is only
  ///     visible for testing.
  void onDisplayPlatformView(
    int viewId,
    int x,
    int y,
    int width,
    int height,
    int viewWidth,
    int viewHeight,
    jni.JObject mutatorsStack,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onDisplayPlatformView, jni.JniCallType.voidType, [
      jni.JValueInt(viewId),
      jni.JValueInt(x),
      jni.JValueInt(y),
      jni.JValueInt(width),
      jni.JValueInt(height),
      jni.JValueInt(viewWidth),
      jni.JValueInt(viewHeight),
      mutatorsStack.reference
    ]).check();
  }

  static final _id_onDisplayOverlaySurface = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onDisplayOverlaySurface", r"(IIIII)V");

  /// from: public void onDisplayOverlaySurface(int id, int x, int y, int width, int height)
  ///
  /// Called when an overlay surface is displayed in the current frame.
  ///@param id The ID of the surface.
  ///@param x The left position relative to {@code FlutterView}.
  ///@param y The top position relative to {@code FlutterView}.
  ///@param width The width of the surface.
  ///@param height The height of the surface. This member is not intended for public use, and is
  ///     only visible for testing.
  void onDisplayOverlaySurface(
    int id,
    int x,
    int y,
    int width,
    int height,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onDisplayOverlaySurface, jni.JniCallType.voidType, [
      jni.JValueInt(id),
      jni.JValueInt(x),
      jni.JValueInt(y),
      jni.JValueInt(width),
      jni.JValueInt(height)
    ]).check();
  }

  static final _id_onBeginFrame = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onBeginFrame", r"()V");

  /// from: public void onBeginFrame()
  void onBeginFrame() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onBeginFrame, jni.JniCallType.voidType, []).check();
  }

  static final _id_onEndFrame =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onEndFrame", r"()V");

  /// from: public void onEndFrame()
  ///
  /// Called by {@code FlutterJNI} when the Flutter frame was submitted.
  ///
  /// This member is not intended for public use, and is only visible for testing.
  void onEndFrame() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onEndFrame, jni.JniCallType.voidType, []).check();
  }

  static final _id_createOverlaySurface = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createOverlaySurface",
      r"(Lio/flutter/plugin/platform/PlatformOverlayView;)Lio/flutter/embedding/engine/FlutterOverlaySurface;");

  /// from: public io.flutter.embedding.engine.FlutterOverlaySurface createOverlaySurface(io.flutter.plugin.platform.PlatformOverlayView imageView)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates and tracks the overlay surface.
  ///@param imageView The surface that displays the overlay.
  ///@return Wrapper object that provides the layer id and the surface. This member is not intended
  ///     for public use, and is only visible for testing.
  jni.JObject createOverlaySurface(
    jni.JObject imageView,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createOverlaySurface,
        jni.JniCallType.objectType,
        [imageView.reference]).object);
  }

  static final _id_createOverlaySurface1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createOverlaySurface",
      r"()Lio/flutter/embedding/engine/FlutterOverlaySurface;");

  /// from: public io.flutter.embedding.engine.FlutterOverlaySurface createOverlaySurface()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates an overlay surface while the Flutter view is rendered by {@code PlatformOverlayView}.
  ///
  /// This method is invoked by {@code FlutterJNI} only.
  ///
  /// This member is not intended for public use, and is only visible for testing.
  jni.JObject createOverlaySurface1() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createOverlaySurface1,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_destroyOverlaySurfaces = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"destroyOverlaySurfaces", r"()V");

  /// from: public void destroyOverlaySurfaces()
  ///
  /// Destroys the overlay surfaces and removes them from the view hierarchy.
  ///
  /// This method is used only internally by {@code FlutterJNI}.
  void destroyOverlaySurfaces() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_destroyOverlaySurfaces, jni.JniCallType.voidType, []).check();
  }

  static final _id_getOverlayLayerViews = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getOverlayLayerViews",
      r"()Landroid/util/SparseArray;");

  /// from: public android.util.SparseArray<io.flutter.plugin.platform.PlatformOverlayView> getOverlayLayerViews()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOverlayLayerViews() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getOverlayLayerViews,
        jni.JniCallType.objectType, []).object);
  }
}

final class $PlatformViewsControllerType
    extends jni.JObjType<PlatformViewsController> {
  const $PlatformViewsControllerType();

  @override
  String get signature =>
      r"Lio/flutter/plugin/platform/PlatformViewsController;";

  @override
  PlatformViewsController fromRef(jni.JObjectPtr ref) =>
      PlatformViewsController.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewsControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewsControllerType) &&
        other is $PlatformViewsControllerType;
  }
}

/// from: io.flutter.plugin.platform.PlatformViewRegistry
///
/// Registry for platform view factories.
///
/// Plugins can register factories for specific view types.
class PlatformViewRegistry extends jni.JObject {
  @override
  late final jni.JObjType<PlatformViewRegistry> $type = type;

  PlatformViewRegistry.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"io/flutter/plugin/platform/PlatformViewRegistry");

  /// The type which includes information such as the signature of this class.
  static const type = $PlatformViewRegistryType();
  static final _id_registerViewFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"registerViewFactory",
      r"(Ljava/lang/String;Lio/flutter/plugin/platform/PlatformViewFactory;)Z");

  /// from: public abstract boolean registerViewFactory(java.lang.String viewTypeId, io.flutter.plugin.platform.PlatformViewFactory factory)
  ///
  /// Registers a factory for a platform view.
  ///@param viewTypeId unique identifier for the platform view's type.
  ///@param factory factory for creating platform views of the specified type.
  ///@return true if succeeded, false if a factory is already registered for viewTypeId.
  bool registerViewFactory(
    jni.JString viewTypeId,
    jni.JObject factory0,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_registerViewFactory,
        jni.JniCallType.booleanType,
        [viewTypeId.reference, factory0.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PlatformViewRegistryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"registerViewFactory(Ljava/lang/String;Lio/flutter/plugin/platform/PlatformViewFactory;)Z") {
        final $r = _$impls[$p]!.registerViewFactory(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PlatformViewRegistry.implement(
    $PlatformViewRegistryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PlatformViewRegistry.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"io.flutter.plugin.platform.PlatformViewRegistry",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $PlatformViewRegistryImpl {
  factory $PlatformViewRegistryImpl({
    required bool Function(jni.JString viewTypeId, jni.JObject factory0)
        registerViewFactory,
  }) = _$PlatformViewRegistryImpl;

  bool registerViewFactory(jni.JString viewTypeId, jni.JObject factory0);
}

class _$PlatformViewRegistryImpl implements $PlatformViewRegistryImpl {
  _$PlatformViewRegistryImpl({
    required bool Function(jni.JString viewTypeId, jni.JObject factory0)
        registerViewFactory,
  }) : _registerViewFactory = registerViewFactory;

  final bool Function(jni.JString viewTypeId, jni.JObject factory0)
      _registerViewFactory;

  bool registerViewFactory(jni.JString viewTypeId, jni.JObject factory0) {
    return _registerViewFactory(viewTypeId, factory0);
  }
}

final class $PlatformViewRegistryType
    extends jni.JObjType<PlatformViewRegistry> {
  const $PlatformViewRegistryType();

  @override
  String get signature => r"Lio/flutter/plugin/platform/PlatformViewRegistry;";

  @override
  PlatformViewRegistry fromRef(jni.JObjectPtr ref) =>
      PlatformViewRegistry.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PlatformViewRegistryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PlatformViewRegistryType) &&
        other is $PlatformViewRegistryType;
  }
}

/// from: com.example.webview_demo.NativeViewFactory
class NativeViewFactory extends jni.JObject {
  @override
  late final jni.JObjType<NativeViewFactory> $type = type;

  NativeViewFactory.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/example/webview_demo/NativeViewFactory");

  /// The type which includes information such as the signature of this class.
  static const type = $NativeViewFactoryType();
  static final _id_create = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;");

  /// from: public abstract io.flutter.plugin.platform.PlatformView create(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  PlatformView create(
    jni.JObject context,
    int i,
    jni.JObject object,
  ) {
    return const $PlatformViewType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create, jni.JniCallType.objectType,
            [context.reference, jni.JValueInt(i), object.reference]).object);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $NativeViewFactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"create(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;") {
        final $r = _$impls[$p]!.create(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory NativeViewFactory.implement(
    $NativeViewFactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = NativeViewFactory.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.example.webview_demo.NativeViewFactory",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $NativeViewFactoryImpl {
  factory $NativeViewFactoryImpl({
    required PlatformView Function(
            jni.JObject context, int i, jni.JObject object)
        create,
  }) = _$NativeViewFactoryImpl;

  PlatformView create(jni.JObject context, int i, jni.JObject object);
}

class _$NativeViewFactoryImpl implements $NativeViewFactoryImpl {
  _$NativeViewFactoryImpl({
    required PlatformView Function(
            jni.JObject context, int i, jni.JObject object)
        create,
  }) : _create = create;

  final PlatformView Function(jni.JObject context, int i, jni.JObject object)
      _create;

  PlatformView create(jni.JObject context, int i, jni.JObject object) {
    return _create(context, i, object);
  }
}

final class $NativeViewFactoryType extends jni.JObjType<NativeViewFactory> {
  const $NativeViewFactoryType();

  @override
  String get signature => r"Lcom/example/webview_demo/NativeViewFactory;";

  @override
  NativeViewFactory fromRef(jni.JObjectPtr ref) =>
      NativeViewFactory.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($NativeViewFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NativeViewFactoryType) &&
        other is $NativeViewFactoryType;
  }
}

/// from: com.example.webview_demo.NativeViewFactoryWrapper
class NativeViewFactoryWrapper extends jni.JObject {
  @override
  late final jni.JObjType<NativeViewFactoryWrapper> $type = type;

  NativeViewFactoryWrapper.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/example/webview_demo/NativeViewFactoryWrapper");

  /// The type which includes information such as the signature of this class.
  static const type = $NativeViewFactoryWrapperType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lcom/example/webview_demo/NativeViewFactory;)V");

  /// from: public void <init>(com.example.webview_demo.NativeViewFactory nativeViewFactory)
  /// The returned object must be released after use, by calling the [release] method.
  factory NativeViewFactoryWrapper(
    NativeViewFactory nativeViewFactory,
  ) {
    return NativeViewFactoryWrapper.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [nativeViewFactory.reference]).object);
  }

  static final _id_create = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;");

  /// from: public io.flutter.plugin.platform.PlatformView create(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  PlatformView create(
    jni.JObject context,
    int i,
    jni.JObject object,
  ) {
    return const $PlatformViewType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create, jni.JniCallType.objectType,
            [context.reference, jni.JValueInt(i), object.reference]).object);
  }
}

final class $NativeViewFactoryWrapperType
    extends jni.JObjType<NativeViewFactoryWrapper> {
  const $NativeViewFactoryWrapperType();

  @override
  String get signature =>
      r"Lcom/example/webview_demo/NativeViewFactoryWrapper;";

  @override
  NativeViewFactoryWrapper fromRef(jni.JObjectPtr ref) =>
      NativeViewFactoryWrapper.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($NativeViewFactoryWrapperType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NativeViewFactoryWrapperType) &&
        other is $NativeViewFactoryWrapperType;
  }
}

/// from: com.example.webview_demo.MainActivity$Companion
class MainActivity_Companion extends jni.JObject {
  @override
  late final jni.JObjType<MainActivity_Companion> $type = type;

  MainActivity_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/example/webview_demo/MainActivity$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $MainActivity_CompanionType();
  static final _id_getTheView = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTheView", r"()Ljava/util/HashMap;");

  /// from: public final java.util.HashMap getTheView()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTheView() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTheView, jni.JniCallType.objectType, []).object);
  }

  static final _id_setTheView = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setTheView", r"(Ljava/util/HashMap;)V");

  /// from: public final void setTheView(java.util.HashMap hashMap)
  void setTheView(
    jni.JObject hashMap,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTheView,
        jni.JniCallType.voidType, [hashMap.reference]).check();
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory MainActivity_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return MainActivity_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $MainActivity_CompanionType
    extends jni.JObjType<MainActivity_Companion> {
  const $MainActivity_CompanionType();

  @override
  String get signature => r"Lcom/example/webview_demo/MainActivity$Companion;";

  @override
  MainActivity_Companion fromRef(jni.JObjectPtr ref) =>
      MainActivity_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MainActivity_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MainActivity_CompanionType) &&
        other is $MainActivity_CompanionType;
  }
}

/// from: com.example.webview_demo.MainActivity
class MainActivity extends jni.JObject {
  @override
  late final jni.JObjType<MainActivity> $type = type;

  MainActivity.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/example/webview_demo/MainActivity");

  /// The type which includes information such as the signature of this class.
  static const type = $MainActivityType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lcom/example/webview_demo/MainActivity$Companion;",
  );

  /// from: static public final com.example.webview_demo.MainActivity$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static MainActivity_Companion get Companion =>
      const $MainActivity_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_theView = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"theView",
    r"Ljava/util/HashMap;",
  );

  /// from: static public java.util.HashMap theView
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get theView => const jni.JObjectType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_theView, jni.JniCallType.objectType)
      .object);

  /// from: static public java.util.HashMap theView
  /// The returned object must be released after use, by calling the [release] method.
  static set theView(jni.JObject value) => jni.Jni.env
      .SetStaticObjectField(_class.reference, _id_theView, value.reference);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MainActivity() {
    return MainActivity.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_configureFlutterEngine = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"configureFlutterEngine",
      r"(Lio/flutter/embedding/engine/FlutterEngine;)V");

  /// from: public void configureFlutterEngine(io.flutter.embedding.engine.FlutterEngine flutterEngine)
  void configureFlutterEngine(
    FlutterEngine flutterEngine,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_configureFlutterEngine,
        jni.JniCallType.voidType,
        [flutterEngine.reference]).check();
  }

  static final _id_getTheView = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"getTheView", r"()Ljava/util/HashMap;");

  /// from: static public final java.util.HashMap getTheView()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getTheView() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getTheView,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setTheView = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"setTheView", r"(Ljava/util/HashMap;)V");

  /// from: static public final void setTheView(java.util.HashMap hashMap)
  static void setTheView(
    jni.JObject hashMap,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_setTheView, jni.JniCallType.voidType, [hashMap.reference]).check();
  }
}

final class $MainActivityType extends jni.JObjType<MainActivity> {
  const $MainActivityType();

  @override
  String get signature => r"Lcom/example/webview_demo/MainActivity;";

  @override
  MainActivity fromRef(jni.JObjectPtr ref) => MainActivity.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MainActivityType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MainActivityType) &&
        other is $MainActivityType;
  }
}

/// from: android.view.View$AccessibilityDelegate
class View_AccessibilityDelegate extends jni.JObject {
  @override
  late final jni.JObjType<View_AccessibilityDelegate> $type = type;

  View_AccessibilityDelegate.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$AccessibilityDelegate");

  /// The type which includes information such as the signature of this class.
  static const type = $View_AccessibilityDelegateType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory View_AccessibilityDelegate() {
    return View_AccessibilityDelegate.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_sendAccessibilityEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sendAccessibilityEvent", r"(Landroid/view/View;I)V");

  /// from: public void sendAccessibilityEvent(android.view.View view, int i)
  void sendAccessibilityEvent(
    View view,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sendAccessibilityEvent,
        jni.JniCallType.voidType,
        [view.reference, jni.JValueInt(i)]).check();
  }

  static final _id_performAccessibilityAction = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"performAccessibilityAction",
      r"(Landroid/view/View;ILandroid/os/Bundle;)Z");

  /// from: public boolean performAccessibilityAction(android.view.View view, int i, android.os.Bundle bundle)
  bool performAccessibilityAction(
    View view,
    int i,
    jni.JObject bundle,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performAccessibilityAction,
        jni.JniCallType.booleanType,
        [view.reference, jni.JValueInt(i), bundle.reference]).boolean;
  }

  static final _id_sendAccessibilityEventUnchecked = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sendAccessibilityEventUnchecked",
          r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void sendAccessibilityEventUnchecked(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void sendAccessibilityEventUnchecked(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sendAccessibilityEventUnchecked,
        jni.JniCallType.voidType,
        [view.reference, accessibilityEvent.reference]).check();
  }

  static final _id_dispatchPopulateAccessibilityEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchPopulateAccessibilityEvent",
          r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool dispatchPopulateAccessibilityEvent(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchPopulateAccessibilityEvent,
        jni.JniCallType.booleanType,
        [view.reference, accessibilityEvent.reference]).boolean;
  }

  static final _id_onPopulateAccessibilityEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onPopulateAccessibilityEvent",
      r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onPopulateAccessibilityEvent(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onPopulateAccessibilityEvent(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onPopulateAccessibilityEvent,
        jni.JniCallType.voidType,
        [view.reference, accessibilityEvent.reference]).check();
  }

  static final _id_onInitializeAccessibilityEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onInitializeAccessibilityEvent",
      r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onInitializeAccessibilityEvent(android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onInitializeAccessibilityEvent(
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onInitializeAccessibilityEvent,
        jni.JniCallType.voidType,
        [view.reference, accessibilityEvent.reference]).check();
  }

  static final _id_onInitializeAccessibilityNodeInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onInitializeAccessibilityNodeInfo",
          r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;)V");

  /// from: public void onInitializeAccessibilityNodeInfo(android.view.View view, android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo)
  void onInitializeAccessibilityNodeInfo(
    View view,
    jni.JObject accessibilityNodeInfo,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onInitializeAccessibilityNodeInfo,
        jni.JniCallType.voidType,
        [view.reference, accessibilityNodeInfo.reference]).check();
  }

  static final _id_addExtraDataToAccessibilityNodeInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"addExtraDataToAccessibilityNodeInfo",
          r"(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.View view, android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo, java.lang.String string, android.os.Bundle bundle)
  void addExtraDataToAccessibilityNodeInfo(
    View view,
    jni.JObject accessibilityNodeInfo,
    jni.JString string,
    jni.JObject bundle,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_addExtraDataToAccessibilityNodeInfo, jni.JniCallType.voidType, [
      view.reference,
      accessibilityNodeInfo.reference,
      string.reference,
      bundle.reference
    ]).check();
  }

  static final _id_onRequestSendAccessibilityEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onRequestSendAccessibilityEvent",
          r"(Landroid/view/ViewGroup;Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean onRequestSendAccessibilityEvent(android.view.ViewGroup viewGroup, android.view.View view, android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool onRequestSendAccessibilityEvent(
    jni.JObject viewGroup,
    View view,
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onRequestSendAccessibilityEvent, jni.JniCallType.booleanType, [
      viewGroup.reference,
      view.reference,
      accessibilityEvent.reference
    ]).boolean;
  }

  static final _id_getAccessibilityNodeProvider = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAccessibilityNodeProvider",
      r"(Landroid/view/View;)Landroid/view/accessibility/AccessibilityNodeProvider;");

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider(android.view.View view)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityNodeProvider(
    View view,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityNodeProvider,
        jni.JniCallType.objectType,
        [view.reference]).object);
  }
}

final class $View_AccessibilityDelegateType
    extends jni.JObjType<View_AccessibilityDelegate> {
  const $View_AccessibilityDelegateType();

  @override
  String get signature => r"Landroid/view/View$AccessibilityDelegate;";

  @override
  View_AccessibilityDelegate fromRef(jni.JObjectPtr ref) =>
      View_AccessibilityDelegate.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_AccessibilityDelegateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_AccessibilityDelegateType) &&
        other is $View_AccessibilityDelegateType;
  }
}

/// from: android.view.View$BaseSavedState
class View_BaseSavedState extends jni.JObject {
  @override
  late final jni.JObjType<View_BaseSavedState> $type = type;

  View_BaseSavedState.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"android/view/View$BaseSavedState");

  /// The type which includes information such as the signature of this class.
  static const type = $View_BaseSavedStateType();
  static final _id_CREATOR = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"CREATOR",
    r"Landroid/os/Parcelable$Creator;",
  );

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR => const jni.JObjectType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_CREATOR, jni.JniCallType.objectType)
      .object);

  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel parcel)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_BaseSavedState(
    jni.JObject parcel,
  ) {
    return View_BaseSavedState.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [parcel.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/os/Parcel;Ljava/lang/ClassLoader;)V");

  /// from: public void <init>(android.os.Parcel parcel, java.lang.ClassLoader classLoader)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_BaseSavedState.new1(
    jni.JObject parcel,
    jni.JObject classLoader,
  ) {
    return View_BaseSavedState.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [parcel.reference, classLoader.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Landroid/os/Parcelable;)V");

  /// from: public void <init>(android.os.Parcelable parcelable)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_BaseSavedState.new2(
    jni.JObject parcelable,
  ) {
    return View_BaseSavedState.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new2, [parcelable.reference]).object);
  }

  static final _id_writeToParcel = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeToParcel", r"(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeToParcel,
        jni.JniCallType.voidType, [parcel.reference, jni.JValueInt(i)]).check();
  }
}

final class $View_BaseSavedStateType extends jni.JObjType<View_BaseSavedState> {
  const $View_BaseSavedStateType();

  @override
  String get signature => r"Landroid/view/View$BaseSavedState;";

  @override
  View_BaseSavedState fromRef(jni.JObjectPtr ref) =>
      View_BaseSavedState.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_BaseSavedStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_BaseSavedStateType) &&
        other is $View_BaseSavedStateType;
  }
}

/// from: android.view.View$DragShadowBuilder
class View_DragShadowBuilder extends jni.JObject {
  @override
  late final jni.JObjType<View_DragShadowBuilder> $type = type;

  View_DragShadowBuilder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$DragShadowBuilder");

  /// The type which includes information such as the signature of this class.
  static const type = $View_DragShadowBuilderType();
  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Landroid/view/View;)V");

  /// from: public void <init>(android.view.View view)
  /// The returned object must be released after use, by calling the [release] method.
  factory View_DragShadowBuilder(
    View view,
  ) {
    return View_DragShadowBuilder.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [view.reference]).object);
  }

  static final _id_new1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory View_DragShadowBuilder.new1() {
    return View_DragShadowBuilder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new1, []).object);
  }

  static final _id_getView = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getView", r"()Landroid/view/View;");

  /// from: public final android.view.View getView()
  /// The returned object must be released after use, by calling the [release] method.
  View getView() {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getView, jni.JniCallType.objectType, []).object);
  }

  static final _id_onProvideShadowMetrics = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onProvideShadowMetrics",
      r"(Landroid/graphics/Point;Landroid/graphics/Point;)V");

  /// from: public void onProvideShadowMetrics(android.graphics.Point point, android.graphics.Point point1)
  void onProvideShadowMetrics(
    jni.JObject point,
    jni.JObject point1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideShadowMetrics,
        jni.JniCallType.voidType,
        [point.reference, point1.reference]).check();
  }

  static final _id_onDrawShadow = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDrawShadow", r"(Landroid/graphics/Canvas;)V");

  /// from: public void onDrawShadow(android.graphics.Canvas canvas)
  void onDrawShadow(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDrawShadow,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }
}

final class $View_DragShadowBuilderType
    extends jni.JObjType<View_DragShadowBuilder> {
  const $View_DragShadowBuilderType();

  @override
  String get signature => r"Landroid/view/View$DragShadowBuilder;";

  @override
  View_DragShadowBuilder fromRef(jni.JObjectPtr ref) =>
      View_DragShadowBuilder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_DragShadowBuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_DragShadowBuilderType) &&
        other is $View_DragShadowBuilderType;
  }
}

/// from: android.view.View$MeasureSpec
class View_MeasureSpec extends jni.JObject {
  @override
  late final jni.JObjType<View_MeasureSpec> $type = type;

  View_MeasureSpec.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"android/view/View$MeasureSpec");

  /// The type which includes information such as the signature of this class.
  static const type = $View_MeasureSpecType();

  /// from: static public final int AT_MOST
  static const AT_MOST = -2147483648;

  /// from: static public final int EXACTLY
  static const EXACTLY = 1073741824;

  /// from: static public final int UNSPECIFIED
  static const UNSPECIFIED = 0;

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory View_MeasureSpec() {
    return View_MeasureSpec.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_makeMeasureSpec = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"makeMeasureSpec", r"(II)I");

  /// from: static public int makeMeasureSpec(int i, int i1)
  static int makeMeasureSpec(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_makeMeasureSpec,
        jni.JniCallType.intType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_getMode = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getMode", r"(I)I");

  /// from: static public int getMode(int i)
  static int getMode(
    int i,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_getMode, jni.JniCallType.intType, [jni.JValueInt(i)]).integer;
  }

  static final _id_getSize = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getSize", r"(I)I");

  /// from: static public int getSize(int i)
  static int getSize(
    int i,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_getSize, jni.JniCallType.intType, [jni.JValueInt(i)]).integer;
  }

  static final _id_toString1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"toString", r"(I)Ljava/lang/String;");

  /// from: static public java.lang.String toString(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString toString1(
    int i,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_toString1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }
}

final class $View_MeasureSpecType extends jni.JObjType<View_MeasureSpec> {
  const $View_MeasureSpecType();

  @override
  String get signature => r"Landroid/view/View$MeasureSpec;";

  @override
  View_MeasureSpec fromRef(jni.JObjectPtr ref) => View_MeasureSpec.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_MeasureSpecType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_MeasureSpecType) &&
        other is $View_MeasureSpecType;
  }
}

/// from: android.view.View$OnApplyWindowInsetsListener
class View_OnApplyWindowInsetsListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnApplyWindowInsetsListener> $type = type;

  View_OnApplyWindowInsetsListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnApplyWindowInsetsListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnApplyWindowInsetsListenerType();
  static final _id_onApplyWindowInsets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onApplyWindowInsets",
      r"(Landroid/view/View;Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public abstract android.view.WindowInsets onApplyWindowInsets(android.view.View view, android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onApplyWindowInsets(
    View view,
    jni.JObject windowInsets,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onApplyWindowInsets,
        jni.JniCallType.objectType,
        [view.reference, windowInsets.reference]).object);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnApplyWindowInsetsListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onApplyWindowInsets(Landroid/view/View;Landroid/view/WindowInsets;)Landroid/view/WindowInsets;") {
        final $r = _$impls[$p]!.onApplyWindowInsets(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnApplyWindowInsetsListener.implement(
    $View_OnApplyWindowInsetsListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnApplyWindowInsetsListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnApplyWindowInsetsListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnApplyWindowInsetsListenerImpl {
  factory $View_OnApplyWindowInsetsListenerImpl({
    required jni.JObject Function(View view, jni.JObject windowInsets)
        onApplyWindowInsets,
  }) = _$View_OnApplyWindowInsetsListenerImpl;

  jni.JObject onApplyWindowInsets(View view, jni.JObject windowInsets);
}

class _$View_OnApplyWindowInsetsListenerImpl
    implements $View_OnApplyWindowInsetsListenerImpl {
  _$View_OnApplyWindowInsetsListenerImpl({
    required jni.JObject Function(View view, jni.JObject windowInsets)
        onApplyWindowInsets,
  }) : _onApplyWindowInsets = onApplyWindowInsets;

  final jni.JObject Function(View view, jni.JObject windowInsets)
      _onApplyWindowInsets;

  jni.JObject onApplyWindowInsets(View view, jni.JObject windowInsets) {
    return _onApplyWindowInsets(view, windowInsets);
  }
}

final class $View_OnApplyWindowInsetsListenerType
    extends jni.JObjType<View_OnApplyWindowInsetsListener> {
  const $View_OnApplyWindowInsetsListenerType();

  @override
  String get signature => r"Landroid/view/View$OnApplyWindowInsetsListener;";

  @override
  View_OnApplyWindowInsetsListener fromRef(jni.JObjectPtr ref) =>
      View_OnApplyWindowInsetsListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnApplyWindowInsetsListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnApplyWindowInsetsListenerType) &&
        other is $View_OnApplyWindowInsetsListenerType;
  }
}

/// from: android.view.View$OnAttachStateChangeListener
class View_OnAttachStateChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnAttachStateChangeListener> $type = type;

  View_OnAttachStateChangeListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnAttachStateChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnAttachStateChangeListenerType();
  static final _id_onViewAttachedToWindow = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onViewAttachedToWindow", r"(Landroid/view/View;)V");

  /// from: public abstract void onViewAttachedToWindow(android.view.View view)
  void onViewAttachedToWindow(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onViewAttachedToWindow,
        jni.JniCallType.voidType,
        [view.reference]).check();
  }

  static final _id_onViewDetachedFromWindow = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onViewDetachedFromWindow", r"(Landroid/view/View;)V");

  /// from: public abstract void onViewDetachedFromWindow(android.view.View view)
  void onViewDetachedFromWindow(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onViewDetachedFromWindow,
        jni.JniCallType.voidType,
        [view.reference]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnAttachStateChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onViewAttachedToWindow(Landroid/view/View;)V") {
        _$impls[$p]!.onViewAttachedToWindow(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onViewDetachedFromWindow(Landroid/view/View;)V") {
        _$impls[$p]!.onViewDetachedFromWindow(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnAttachStateChangeListener.implement(
    $View_OnAttachStateChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnAttachStateChangeListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnAttachStateChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnAttachStateChangeListenerImpl {
  factory $View_OnAttachStateChangeListenerImpl({
    required void Function(View view) onViewAttachedToWindow,
    required void Function(View view) onViewDetachedFromWindow,
  }) = _$View_OnAttachStateChangeListenerImpl;

  void onViewAttachedToWindow(View view);
  void onViewDetachedFromWindow(View view);
}

class _$View_OnAttachStateChangeListenerImpl
    implements $View_OnAttachStateChangeListenerImpl {
  _$View_OnAttachStateChangeListenerImpl({
    required void Function(View view) onViewAttachedToWindow,
    required void Function(View view) onViewDetachedFromWindow,
  })  : _onViewAttachedToWindow = onViewAttachedToWindow,
        _onViewDetachedFromWindow = onViewDetachedFromWindow;

  final void Function(View view) _onViewAttachedToWindow;
  final void Function(View view) _onViewDetachedFromWindow;

  void onViewAttachedToWindow(View view) {
    return _onViewAttachedToWindow(view);
  }

  void onViewDetachedFromWindow(View view) {
    return _onViewDetachedFromWindow(view);
  }
}

final class $View_OnAttachStateChangeListenerType
    extends jni.JObjType<View_OnAttachStateChangeListener> {
  const $View_OnAttachStateChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnAttachStateChangeListener;";

  @override
  View_OnAttachStateChangeListener fromRef(jni.JObjectPtr ref) =>
      View_OnAttachStateChangeListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnAttachStateChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnAttachStateChangeListenerType) &&
        other is $View_OnAttachStateChangeListenerType;
  }
}

/// from: android.view.View$OnCapturedPointerListener
class View_OnCapturedPointerListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnCapturedPointerListener> $type = type;

  View_OnCapturedPointerListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnCapturedPointerListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnCapturedPointerListenerType();
  static final _id_onCapturedPointer = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onCapturedPointer",
      r"(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onCapturedPointer(android.view.View view, android.view.MotionEvent motionEvent)
  bool onCapturedPointer(
    View view,
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCapturedPointer,
        jni.JniCallType.booleanType,
        [view.reference, motionEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnCapturedPointerListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onCapturedPointer(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onCapturedPointer(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnCapturedPointerListener.implement(
    $View_OnCapturedPointerListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnCapturedPointerListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnCapturedPointerListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnCapturedPointerListenerImpl {
  factory $View_OnCapturedPointerListenerImpl({
    required bool Function(View view, jni.JObject motionEvent)
        onCapturedPointer,
  }) = _$View_OnCapturedPointerListenerImpl;

  bool onCapturedPointer(View view, jni.JObject motionEvent);
}

class _$View_OnCapturedPointerListenerImpl
    implements $View_OnCapturedPointerListenerImpl {
  _$View_OnCapturedPointerListenerImpl({
    required bool Function(View view, jni.JObject motionEvent)
        onCapturedPointer,
  }) : _onCapturedPointer = onCapturedPointer;

  final bool Function(View view, jni.JObject motionEvent) _onCapturedPointer;

  bool onCapturedPointer(View view, jni.JObject motionEvent) {
    return _onCapturedPointer(view, motionEvent);
  }
}

final class $View_OnCapturedPointerListenerType
    extends jni.JObjType<View_OnCapturedPointerListener> {
  const $View_OnCapturedPointerListenerType();

  @override
  String get signature => r"Landroid/view/View$OnCapturedPointerListener;";

  @override
  View_OnCapturedPointerListener fromRef(jni.JObjectPtr ref) =>
      View_OnCapturedPointerListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnCapturedPointerListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnCapturedPointerListenerType) &&
        other is $View_OnCapturedPointerListenerType;
  }
}

/// from: android.view.View$OnClickListener
class View_OnClickListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnClickListener> $type = type;

  View_OnClickListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnClickListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnClickListenerType();
  static final _id_onClick = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onClick", r"(Landroid/view/View;)V");

  /// from: public abstract void onClick(android.view.View view)
  void onClick(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onClick,
        jni.JniCallType.voidType, [view.reference]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onClick(Landroid/view/View;)V") {
        _$impls[$p]!.onClick(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnClickListener.implement(
    $View_OnClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnClickListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnClickListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnClickListenerImpl {
  factory $View_OnClickListenerImpl({
    required void Function(View view) onClick,
  }) = _$View_OnClickListenerImpl;

  void onClick(View view);
}

class _$View_OnClickListenerImpl implements $View_OnClickListenerImpl {
  _$View_OnClickListenerImpl({
    required void Function(View view) onClick,
  }) : _onClick = onClick;

  final void Function(View view) _onClick;

  void onClick(View view) {
    return _onClick(view);
  }
}

final class $View_OnClickListenerType
    extends jni.JObjType<View_OnClickListener> {
  const $View_OnClickListenerType();

  @override
  String get signature => r"Landroid/view/View$OnClickListener;";

  @override
  View_OnClickListener fromRef(jni.JObjectPtr ref) =>
      View_OnClickListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnClickListenerType) &&
        other is $View_OnClickListenerType;
  }
}

/// from: android.view.View$OnContextClickListener
class View_OnContextClickListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnContextClickListener> $type = type;

  View_OnContextClickListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnContextClickListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnContextClickListenerType();
  static final _id_onContextClick = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onContextClick", r"(Landroid/view/View;)Z");

  /// from: public abstract boolean onContextClick(android.view.View view)
  bool onContextClick(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onContextClick,
        jni.JniCallType.booleanType, [view.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnContextClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onContextClick(Landroid/view/View;)Z") {
        final $r = _$impls[$p]!.onContextClick(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnContextClickListener.implement(
    $View_OnContextClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnContextClickListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnContextClickListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnContextClickListenerImpl {
  factory $View_OnContextClickListenerImpl({
    required bool Function(View view) onContextClick,
  }) = _$View_OnContextClickListenerImpl;

  bool onContextClick(View view);
}

class _$View_OnContextClickListenerImpl
    implements $View_OnContextClickListenerImpl {
  _$View_OnContextClickListenerImpl({
    required bool Function(View view) onContextClick,
  }) : _onContextClick = onContextClick;

  final bool Function(View view) _onContextClick;

  bool onContextClick(View view) {
    return _onContextClick(view);
  }
}

final class $View_OnContextClickListenerType
    extends jni.JObjType<View_OnContextClickListener> {
  const $View_OnContextClickListenerType();

  @override
  String get signature => r"Landroid/view/View$OnContextClickListener;";

  @override
  View_OnContextClickListener fromRef(jni.JObjectPtr ref) =>
      View_OnContextClickListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnContextClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnContextClickListenerType) &&
        other is $View_OnContextClickListenerType;
  }
}

/// from: android.view.View$OnCreateContextMenuListener
class View_OnCreateContextMenuListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnCreateContextMenuListener> $type = type;

  View_OnCreateContextMenuListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnCreateContextMenuListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnCreateContextMenuListenerType();
  static final _id_onCreateContextMenu = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onCreateContextMenu",
      r"(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu$ContextMenuInfo;)V");

  /// from: public abstract void onCreateContextMenu(android.view.ContextMenu contextMenu, android.view.View view, android.view.ContextMenu$ContextMenuInfo contextMenuInfo)
  void onCreateContextMenu(
    jni.JObject contextMenu,
    View view,
    jni.JObject contextMenuInfo,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onCreateContextMenu, jni.JniCallType.voidType, [
      contextMenu.reference,
      view.reference,
      contextMenuInfo.reference
    ]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnCreateContextMenuListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onCreateContextMenu(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu$ContextMenuInfo;)V") {
        _$impls[$p]!.onCreateContextMenu(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
          $a[1].castTo(const $ViewType(), releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnCreateContextMenuListener.implement(
    $View_OnCreateContextMenuListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnCreateContextMenuListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnCreateContextMenuListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnCreateContextMenuListenerImpl {
  factory $View_OnCreateContextMenuListenerImpl({
    required void Function(
            jni.JObject contextMenu, View view, jni.JObject contextMenuInfo)
        onCreateContextMenu,
  }) = _$View_OnCreateContextMenuListenerImpl;

  void onCreateContextMenu(
      jni.JObject contextMenu, View view, jni.JObject contextMenuInfo);
}

class _$View_OnCreateContextMenuListenerImpl
    implements $View_OnCreateContextMenuListenerImpl {
  _$View_OnCreateContextMenuListenerImpl({
    required void Function(
            jni.JObject contextMenu, View view, jni.JObject contextMenuInfo)
        onCreateContextMenu,
  }) : _onCreateContextMenu = onCreateContextMenu;

  final void Function(
          jni.JObject contextMenu, View view, jni.JObject contextMenuInfo)
      _onCreateContextMenu;

  void onCreateContextMenu(
      jni.JObject contextMenu, View view, jni.JObject contextMenuInfo) {
    return _onCreateContextMenu(contextMenu, view, contextMenuInfo);
  }
}

final class $View_OnCreateContextMenuListenerType
    extends jni.JObjType<View_OnCreateContextMenuListener> {
  const $View_OnCreateContextMenuListenerType();

  @override
  String get signature => r"Landroid/view/View$OnCreateContextMenuListener;";

  @override
  View_OnCreateContextMenuListener fromRef(jni.JObjectPtr ref) =>
      View_OnCreateContextMenuListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnCreateContextMenuListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnCreateContextMenuListenerType) &&
        other is $View_OnCreateContextMenuListenerType;
  }
}

/// from: android.view.View$OnDragListener
class View_OnDragListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnDragListener> $type = type;

  View_OnDragListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"android/view/View$OnDragListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnDragListenerType();
  static final _id_onDrag = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"onDrag", r"(Landroid/view/View;Landroid/view/DragEvent;)Z");

  /// from: public abstract boolean onDrag(android.view.View view, android.view.DragEvent dragEvent)
  bool onDrag(
    View view,
    jni.JObject dragEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onDrag,
        jni.JniCallType.booleanType,
        [view.reference, dragEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnDragListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onDrag(Landroid/view/View;Landroid/view/DragEvent;)Z") {
        final $r = _$impls[$p]!.onDrag(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnDragListener.implement(
    $View_OnDragListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnDragListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnDragListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnDragListenerImpl {
  factory $View_OnDragListenerImpl({
    required bool Function(View view, jni.JObject dragEvent) onDrag,
  }) = _$View_OnDragListenerImpl;

  bool onDrag(View view, jni.JObject dragEvent);
}

class _$View_OnDragListenerImpl implements $View_OnDragListenerImpl {
  _$View_OnDragListenerImpl({
    required bool Function(View view, jni.JObject dragEvent) onDrag,
  }) : _onDrag = onDrag;

  final bool Function(View view, jni.JObject dragEvent) _onDrag;

  bool onDrag(View view, jni.JObject dragEvent) {
    return _onDrag(view, dragEvent);
  }
}

final class $View_OnDragListenerType extends jni.JObjType<View_OnDragListener> {
  const $View_OnDragListenerType();

  @override
  String get signature => r"Landroid/view/View$OnDragListener;";

  @override
  View_OnDragListener fromRef(jni.JObjectPtr ref) =>
      View_OnDragListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnDragListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnDragListenerType) &&
        other is $View_OnDragListenerType;
  }
}

/// from: android.view.View$OnFocusChangeListener
class View_OnFocusChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnFocusChangeListener> $type = type;

  View_OnFocusChangeListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnFocusChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnFocusChangeListenerType();
  static final _id_onFocusChange = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onFocusChange", r"(Landroid/view/View;Z)V");

  /// from: public abstract void onFocusChange(android.view.View view, boolean z)
  void onFocusChange(
    View view,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onFocusChange,
        jni.JniCallType.voidType, [view.reference, z ? 1 : 0]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnFocusChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFocusChange(Landroid/view/View;Z)V") {
        _$impls[$p]!.onFocusChange(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnFocusChangeListener.implement(
    $View_OnFocusChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnFocusChangeListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnFocusChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnFocusChangeListenerImpl {
  factory $View_OnFocusChangeListenerImpl({
    required void Function(View view, bool z) onFocusChange,
  }) = _$View_OnFocusChangeListenerImpl;

  void onFocusChange(View view, bool z);
}

class _$View_OnFocusChangeListenerImpl
    implements $View_OnFocusChangeListenerImpl {
  _$View_OnFocusChangeListenerImpl({
    required void Function(View view, bool z) onFocusChange,
  }) : _onFocusChange = onFocusChange;

  final void Function(View view, bool z) _onFocusChange;

  void onFocusChange(View view, bool z) {
    return _onFocusChange(view, z);
  }
}

final class $View_OnFocusChangeListenerType
    extends jni.JObjType<View_OnFocusChangeListener> {
  const $View_OnFocusChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnFocusChangeListener;";

  @override
  View_OnFocusChangeListener fromRef(jni.JObjectPtr ref) =>
      View_OnFocusChangeListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnFocusChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnFocusChangeListenerType) &&
        other is $View_OnFocusChangeListenerType;
  }
}

/// from: android.view.View$OnGenericMotionListener
class View_OnGenericMotionListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnGenericMotionListener> $type = type;

  View_OnGenericMotionListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnGenericMotionListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnGenericMotionListenerType();
  static final _id_onGenericMotion = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onGenericMotion",
      r"(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onGenericMotion(android.view.View view, android.view.MotionEvent motionEvent)
  bool onGenericMotion(
    View view,
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onGenericMotion,
        jni.JniCallType.booleanType,
        [view.reference, motionEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnGenericMotionListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onGenericMotion(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onGenericMotion(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnGenericMotionListener.implement(
    $View_OnGenericMotionListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnGenericMotionListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnGenericMotionListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnGenericMotionListenerImpl {
  factory $View_OnGenericMotionListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onGenericMotion,
  }) = _$View_OnGenericMotionListenerImpl;

  bool onGenericMotion(View view, jni.JObject motionEvent);
}

class _$View_OnGenericMotionListenerImpl
    implements $View_OnGenericMotionListenerImpl {
  _$View_OnGenericMotionListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onGenericMotion,
  }) : _onGenericMotion = onGenericMotion;

  final bool Function(View view, jni.JObject motionEvent) _onGenericMotion;

  bool onGenericMotion(View view, jni.JObject motionEvent) {
    return _onGenericMotion(view, motionEvent);
  }
}

final class $View_OnGenericMotionListenerType
    extends jni.JObjType<View_OnGenericMotionListener> {
  const $View_OnGenericMotionListenerType();

  @override
  String get signature => r"Landroid/view/View$OnGenericMotionListener;";

  @override
  View_OnGenericMotionListener fromRef(jni.JObjectPtr ref) =>
      View_OnGenericMotionListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnGenericMotionListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnGenericMotionListenerType) &&
        other is $View_OnGenericMotionListenerType;
  }
}

/// from: android.view.View$OnHoverListener
class View_OnHoverListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnHoverListener> $type = type;

  View_OnHoverListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnHoverListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnHoverListenerType();
  static final _id_onHover = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"onHover", r"(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onHover(android.view.View view, android.view.MotionEvent motionEvent)
  bool onHover(
    View view,
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onHover,
        jni.JniCallType.booleanType,
        [view.reference, motionEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnHoverListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onHover(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onHover(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnHoverListener.implement(
    $View_OnHoverListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnHoverListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnHoverListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnHoverListenerImpl {
  factory $View_OnHoverListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onHover,
  }) = _$View_OnHoverListenerImpl;

  bool onHover(View view, jni.JObject motionEvent);
}

class _$View_OnHoverListenerImpl implements $View_OnHoverListenerImpl {
  _$View_OnHoverListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onHover,
  }) : _onHover = onHover;

  final bool Function(View view, jni.JObject motionEvent) _onHover;

  bool onHover(View view, jni.JObject motionEvent) {
    return _onHover(view, motionEvent);
  }
}

final class $View_OnHoverListenerType
    extends jni.JObjType<View_OnHoverListener> {
  const $View_OnHoverListenerType();

  @override
  String get signature => r"Landroid/view/View$OnHoverListener;";

  @override
  View_OnHoverListener fromRef(jni.JObjectPtr ref) =>
      View_OnHoverListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnHoverListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnHoverListenerType) &&
        other is $View_OnHoverListenerType;
  }
}

/// from: android.view.View$OnKeyListener
class View_OnKeyListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnKeyListener> $type = type;

  View_OnKeyListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"android/view/View$OnKeyListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnKeyListenerType();
  static final _id_onKey = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"onKey", r"(Landroid/view/View;ILandroid/view/KeyEvent;)Z");

  /// from: public abstract boolean onKey(android.view.View view, int i, android.view.KeyEvent keyEvent)
  bool onKey(
    View view,
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKey,
        jni.JniCallType.booleanType,
        [view.reference, jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnKeyListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onKey(Landroid/view/View;ILandroid/view/KeyEvent;)Z") {
        final $r = _$impls[$p]!.onKey(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnKeyListener.implement(
    $View_OnKeyListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnKeyListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnKeyListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnKeyListenerImpl {
  factory $View_OnKeyListenerImpl({
    required bool Function(View view, int i, jni.JObject keyEvent) onKey,
  }) = _$View_OnKeyListenerImpl;

  bool onKey(View view, int i, jni.JObject keyEvent);
}

class _$View_OnKeyListenerImpl implements $View_OnKeyListenerImpl {
  _$View_OnKeyListenerImpl({
    required bool Function(View view, int i, jni.JObject keyEvent) onKey,
  }) : _onKey = onKey;

  final bool Function(View view, int i, jni.JObject keyEvent) _onKey;

  bool onKey(View view, int i, jni.JObject keyEvent) {
    return _onKey(view, i, keyEvent);
  }
}

final class $View_OnKeyListenerType extends jni.JObjType<View_OnKeyListener> {
  const $View_OnKeyListenerType();

  @override
  String get signature => r"Landroid/view/View$OnKeyListener;";

  @override
  View_OnKeyListener fromRef(jni.JObjectPtr ref) =>
      View_OnKeyListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnKeyListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnKeyListenerType) &&
        other is $View_OnKeyListenerType;
  }
}

/// from: android.view.View$OnLayoutChangeListener
class View_OnLayoutChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnLayoutChangeListener> $type = type;

  View_OnLayoutChangeListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnLayoutChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnLayoutChangeListenerType();
  static final _id_onLayoutChange = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onLayoutChange", r"(Landroid/view/View;IIIIIIII)V");

  /// from: public abstract void onLayoutChange(android.view.View view, int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
  void onLayoutChange(
    View view,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onLayoutChange, jni.JniCallType.voidType, [
      view.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3),
      jni.JValueInt(i4),
      jni.JValueInt(i5),
      jni.JValueInt(i6),
      jni.JValueInt(i7)
    ]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnLayoutChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onLayoutChange(Landroid/view/View;IIIIIIII)V") {
        _$impls[$p]!.onLayoutChange(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[8]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnLayoutChangeListener.implement(
    $View_OnLayoutChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnLayoutChangeListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnLayoutChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnLayoutChangeListenerImpl {
  factory $View_OnLayoutChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3, int i4,
            int i5, int i6, int i7)
        onLayoutChange,
  }) = _$View_OnLayoutChangeListenerImpl;

  void onLayoutChange(
      View view, int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7);
}

class _$View_OnLayoutChangeListenerImpl
    implements $View_OnLayoutChangeListenerImpl {
  _$View_OnLayoutChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3, int i4,
            int i5, int i6, int i7)
        onLayoutChange,
  }) : _onLayoutChange = onLayoutChange;

  final void Function(View view, int i, int i1, int i2, int i3, int i4, int i5,
      int i6, int i7) _onLayoutChange;

  void onLayoutChange(View view, int i, int i1, int i2, int i3, int i4, int i5,
      int i6, int i7) {
    return _onLayoutChange(view, i, i1, i2, i3, i4, i5, i6, i7);
  }
}

final class $View_OnLayoutChangeListenerType
    extends jni.JObjType<View_OnLayoutChangeListener> {
  const $View_OnLayoutChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnLayoutChangeListener;";

  @override
  View_OnLayoutChangeListener fromRef(jni.JObjectPtr ref) =>
      View_OnLayoutChangeListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnLayoutChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnLayoutChangeListenerType) &&
        other is $View_OnLayoutChangeListenerType;
  }
}

/// from: android.view.View$OnLongClickListener
class View_OnLongClickListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnLongClickListener> $type = type;

  View_OnLongClickListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnLongClickListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnLongClickListenerType();
  static final _id_onLongClick = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onLongClick", r"(Landroid/view/View;)Z");

  /// from: public abstract boolean onLongClick(android.view.View view)
  bool onLongClick(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onLongClick,
        jni.JniCallType.booleanType, [view.reference]).boolean;
  }

  static final _id_onLongClickUseDefaultHapticFeedback = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onLongClickUseDefaultHapticFeedback",
          r"(Landroid/view/View;)Z");

  /// from: public boolean onLongClickUseDefaultHapticFeedback(android.view.View view)
  bool onLongClickUseDefaultHapticFeedback(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onLongClickUseDefaultHapticFeedback,
        jni.JniCallType.booleanType,
        [view.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnLongClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onLongClick(Landroid/view/View;)Z") {
        final $r = _$impls[$p]!.onLongClick(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
      if ($d == r"onLongClickUseDefaultHapticFeedback(Landroid/view/View;)Z") {
        final $r = _$impls[$p]!.onLongClickUseDefaultHapticFeedback(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnLongClickListener.implement(
    $View_OnLongClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnLongClickListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnLongClickListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnLongClickListenerImpl {
  factory $View_OnLongClickListenerImpl({
    required bool Function(View view) onLongClick,
    required bool Function(View view) onLongClickUseDefaultHapticFeedback,
  }) = _$View_OnLongClickListenerImpl;

  bool onLongClick(View view);
  bool onLongClickUseDefaultHapticFeedback(View view);
}

class _$View_OnLongClickListenerImpl implements $View_OnLongClickListenerImpl {
  _$View_OnLongClickListenerImpl({
    required bool Function(View view) onLongClick,
    required bool Function(View view) onLongClickUseDefaultHapticFeedback,
  })  : _onLongClick = onLongClick,
        _onLongClickUseDefaultHapticFeedback =
            onLongClickUseDefaultHapticFeedback;

  final bool Function(View view) _onLongClick;
  final bool Function(View view) _onLongClickUseDefaultHapticFeedback;

  bool onLongClick(View view) {
    return _onLongClick(view);
  }

  bool onLongClickUseDefaultHapticFeedback(View view) {
    return _onLongClickUseDefaultHapticFeedback(view);
  }
}

final class $View_OnLongClickListenerType
    extends jni.JObjType<View_OnLongClickListener> {
  const $View_OnLongClickListenerType();

  @override
  String get signature => r"Landroid/view/View$OnLongClickListener;";

  @override
  View_OnLongClickListener fromRef(jni.JObjectPtr ref) =>
      View_OnLongClickListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnLongClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnLongClickListenerType) &&
        other is $View_OnLongClickListenerType;
  }
}

/// from: android.view.View$OnScrollChangeListener
class View_OnScrollChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnScrollChangeListener> $type = type;

  View_OnScrollChangeListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnScrollChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnScrollChangeListenerType();
  static final _id_onScrollChange = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onScrollChange", r"(Landroid/view/View;IIII)V");

  /// from: public abstract void onScrollChange(android.view.View view, int i, int i1, int i2, int i3)
  void onScrollChange(
    View view,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onScrollChange, jni.JniCallType.voidType, [
      view.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnScrollChangeListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onScrollChange(Landroid/view/View;IIII)V") {
        _$impls[$p]!.onScrollChange(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnScrollChangeListener.implement(
    $View_OnScrollChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnScrollChangeListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnScrollChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnScrollChangeListenerImpl {
  factory $View_OnScrollChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3)
        onScrollChange,
  }) = _$View_OnScrollChangeListenerImpl;

  void onScrollChange(View view, int i, int i1, int i2, int i3);
}

class _$View_OnScrollChangeListenerImpl
    implements $View_OnScrollChangeListenerImpl {
  _$View_OnScrollChangeListenerImpl({
    required void Function(View view, int i, int i1, int i2, int i3)
        onScrollChange,
  }) : _onScrollChange = onScrollChange;

  final void Function(View view, int i, int i1, int i2, int i3) _onScrollChange;

  void onScrollChange(View view, int i, int i1, int i2, int i3) {
    return _onScrollChange(view, i, i1, i2, i3);
  }
}

final class $View_OnScrollChangeListenerType
    extends jni.JObjType<View_OnScrollChangeListener> {
  const $View_OnScrollChangeListenerType();

  @override
  String get signature => r"Landroid/view/View$OnScrollChangeListener;";

  @override
  View_OnScrollChangeListener fromRef(jni.JObjectPtr ref) =>
      View_OnScrollChangeListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnScrollChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnScrollChangeListenerType) &&
        other is $View_OnScrollChangeListenerType;
  }
}

/// from: android.view.View$OnSystemUiVisibilityChangeListener
class View_OnSystemUiVisibilityChangeListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnSystemUiVisibilityChangeListener> $type = type;

  View_OnSystemUiVisibilityChangeListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(
      r"android/view/View$OnSystemUiVisibilityChangeListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnSystemUiVisibilityChangeListenerType();
  static final _id_onSystemUiVisibilityChange = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onSystemUiVisibilityChange", r"(I)V");

  /// from: public abstract void onSystemUiVisibilityChange(int i)
  void onSystemUiVisibilityChange(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onSystemUiVisibilityChange,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnSystemUiVisibilityChangeListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onSystemUiVisibilityChange(I)V") {
        _$impls[$p]!.onSystemUiVisibilityChange(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnSystemUiVisibilityChangeListener.implement(
    $View_OnSystemUiVisibilityChangeListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnSystemUiVisibilityChangeListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnSystemUiVisibilityChangeListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnSystemUiVisibilityChangeListenerImpl {
  factory $View_OnSystemUiVisibilityChangeListenerImpl({
    required void Function(int i) onSystemUiVisibilityChange,
  }) = _$View_OnSystemUiVisibilityChangeListenerImpl;

  void onSystemUiVisibilityChange(int i);
}

class _$View_OnSystemUiVisibilityChangeListenerImpl
    implements $View_OnSystemUiVisibilityChangeListenerImpl {
  _$View_OnSystemUiVisibilityChangeListenerImpl({
    required void Function(int i) onSystemUiVisibilityChange,
  }) : _onSystemUiVisibilityChange = onSystemUiVisibilityChange;

  final void Function(int i) _onSystemUiVisibilityChange;

  void onSystemUiVisibilityChange(int i) {
    return _onSystemUiVisibilityChange(i);
  }
}

final class $View_OnSystemUiVisibilityChangeListenerType
    extends jni.JObjType<View_OnSystemUiVisibilityChangeListener> {
  const $View_OnSystemUiVisibilityChangeListenerType();

  @override
  String get signature =>
      r"Landroid/view/View$OnSystemUiVisibilityChangeListener;";

  @override
  View_OnSystemUiVisibilityChangeListener fromRef(jni.JObjectPtr ref) =>
      View_OnSystemUiVisibilityChangeListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnSystemUiVisibilityChangeListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($View_OnSystemUiVisibilityChangeListenerType) &&
        other is $View_OnSystemUiVisibilityChangeListenerType;
  }
}

/// from: android.view.View$OnTouchListener
class View_OnTouchListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnTouchListener> $type = type;

  View_OnTouchListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnTouchListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnTouchListenerType();
  static final _id_onTouch = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"onTouch", r"(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onTouch(android.view.View view, android.view.MotionEvent motionEvent)
  bool onTouch(
    View view,
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onTouch,
        jni.JniCallType.booleanType,
        [view.reference, motionEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnTouchListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onTouch(Landroid/view/View;Landroid/view/MotionEvent;)Z") {
        final $r = _$impls[$p]!.onTouch(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnTouchListener.implement(
    $View_OnTouchListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnTouchListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnTouchListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnTouchListenerImpl {
  factory $View_OnTouchListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onTouch,
  }) = _$View_OnTouchListenerImpl;

  bool onTouch(View view, jni.JObject motionEvent);
}

class _$View_OnTouchListenerImpl implements $View_OnTouchListenerImpl {
  _$View_OnTouchListenerImpl({
    required bool Function(View view, jni.JObject motionEvent) onTouch,
  }) : _onTouch = onTouch;

  final bool Function(View view, jni.JObject motionEvent) _onTouch;

  bool onTouch(View view, jni.JObject motionEvent) {
    return _onTouch(view, motionEvent);
  }
}

final class $View_OnTouchListenerType
    extends jni.JObjType<View_OnTouchListener> {
  const $View_OnTouchListenerType();

  @override
  String get signature => r"Landroid/view/View$OnTouchListener;";

  @override
  View_OnTouchListener fromRef(jni.JObjectPtr ref) =>
      View_OnTouchListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnTouchListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnTouchListenerType) &&
        other is $View_OnTouchListenerType;
  }
}

/// from: android.view.View$OnUnhandledKeyEventListener
class View_OnUnhandledKeyEventListener extends jni.JObject {
  @override
  late final jni.JObjType<View_OnUnhandledKeyEventListener> $type = type;

  View_OnUnhandledKeyEventListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/view/View$OnUnhandledKeyEventListener");

  /// The type which includes information such as the signature of this class.
  static const type = $View_OnUnhandledKeyEventListenerType();
  static final _id_onUnhandledKeyEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onUnhandledKeyEvent",
      r"(Landroid/view/View;Landroid/view/KeyEvent;)Z");

  /// from: public abstract boolean onUnhandledKeyEvent(android.view.View view, android.view.KeyEvent keyEvent)
  bool onUnhandledKeyEvent(
    View view,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onUnhandledKeyEvent,
        jni.JniCallType.booleanType,
        [view.reference, keyEvent.reference]).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $View_OnUnhandledKeyEventListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onUnhandledKeyEvent(Landroid/view/View;Landroid/view/KeyEvent;)Z") {
        final $r = _$impls[$p]!.onUnhandledKeyEvent(
          $a[0].castTo(const $ViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory View_OnUnhandledKeyEventListener.implement(
    $View_OnUnhandledKeyEventListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = View_OnUnhandledKeyEventListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.view.View$OnUnhandledKeyEventListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $View_OnUnhandledKeyEventListenerImpl {
  factory $View_OnUnhandledKeyEventListenerImpl({
    required bool Function(View view, jni.JObject keyEvent) onUnhandledKeyEvent,
  }) = _$View_OnUnhandledKeyEventListenerImpl;

  bool onUnhandledKeyEvent(View view, jni.JObject keyEvent);
}

class _$View_OnUnhandledKeyEventListenerImpl
    implements $View_OnUnhandledKeyEventListenerImpl {
  _$View_OnUnhandledKeyEventListenerImpl({
    required bool Function(View view, jni.JObject keyEvent) onUnhandledKeyEvent,
  }) : _onUnhandledKeyEvent = onUnhandledKeyEvent;

  final bool Function(View view, jni.JObject keyEvent) _onUnhandledKeyEvent;

  bool onUnhandledKeyEvent(View view, jni.JObject keyEvent) {
    return _onUnhandledKeyEvent(view, keyEvent);
  }
}

final class $View_OnUnhandledKeyEventListenerType
    extends jni.JObjType<View_OnUnhandledKeyEventListener> {
  const $View_OnUnhandledKeyEventListenerType();

  @override
  String get signature => r"Landroid/view/View$OnUnhandledKeyEventListener;";

  @override
  View_OnUnhandledKeyEventListener fromRef(jni.JObjectPtr ref) =>
      View_OnUnhandledKeyEventListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($View_OnUnhandledKeyEventListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($View_OnUnhandledKeyEventListenerType) &&
        other is $View_OnUnhandledKeyEventListenerType;
  }
}

/// from: android.view.View
class View extends jni.JObject {
  @override
  late final jni.JObjType<View> $type = type;

  View.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"android/view/View");

  /// The type which includes information such as the signature of this class.
  static const type = $ViewType();

  /// from: static public final int ACCESSIBILITY_DATA_SENSITIVE_AUTO
  static const ACCESSIBILITY_DATA_SENSITIVE_AUTO = 0;

  /// from: static public final int ACCESSIBILITY_DATA_SENSITIVE_NO
  static const ACCESSIBILITY_DATA_SENSITIVE_NO = 2;

  /// from: static public final int ACCESSIBILITY_DATA_SENSITIVE_YES
  static const ACCESSIBILITY_DATA_SENSITIVE_YES = 1;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_ASSERTIVE
  static const ACCESSIBILITY_LIVE_REGION_ASSERTIVE = 2;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_NONE
  static const ACCESSIBILITY_LIVE_REGION_NONE = 0;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_POLITE
  static const ACCESSIBILITY_LIVE_REGION_POLITE = 1;

  static final _id_ALPHA = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ALPHA",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ALPHA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ALPHA => const jni.JObjectType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_ALPHA, jni.JniCallType.objectType)
      .object);

  /// from: static public final int AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  static const AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS = 1;

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE =
      r"""creditCardExpirationDate""";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY =
      r"""creditCardExpirationDay""";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH =
      r"""creditCardExpirationMonth""";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR =
      r"""creditCardExpirationYear""";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_NUMBER
  static const AUTOFILL_HINT_CREDIT_CARD_NUMBER = r"""creditCardNumber""";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE
  static const AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE =
      r"""creditCardSecurityCode""";

  /// from: static public final java.lang.String AUTOFILL_HINT_EMAIL_ADDRESS
  static const AUTOFILL_HINT_EMAIL_ADDRESS = r"""emailAddress""";

  /// from: static public final java.lang.String AUTOFILL_HINT_NAME
  static const AUTOFILL_HINT_NAME = r"""name""";

  /// from: static public final java.lang.String AUTOFILL_HINT_PASSWORD
  static const AUTOFILL_HINT_PASSWORD = r"""password""";

  /// from: static public final java.lang.String AUTOFILL_HINT_PHONE
  static const AUTOFILL_HINT_PHONE = r"""phone""";

  /// from: static public final java.lang.String AUTOFILL_HINT_POSTAL_ADDRESS
  static const AUTOFILL_HINT_POSTAL_ADDRESS = r"""postalAddress""";

  /// from: static public final java.lang.String AUTOFILL_HINT_POSTAL_CODE
  static const AUTOFILL_HINT_POSTAL_CODE = r"""postalCode""";

  /// from: static public final java.lang.String AUTOFILL_HINT_USERNAME
  static const AUTOFILL_HINT_USERNAME = r"""username""";

  /// from: static public final int AUTOFILL_TYPE_DATE
  static const AUTOFILL_TYPE_DATE = 4;

  /// from: static public final int AUTOFILL_TYPE_LIST
  static const AUTOFILL_TYPE_LIST = 3;

  /// from: static public final int AUTOFILL_TYPE_NONE
  static const AUTOFILL_TYPE_NONE = 0;

  /// from: static public final int AUTOFILL_TYPE_TEXT
  static const AUTOFILL_TYPE_TEXT = 1;

  /// from: static public final int AUTOFILL_TYPE_TOGGLE
  static const AUTOFILL_TYPE_TOGGLE = 2;

  /// from: static public final int DRAG_FLAG_ACCESSIBILITY_ACTION
  static const DRAG_FLAG_ACCESSIBILITY_ACTION = 1024;

  /// from: static public final int DRAG_FLAG_GLOBAL
  static const DRAG_FLAG_GLOBAL = 256;

  /// from: static public final int DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION = 64;

  /// from: static public final int DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION = 128;

  /// from: static public final int DRAG_FLAG_GLOBAL_URI_READ
  static const DRAG_FLAG_GLOBAL_URI_READ = 1;

  /// from: static public final int DRAG_FLAG_GLOBAL_URI_WRITE
  static const DRAG_FLAG_GLOBAL_URI_WRITE = 2;

  /// from: static public final int DRAG_FLAG_OPAQUE
  static const DRAG_FLAG_OPAQUE = 512;

  /// from: static public final int DRAWING_CACHE_QUALITY_AUTO
  static const DRAWING_CACHE_QUALITY_AUTO = 0;

  /// from: static public final int DRAWING_CACHE_QUALITY_HIGH
  static const DRAWING_CACHE_QUALITY_HIGH = 1048576;

  /// from: static public final int DRAWING_CACHE_QUALITY_LOW
  static const DRAWING_CACHE_QUALITY_LOW = 524288;

  static final _id_EMPTY_STATE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"EMPTY_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] EMPTY_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get EMPTY_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_EMPTY_STATE_SET, jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_FOCUSED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_FOCUSED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_ENABLED_FOCUSED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
              .getStaticField(
                  _class.reference,
                  _id_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
                  jni.JniCallType.objectType)
              .object);

  static final _id_ENABLED_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_ENABLED_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_ENABLED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_STATE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_ENABLED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_ENABLED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ENABLED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] ENABLED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get ENABLED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference,
              _id_ENABLED_WINDOW_FOCUSED_STATE_SET, jni.JniCallType.objectType)
          .object);

  /// from: static public final int FIND_VIEWS_WITH_CONTENT_DESCRIPTION
  static const FIND_VIEWS_WITH_CONTENT_DESCRIPTION = 2;

  /// from: static public final int FIND_VIEWS_WITH_TEXT
  static const FIND_VIEWS_WITH_TEXT = 1;

  /// from: static public final int FOCUSABLE
  static const FOCUSABLE = 1;

  /// from: static public final int FOCUSABLES_ALL
  static const FOCUSABLES_ALL = 0;

  /// from: static public final int FOCUSABLES_TOUCH_MODE
  static const FOCUSABLES_TOUCH_MODE = 1;

  /// from: static public final int FOCUSABLE_AUTO
  static const FOCUSABLE_AUTO = 16;

  static final _id_FOCUSED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_FOCUSED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_FOCUSED_STATE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference,
              _id_FOCUSED_WINDOW_FOCUSED_STATE_SET, jni.JniCallType.objectType)
          .object);

  /// from: static public final int FOCUS_BACKWARD
  static const FOCUS_BACKWARD = 1;

  /// from: static public final int FOCUS_DOWN
  static const FOCUS_DOWN = 130;

  /// from: static public final int FOCUS_FORWARD
  static const FOCUS_FORWARD = 2;

  /// from: static public final int FOCUS_LEFT
  static const FOCUS_LEFT = 17;

  /// from: static public final int FOCUS_RIGHT
  static const FOCUS_RIGHT = 66;

  /// from: static public final int FOCUS_UP
  static const FOCUS_UP = 33;

  /// from: static public final int GONE
  static const GONE = 8;

  /// from: static public final int HAPTIC_FEEDBACK_ENABLED
  static const HAPTIC_FEEDBACK_ENABLED = 268435456;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_AUTO
  static const IMPORTANT_FOR_ACCESSIBILITY_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_NO
  static const IMPORTANT_FOR_ACCESSIBILITY_NO = 2;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
  static const IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS = 4;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_YES
  static const IMPORTANT_FOR_ACCESSIBILITY_YES = 1;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_AUTO
  static const IMPORTANT_FOR_AUTOFILL_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_NO
  static const IMPORTANT_FOR_AUTOFILL_NO = 2;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS = 8;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_YES
  static const IMPORTANT_FOR_AUTOFILL_YES = 1;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_AUTO
  static const IMPORTANT_FOR_CONTENT_CAPTURE_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_NO
  static const IMPORTANT_FOR_CONTENT_CAPTURE_NO = 2;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_NO_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_CONTENT_CAPTURE_NO_EXCLUDE_DESCENDANTS = 8;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_YES
  static const IMPORTANT_FOR_CONTENT_CAPTURE_YES = 1;

  /// from: static public final int IMPORTANT_FOR_CONTENT_CAPTURE_YES_EXCLUDE_DESCENDANTS
  static const IMPORTANT_FOR_CONTENT_CAPTURE_YES_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int INVISIBLE
  static const INVISIBLE = 4;

  /// from: static public final int KEEP_SCREEN_ON
  static const KEEP_SCREEN_ON = 67108864;

  /// from: static public final int LAYER_TYPE_HARDWARE
  static const LAYER_TYPE_HARDWARE = 2;

  /// from: static public final int LAYER_TYPE_NONE
  static const LAYER_TYPE_NONE = 0;

  /// from: static public final int LAYER_TYPE_SOFTWARE
  static const LAYER_TYPE_SOFTWARE = 1;

  /// from: static public final int LAYOUT_DIRECTION_INHERIT
  static const LAYOUT_DIRECTION_INHERIT = 2;

  /// from: static public final int LAYOUT_DIRECTION_LOCALE
  static const LAYOUT_DIRECTION_LOCALE = 3;

  /// from: static public final int LAYOUT_DIRECTION_LTR
  static const LAYOUT_DIRECTION_LTR = 0;

  /// from: static public final int LAYOUT_DIRECTION_RTL
  static const LAYOUT_DIRECTION_RTL = 1;

  /// from: static public final int MEASURED_HEIGHT_STATE_SHIFT
  static const MEASURED_HEIGHT_STATE_SHIFT = 16;

  /// from: static public final int MEASURED_SIZE_MASK
  static const MEASURED_SIZE_MASK = 16777215;

  /// from: static public final int MEASURED_STATE_MASK
  static const MEASURED_STATE_MASK = -16777216;

  /// from: static public final int MEASURED_STATE_TOO_SMALL
  static const MEASURED_STATE_TOO_SMALL = 16777216;

  /// from: static public final int NOT_FOCUSABLE
  static const NOT_FOCUSABLE = 0;

  /// from: static public final int NO_ID
  static const NO_ID = -1;

  /// from: static public final int OVER_SCROLL_ALWAYS
  static const OVER_SCROLL_ALWAYS = 0;

  /// from: static public final int OVER_SCROLL_IF_CONTENT_SCROLLS
  static const OVER_SCROLL_IF_CONTENT_SCROLLS = 1;

  /// from: static public final int OVER_SCROLL_NEVER
  static const OVER_SCROLL_NEVER = 2;

  static final _id_PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
              .getStaticField(
                  _class.reference,
                  _id_PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
                  jni.JniCallType.objectType)
              .object);

  static final _id_PRESSED_ENABLED_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference,
              _id_PRESSED_ENABLED_FOCUSED_STATE_SET, jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
          const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
              .getStaticField(
                  _class.reference,
                  _id_PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET,
                  jni.JniCallType.objectType)
              .object);

  static final _id_PRESSED_ENABLED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_PRESSED_ENABLED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
              .getStaticField(
                  _class.reference,
                  _id_PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET,
                  jni.JniCallType.objectType)
              .object);

  static final _id_PRESSED_ENABLED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PRESSED_ENABLED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_FOCUSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_FOCUSED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_PRESSED_FOCUSED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint>
      get PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
              .getStaticField(
                  _class.reference,
                  _id_PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
                  jni.JniCallType.objectType)
              .object);

  static final _id_PRESSED_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PRESSED_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_SELECTED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PRESSED_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference,
              _id_PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_STATE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PRESSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PRESSED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PRESSED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] PRESSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get PRESSED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference,
              _id_PRESSED_WINDOW_FOCUSED_STATE_SET, jni.JniCallType.objectType)
          .object);

  static final _id_ROTATION = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ROTATION",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ROTATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ROTATION =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_ROTATION, jni.JniCallType.objectType)
          .object);

  static final _id_ROTATION_X = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ROTATION_X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ROTATION_X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ROTATION_X =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_ROTATION_X, jni.JniCallType.objectType)
          .object);

  static final _id_ROTATION_Y = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"ROTATION_Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property ROTATION_Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get ROTATION_Y =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_ROTATION_Y, jni.JniCallType.objectType)
          .object);

  static final _id_SCALE_X = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"SCALE_X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property SCALE_X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get SCALE_X => const jni.JObjectType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_SCALE_X, jni.JniCallType.objectType)
      .object);

  static final _id_SCALE_Y = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"SCALE_Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property SCALE_Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get SCALE_Y => const jni.JObjectType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_SCALE_Y, jni.JniCallType.objectType)
      .object);

  /// from: static public final int SCREEN_STATE_OFF
  static const SCREEN_STATE_OFF = 0;

  /// from: static public final int SCREEN_STATE_ON
  static const SCREEN_STATE_ON = 1;

  /// from: static public final int SCROLLBARS_INSIDE_INSET
  static const SCROLLBARS_INSIDE_INSET = 16777216;

  /// from: static public final int SCROLLBARS_INSIDE_OVERLAY
  static const SCROLLBARS_INSIDE_OVERLAY = 0;

  /// from: static public final int SCROLLBARS_OUTSIDE_INSET
  static const SCROLLBARS_OUTSIDE_INSET = 50331648;

  /// from: static public final int SCROLLBARS_OUTSIDE_OVERLAY
  static const SCROLLBARS_OUTSIDE_OVERLAY = 33554432;

  /// from: static public final int SCROLLBAR_POSITION_DEFAULT
  static const SCROLLBAR_POSITION_DEFAULT = 0;

  /// from: static public final int SCROLLBAR_POSITION_LEFT
  static const SCROLLBAR_POSITION_LEFT = 1;

  /// from: static public final int SCROLLBAR_POSITION_RIGHT
  static const SCROLLBAR_POSITION_RIGHT = 2;

  /// from: static public final int SCROLL_AXIS_HORIZONTAL
  static const SCROLL_AXIS_HORIZONTAL = 1;

  /// from: static public final int SCROLL_AXIS_NONE
  static const SCROLL_AXIS_NONE = 0;

  /// from: static public final int SCROLL_AXIS_VERTICAL
  static const SCROLL_AXIS_VERTICAL = 2;

  /// from: static public final int SCROLL_CAPTURE_HINT_AUTO
  static const SCROLL_CAPTURE_HINT_AUTO = 0;

  /// from: static public final int SCROLL_CAPTURE_HINT_EXCLUDE
  static const SCROLL_CAPTURE_HINT_EXCLUDE = 1;

  /// from: static public final int SCROLL_CAPTURE_HINT_EXCLUDE_DESCENDANTS
  static const SCROLL_CAPTURE_HINT_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int SCROLL_CAPTURE_HINT_INCLUDE
  static const SCROLL_CAPTURE_HINT_INCLUDE = 2;

  /// from: static public final int SCROLL_INDICATOR_BOTTOM
  static const SCROLL_INDICATOR_BOTTOM = 2;

  /// from: static public final int SCROLL_INDICATOR_END
  static const SCROLL_INDICATOR_END = 32;

  /// from: static public final int SCROLL_INDICATOR_LEFT
  static const SCROLL_INDICATOR_LEFT = 4;

  /// from: static public final int SCROLL_INDICATOR_RIGHT
  static const SCROLL_INDICATOR_RIGHT = 8;

  /// from: static public final int SCROLL_INDICATOR_START
  static const SCROLL_INDICATOR_START = 16;

  /// from: static public final int SCROLL_INDICATOR_TOP
  static const SCROLL_INDICATOR_TOP = 1;

  static final _id_SELECTED_STATE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"SELECTED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] SELECTED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get SELECTED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_SELECTED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"SELECTED_WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get SELECTED_WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference,
              _id_SELECTED_WINDOW_FOCUSED_STATE_SET, jni.JniCallType.objectType)
          .object);

  /// from: static public final int SOUND_EFFECTS_ENABLED
  static const SOUND_EFFECTS_ENABLED = 134217728;

  /// from: static public final int STATUS_BAR_HIDDEN
  static const STATUS_BAR_HIDDEN = 1;

  /// from: static public final int STATUS_BAR_VISIBLE
  static const STATUS_BAR_VISIBLE = 0;

  /// from: static public final int SYSTEM_UI_FLAG_FULLSCREEN
  static const SYSTEM_UI_FLAG_FULLSCREEN = 4;

  /// from: static public final int SYSTEM_UI_FLAG_HIDE_NAVIGATION
  static const SYSTEM_UI_FLAG_HIDE_NAVIGATION = 2;

  /// from: static public final int SYSTEM_UI_FLAG_IMMERSIVE
  static const SYSTEM_UI_FLAG_IMMERSIVE = 2048;

  /// from: static public final int SYSTEM_UI_FLAG_IMMERSIVE_STICKY
  static const SYSTEM_UI_FLAG_IMMERSIVE_STICKY = 4096;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
  static const SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN = 1024;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
  static const SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION = 512;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_STABLE
  static const SYSTEM_UI_FLAG_LAYOUT_STABLE = 256;

  /// from: static public final int SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR
  static const SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR = 16;

  /// from: static public final int SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
  static const SYSTEM_UI_FLAG_LIGHT_STATUS_BAR = 8192;

  /// from: static public final int SYSTEM_UI_FLAG_LOW_PROFILE
  static const SYSTEM_UI_FLAG_LOW_PROFILE = 1;

  /// from: static public final int SYSTEM_UI_FLAG_VISIBLE
  static const SYSTEM_UI_FLAG_VISIBLE = 0;

  /// from: static public final int SYSTEM_UI_LAYOUT_FLAGS
  static const SYSTEM_UI_LAYOUT_FLAGS = 1536;

  /// from: static public final int TEXT_ALIGNMENT_CENTER
  static const TEXT_ALIGNMENT_CENTER = 4;

  /// from: static public final int TEXT_ALIGNMENT_GRAVITY
  static const TEXT_ALIGNMENT_GRAVITY = 1;

  /// from: static public final int TEXT_ALIGNMENT_INHERIT
  static const TEXT_ALIGNMENT_INHERIT = 0;

  /// from: static public final int TEXT_ALIGNMENT_TEXT_END
  static const TEXT_ALIGNMENT_TEXT_END = 3;

  /// from: static public final int TEXT_ALIGNMENT_TEXT_START
  static const TEXT_ALIGNMENT_TEXT_START = 2;

  /// from: static public final int TEXT_ALIGNMENT_VIEW_END
  static const TEXT_ALIGNMENT_VIEW_END = 6;

  /// from: static public final int TEXT_ALIGNMENT_VIEW_START
  static const TEXT_ALIGNMENT_VIEW_START = 5;

  /// from: static public final int TEXT_DIRECTION_ANY_RTL
  static const TEXT_DIRECTION_ANY_RTL = 2;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG
  static const TEXT_DIRECTION_FIRST_STRONG = 1;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG_LTR
  static const TEXT_DIRECTION_FIRST_STRONG_LTR = 6;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG_RTL
  static const TEXT_DIRECTION_FIRST_STRONG_RTL = 7;

  /// from: static public final int TEXT_DIRECTION_INHERIT
  static const TEXT_DIRECTION_INHERIT = 0;

  /// from: static public final int TEXT_DIRECTION_LOCALE
  static const TEXT_DIRECTION_LOCALE = 5;

  /// from: static public final int TEXT_DIRECTION_LTR
  static const TEXT_DIRECTION_LTR = 3;

  /// from: static public final int TEXT_DIRECTION_RTL
  static const TEXT_DIRECTION_RTL = 4;

  static final _id_TRANSLATION_X = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"TRANSLATION_X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property TRANSLATION_X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get TRANSLATION_X =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_TRANSLATION_X, jni.JniCallType.objectType)
          .object);

  static final _id_TRANSLATION_Y = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"TRANSLATION_Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property TRANSLATION_Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get TRANSLATION_Y =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_TRANSLATION_Y, jni.JniCallType.objectType)
          .object);

  static final _id_TRANSLATION_Z = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"TRANSLATION_Z",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property TRANSLATION_Z
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get TRANSLATION_Z =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_TRANSLATION_Z, jni.JniCallType.objectType)
          .object);

  /// from: static protected final java.lang.String VIEW_LOG_TAG
  static const VIEW_LOG_TAG = r"""View""";

  /// from: static public final int VISIBLE
  static const VISIBLE = 0;

  static final _id_WINDOW_FOCUSED_STATE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"WINDOW_FOCUSED_STATE_SET",
    r"[I",
  );

  /// from: static protected final int[] WINDOW_FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get WINDOW_FOCUSED_STATE_SET =>
      const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_WINDOW_FOCUSED_STATE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_X = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"X",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property X
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get X => const jni.JObjectType().fromRef(jni.Jni.accessors
      .getStaticField(_class.reference, _id_X, jni.JniCallType.objectType)
      .object);

  static final _id_Y = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Y",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property Y
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get Y => const jni.JObjectType().fromRef(jni.Jni.accessors
      .getStaticField(_class.reference, _id_Y, jni.JniCallType.objectType)
      .object);

  static final _id_Z = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Z",
    r"Landroid/util/Property;",
  );

  /// from: static public final android.util.Property Z
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get Z => const jni.JObjectType().fromRef(jni.Jni.accessors
      .getStaticField(_class.reference, _id_Z, jni.JniCallType.objectType)
      .object);

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory View(
    jni.JObject context,
  ) {
    return View.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [context.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  factory View.new1(
    jni.JObject context,
    jni.JObject attributeSet,
  ) {
    return View.fromRef(jni.Jni.accessors.newObjectWithArgs(_class.reference,
        _id_new1, [context.reference, attributeSet.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory View.new2(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
  ) {
    return View.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new2,
        [context.reference, attributeSet.reference, jni.JValueInt(i)]).object);
  }

  static final _id_new3 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory View.new3(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    int i1,
  ) {
    return View.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new3, [
      context.reference,
      attributeSet.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).object);
  }

  static final _id_getAttributeResolutionStack = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getAttributeResolutionStack", r"(I)[I");

  /// from: public int[] getAttributeResolutionStack(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getAttributeResolutionStack(
    int i,
  ) {
    return const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getAttributeResolutionStack,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_getAttributeSourceResourceMap = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getAttributeSourceResourceMap",
          r"()Ljava/util/Map;");

  /// from: public java.util.Map getAttributeSourceResourceMap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JInteger, jni.JInteger> getAttributeSourceResourceMap() {
    return const jni.JMapType(jni.JIntegerType(), jni.JIntegerType()).fromRef(
        jni.Jni.accessors.callMethodWithArgs(
            reference,
            _id_getAttributeSourceResourceMap,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getExplicitStyle = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getExplicitStyle", r"()I");

  /// from: public int getExplicitStyle()
  int getExplicitStyle() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getExplicitStyle, jni.JniCallType.intType, []).integer;
  }

  static final _id_isShowingLayoutBounds = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isShowingLayoutBounds", r"()Z");

  /// from: public final boolean isShowingLayoutBounds()
  bool isShowingLayoutBounds() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isShowingLayoutBounds, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_saveAttributeDataForStyleable = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"saveAttributeDataForStyleable",
      r"(Landroid/content/Context;[ILandroid/util/AttributeSet;Landroid/content/res/TypedArray;II)V");

  /// from: public final void saveAttributeDataForStyleable(android.content.Context context, int[] is, android.util.AttributeSet attributeSet, android.content.res.TypedArray typedArray, int i, int i1)
  void saveAttributeDataForStyleable(
    jni.JObject context,
    jni.JArray<jni.jint> is0,
    jni.JObject attributeSet,
    jni.JObject typedArray,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_saveAttributeDataForStyleable, jni.JniCallType.voidType, [
      context.reference,
      is0.reference,
      attributeSet.reference,
      typedArray.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_getVerticalFadingEdgeLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getVerticalFadingEdgeLength", r"()I");

  /// from: public int getVerticalFadingEdgeLength()
  int getVerticalFadingEdgeLength() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getVerticalFadingEdgeLength, jni.JniCallType.intType, []).integer;
  }

  static final _id_setFadingEdgeLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setFadingEdgeLength", r"(I)V");

  /// from: public void setFadingEdgeLength(int i)
  void setFadingEdgeLength(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setFadingEdgeLength,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getHorizontalFadingEdgeLength = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getHorizontalFadingEdgeLength", r"()I");

  /// from: public int getHorizontalFadingEdgeLength()
  int getHorizontalFadingEdgeLength() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getHorizontalFadingEdgeLength, jni.JniCallType.intType, []).integer;
  }

  static final _id_getVerticalScrollbarWidth = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getVerticalScrollbarWidth", r"()I");

  /// from: public int getVerticalScrollbarWidth()
  int getVerticalScrollbarWidth() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getVerticalScrollbarWidth, jni.JniCallType.intType, []).integer;
  }

  static final _id_getHorizontalScrollbarHeight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHorizontalScrollbarHeight", r"()I");

  /// from: protected int getHorizontalScrollbarHeight()
  int getHorizontalScrollbarHeight() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getHorizontalScrollbarHeight, jni.JniCallType.intType, []).integer;
  }

  static final _id_setVerticalScrollbarThumbDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setVerticalScrollbarThumbDrawable",
          r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setVerticalScrollbarThumbDrawable(android.graphics.drawable.Drawable drawable)
  void setVerticalScrollbarThumbDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setVerticalScrollbarThumbDrawable,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_setVerticalScrollbarTrackDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setVerticalScrollbarTrackDrawable",
          r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setVerticalScrollbarTrackDrawable(android.graphics.drawable.Drawable drawable)
  void setVerticalScrollbarTrackDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setVerticalScrollbarTrackDrawable,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_setHorizontalScrollbarThumbDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setHorizontalScrollbarThumbDrawable",
          r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setHorizontalScrollbarThumbDrawable(android.graphics.drawable.Drawable drawable)
  void setHorizontalScrollbarThumbDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHorizontalScrollbarThumbDrawable,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_setHorizontalScrollbarTrackDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setHorizontalScrollbarTrackDrawable",
          r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setHorizontalScrollbarTrackDrawable(android.graphics.drawable.Drawable drawable)
  void setHorizontalScrollbarTrackDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHorizontalScrollbarTrackDrawable,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_getVerticalScrollbarThumbDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getVerticalScrollbarThumbDrawable",
          r"()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getVerticalScrollbarThumbDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVerticalScrollbarThumbDrawable() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getVerticalScrollbarThumbDrawable,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getVerticalScrollbarTrackDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getVerticalScrollbarTrackDrawable",
          r"()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getVerticalScrollbarTrackDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVerticalScrollbarTrackDrawable() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getVerticalScrollbarTrackDrawable,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getHorizontalScrollbarThumbDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHorizontalScrollbarThumbDrawable",
          r"()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getHorizontalScrollbarThumbDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHorizontalScrollbarThumbDrawable() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHorizontalScrollbarThumbDrawable,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getHorizontalScrollbarTrackDrawable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHorizontalScrollbarTrackDrawable",
          r"()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getHorizontalScrollbarTrackDrawable()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHorizontalScrollbarTrackDrawable() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHorizontalScrollbarTrackDrawable,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setVerticalScrollbarPosition = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setVerticalScrollbarPosition", r"(I)V");

  /// from: public void setVerticalScrollbarPosition(int i)
  void setVerticalScrollbarPosition(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setVerticalScrollbarPosition,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getVerticalScrollbarPosition = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getVerticalScrollbarPosition", r"()I");

  /// from: public int getVerticalScrollbarPosition()
  int getVerticalScrollbarPosition() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getVerticalScrollbarPosition, jni.JniCallType.intType, []).integer;
  }

  static final _id_setScrollIndicators = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollIndicators", r"(I)V");

  /// from: public void setScrollIndicators(int i)
  void setScrollIndicators(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollIndicators,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setScrollIndicators1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollIndicators", r"(II)V");

  /// from: public void setScrollIndicators(int i, int i1)
  void setScrollIndicators1(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollIndicators1,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_getScrollIndicators = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getScrollIndicators", r"()I");

  /// from: public int getScrollIndicators()
  int getScrollIndicators() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getScrollIndicators, jni.JniCallType.intType, []).integer;
  }

  static final _id_setOnScrollChangeListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnScrollChangeListener",
      r"(Landroid/view/View$OnScrollChangeListener;)V");

  /// from: public void setOnScrollChangeListener(android.view.View$OnScrollChangeListener onScrollChangeListener)
  void setOnScrollChangeListener(
    View_OnScrollChangeListener onScrollChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnScrollChangeListener,
        jni.JniCallType.voidType,
        [onScrollChangeListener.reference]).check();
  }

  static final _id_setOnFocusChangeListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnFocusChangeListener",
      r"(Landroid/view/View$OnFocusChangeListener;)V");

  /// from: public void setOnFocusChangeListener(android.view.View$OnFocusChangeListener onFocusChangeListener)
  void setOnFocusChangeListener(
    View_OnFocusChangeListener onFocusChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnFocusChangeListener,
        jni.JniCallType.voidType,
        [onFocusChangeListener.reference]).check();
  }

  static final _id_addOnLayoutChangeListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addOnLayoutChangeListener",
      r"(Landroid/view/View$OnLayoutChangeListener;)V");

  /// from: public void addOnLayoutChangeListener(android.view.View$OnLayoutChangeListener onLayoutChangeListener)
  void addOnLayoutChangeListener(
    View_OnLayoutChangeListener onLayoutChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addOnLayoutChangeListener,
        jni.JniCallType.voidType,
        [onLayoutChangeListener.reference]).check();
  }

  static final _id_removeOnLayoutChangeListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"removeOnLayoutChangeListener",
          r"(Landroid/view/View$OnLayoutChangeListener;)V");

  /// from: public void removeOnLayoutChangeListener(android.view.View$OnLayoutChangeListener onLayoutChangeListener)
  void removeOnLayoutChangeListener(
    View_OnLayoutChangeListener onLayoutChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeOnLayoutChangeListener,
        jni.JniCallType.voidType,
        [onLayoutChangeListener.reference]).check();
  }

  static final _id_addOnAttachStateChangeListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"addOnAttachStateChangeListener",
          r"(Landroid/view/View$OnAttachStateChangeListener;)V");

  /// from: public void addOnAttachStateChangeListener(android.view.View$OnAttachStateChangeListener onAttachStateChangeListener)
  void addOnAttachStateChangeListener(
    View_OnAttachStateChangeListener onAttachStateChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addOnAttachStateChangeListener,
        jni.JniCallType.voidType,
        [onAttachStateChangeListener.reference]).check();
  }

  static final _id_removeOnAttachStateChangeListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"removeOnAttachStateChangeListener",
          r"(Landroid/view/View$OnAttachStateChangeListener;)V");

  /// from: public void removeOnAttachStateChangeListener(android.view.View$OnAttachStateChangeListener onAttachStateChangeListener)
  void removeOnAttachStateChangeListener(
    View_OnAttachStateChangeListener onAttachStateChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeOnAttachStateChangeListener,
        jni.JniCallType.voidType,
        [onAttachStateChangeListener.reference]).check();
  }

  static final _id_getOnFocusChangeListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getOnFocusChangeListener",
      r"()Landroid/view/View$OnFocusChangeListener;");

  /// from: public android.view.View$OnFocusChangeListener getOnFocusChangeListener()
  /// The returned object must be released after use, by calling the [release] method.
  View_OnFocusChangeListener getOnFocusChangeListener() {
    return const $View_OnFocusChangeListenerType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getOnFocusChangeListener,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setOnClickListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnClickListener",
      r"(Landroid/view/View$OnClickListener;)V");

  /// from: public void setOnClickListener(android.view.View$OnClickListener onClickListener)
  void setOnClickListener(
    View_OnClickListener onClickListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnClickListener,
        jni.JniCallType.voidType,
        [onClickListener.reference]).check();
  }

  static final _id_hasOnClickListeners = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasOnClickListeners", r"()Z");

  /// from: public boolean hasOnClickListeners()
  bool hasOnClickListeners() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasOnClickListeners, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setOnLongClickListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnLongClickListener",
      r"(Landroid/view/View$OnLongClickListener;)V");

  /// from: public void setOnLongClickListener(android.view.View$OnLongClickListener onLongClickListener)
  void setOnLongClickListener(
    View_OnLongClickListener onLongClickListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnLongClickListener,
        jni.JniCallType.voidType,
        [onLongClickListener.reference]).check();
  }

  static final _id_hasOnLongClickListeners = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasOnLongClickListeners", r"()Z");

  /// from: public boolean hasOnLongClickListeners()
  bool hasOnLongClickListeners() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasOnLongClickListeners, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setOnContextClickListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnContextClickListener",
      r"(Landroid/view/View$OnContextClickListener;)V");

  /// from: public void setOnContextClickListener(android.view.View$OnContextClickListener onContextClickListener)
  void setOnContextClickListener(
    View_OnContextClickListener onContextClickListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnContextClickListener,
        jni.JniCallType.voidType,
        [onContextClickListener.reference]).check();
  }

  static final _id_setOnCreateContextMenuListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOnCreateContextMenuListener",
          r"(Landroid/view/View$OnCreateContextMenuListener;)V");

  /// from: public void setOnCreateContextMenuListener(android.view.View$OnCreateContextMenuListener onCreateContextMenuListener)
  void setOnCreateContextMenuListener(
    View_OnCreateContextMenuListener onCreateContextMenuListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnCreateContextMenuListener,
        jni.JniCallType.voidType,
        [onCreateContextMenuListener.reference]).check();
  }

  static final _id_performClick = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performClick", r"()Z");

  /// from: public boolean performClick()
  bool performClick() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_performClick, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_callOnClick =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"callOnClick", r"()Z");

  /// from: public boolean callOnClick()
  bool callOnClick() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_callOnClick, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_performLongClick = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performLongClick", r"()Z");

  /// from: public boolean performLongClick()
  bool performLongClick() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_performLongClick,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_performLongClick1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performLongClick", r"(FF)Z");

  /// from: public boolean performLongClick(float f, float f1)
  bool performLongClick1(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performLongClick1,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).boolean;
  }

  static final _id_performContextClick = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performContextClick", r"(FF)Z");

  /// from: public boolean performContextClick(float f, float f1)
  bool performContextClick(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performContextClick,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).boolean;
  }

  static final _id_performContextClick1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performContextClick", r"()Z");

  /// from: public boolean performContextClick()
  bool performContextClick1() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_performContextClick1, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_showContextMenu = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"showContextMenu", r"()Z");

  /// from: public boolean showContextMenu()
  bool showContextMenu() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_showContextMenu,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_showContextMenu1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"showContextMenu", r"(FF)Z");

  /// from: public boolean showContextMenu(float f, float f1)
  bool showContextMenu1(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_showContextMenu1,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).boolean;
  }

  static final _id_startActionMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"startActionMode",
      r"(Landroid/view/ActionMode$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode$Callback callback)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startActionMode(
    jni.JObject callback,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_startActionMode,
        jni.JniCallType.objectType,
        [callback.reference]).object);
  }

  static final _id_startActionMode1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"startActionMode",
      r"(Landroid/view/ActionMode$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode$Callback callback, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startActionMode1(
    jni.JObject callback,
    int i,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_startActionMode1,
        jni.JniCallType.objectType,
        [callback.reference, jni.JValueInt(i)]).object);
  }

  static final _id_setOnKeyListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnKeyListener",
      r"(Landroid/view/View$OnKeyListener;)V");

  /// from: public void setOnKeyListener(android.view.View$OnKeyListener onKeyListener)
  void setOnKeyListener(
    View_OnKeyListener onKeyListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setOnKeyListener,
        jni.JniCallType.voidType, [onKeyListener.reference]).check();
  }

  static final _id_setOnTouchListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnTouchListener",
      r"(Landroid/view/View$OnTouchListener;)V");

  /// from: public void setOnTouchListener(android.view.View$OnTouchListener onTouchListener)
  void setOnTouchListener(
    View_OnTouchListener onTouchListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnTouchListener,
        jni.JniCallType.voidType,
        [onTouchListener.reference]).check();
  }

  static final _id_setOnGenericMotionListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnGenericMotionListener",
      r"(Landroid/view/View$OnGenericMotionListener;)V");

  /// from: public void setOnGenericMotionListener(android.view.View$OnGenericMotionListener onGenericMotionListener)
  void setOnGenericMotionListener(
    View_OnGenericMotionListener onGenericMotionListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnGenericMotionListener,
        jni.JniCallType.voidType,
        [onGenericMotionListener.reference]).check();
  }

  static final _id_setOnHoverListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnHoverListener",
      r"(Landroid/view/View$OnHoverListener;)V");

  /// from: public void setOnHoverListener(android.view.View$OnHoverListener onHoverListener)
  void setOnHoverListener(
    View_OnHoverListener onHoverListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnHoverListener,
        jni.JniCallType.voidType,
        [onHoverListener.reference]).check();
  }

  static final _id_setOnDragListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOnDragListener",
      r"(Landroid/view/View$OnDragListener;)V");

  /// from: public void setOnDragListener(android.view.View$OnDragListener onDragListener)
  void setOnDragListener(
    View_OnDragListener onDragListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnDragListener,
        jni.JniCallType.voidType,
        [onDragListener.reference]).check();
  }

  static final _id_setRevealOnFocusHint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setRevealOnFocusHint", r"(Z)V");

  /// from: public final void setRevealOnFocusHint(boolean z)
  void setRevealOnFocusHint(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setRevealOnFocusHint,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_getRevealOnFocusHint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRevealOnFocusHint", r"()Z");

  /// from: public final boolean getRevealOnFocusHint()
  bool getRevealOnFocusHint() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getRevealOnFocusHint, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_requestRectangleOnScreen = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"requestRectangleOnScreen",
      r"(Landroid/graphics/Rect;)Z");

  /// from: public boolean requestRectangleOnScreen(android.graphics.Rect rect)
  bool requestRectangleOnScreen(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestRectangleOnScreen,
        jni.JniCallType.booleanType,
        [rect.reference]).boolean;
  }

  static final _id_requestRectangleOnScreen1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"requestRectangleOnScreen",
      r"(Landroid/graphics/Rect;Z)Z");

  /// from: public boolean requestRectangleOnScreen(android.graphics.Rect rect, boolean z)
  bool requestRectangleOnScreen1(
    jni.JObject rect,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestRectangleOnScreen1,
        jni.JniCallType.booleanType,
        [rect.reference, z ? 1 : 0]).boolean;
  }

  static final _id_clearFocus =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"clearFocus", r"()V");

  /// from: public void clearFocus()
  void clearFocus() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearFocus, jni.JniCallType.voidType, []).check();
  }

  static final _id_hasFocus =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hasFocus", r"()Z");

  /// from: public boolean hasFocus()
  bool hasFocus() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasFocus, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_hasFocusable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasFocusable", r"()Z");

  /// from: public boolean hasFocusable()
  bool hasFocusable() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasFocusable, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_hasExplicitFocusable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasExplicitFocusable", r"()Z");

  /// from: public boolean hasExplicitFocusable()
  bool hasExplicitFocusable() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasExplicitFocusable, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_onFocusChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onFocusChanged", r"(ZILandroid/graphics/Rect;)V");

  /// from: protected void onFocusChanged(boolean z, int i, android.graphics.Rect rect)
  void onFocusChanged(
    bool z,
    int i,
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onFocusChanged,
        jni.JniCallType.voidType,
        [z ? 1 : 0, jni.JValueInt(i), rect.reference]).check();
  }

  static final _id_setAccessibilityPaneTitle = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setAccessibilityPaneTitle",
      r"(Ljava/lang/CharSequence;)V");

  /// from: public void setAccessibilityPaneTitle(java.lang.CharSequence charSequence)
  void setAccessibilityPaneTitle(
    jni.JObject charSequence,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityPaneTitle,
        jni.JniCallType.voidType,
        [charSequence.reference]).check();
  }

  static final _id_getAccessibilityPaneTitle = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAccessibilityPaneTitle",
      r"()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityPaneTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityPaneTitle() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityPaneTitle,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_sendAccessibilityEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sendAccessibilityEvent", r"(I)V");

  /// from: public void sendAccessibilityEvent(int i)
  void sendAccessibilityEvent(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sendAccessibilityEvent,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_announceForAccessibility = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"announceForAccessibility",
      r"(Ljava/lang/CharSequence;)V");

  /// from: public void announceForAccessibility(java.lang.CharSequence charSequence)
  void announceForAccessibility(
    jni.JObject charSequence,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_announceForAccessibility,
        jni.JniCallType.voidType,
        [charSequence.reference]).check();
  }

  static final _id_sendAccessibilityEventUnchecked = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sendAccessibilityEventUnchecked",
          r"(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void sendAccessibilityEventUnchecked(
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sendAccessibilityEventUnchecked,
        jni.JniCallType.voidType,
        [accessibilityEvent.reference]).check();
  }

  static final _id_dispatchPopulateAccessibilityEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchPopulateAccessibilityEvent",
          r"(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool dispatchPopulateAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchPopulateAccessibilityEvent,
        jni.JniCallType.booleanType,
        [accessibilityEvent.reference]).boolean;
  }

  static final _id_onPopulateAccessibilityEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onPopulateAccessibilityEvent",
          r"(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onPopulateAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onPopulateAccessibilityEvent,
        jni.JniCallType.voidType,
        [accessibilityEvent.reference]).check();
  }

  static final _id_onInitializeAccessibilityEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onInitializeAccessibilityEvent",
          r"(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  void onInitializeAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onInitializeAccessibilityEvent,
        jni.JniCallType.voidType,
        [accessibilityEvent.reference]).check();
  }

  static final _id_createAccessibilityNodeInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createAccessibilityNodeInfo",
          r"()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo createAccessibilityNodeInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createAccessibilityNodeInfo() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createAccessibilityNodeInfo,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onInitializeAccessibilityNodeInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onInitializeAccessibilityNodeInfo",
          r"(Landroid/view/accessibility/AccessibilityNodeInfo;)V");

  /// from: public void onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo)
  void onInitializeAccessibilityNodeInfo(
    jni.JObject accessibilityNodeInfo,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onInitializeAccessibilityNodeInfo,
        jni.JniCallType.voidType,
        [accessibilityNodeInfo.reference]).check();
  }

  static final _id_getAccessibilityClassName = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAccessibilityClassName",
      r"()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityClassName() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityClassName,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onProvideStructure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onProvideStructure",
      r"(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideStructure(android.view.ViewStructure viewStructure)
  void onProvideStructure(
    jni.JObject viewStructure,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference]).check();
  }

  static final _id_onProvideAutofillStructure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onProvideAutofillStructure",
      r"(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideAutofillStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideAutofillStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference, jni.JValueInt(i)]).check();
  }

  static final _id_onProvideContentCaptureStructure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onProvideContentCaptureStructure",
          r"(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideContentCaptureStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideContentCaptureStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideContentCaptureStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference, jni.JValueInt(i)]).check();
  }

  static final _id_onProvideVirtualStructure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onProvideVirtualStructure",
      r"(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideVirtualStructure(android.view.ViewStructure viewStructure)
  void onProvideVirtualStructure(
    jni.JObject viewStructure,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideVirtualStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference]).check();
  }

  static final _id_onProvideAutofillVirtualStructure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onProvideAutofillVirtualStructure",
          r"(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillVirtualStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideAutofillVirtualStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideAutofillVirtualStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference, jni.JValueInt(i)]).check();
  }

  static final _id_setOnReceiveContentListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOnReceiveContentListener",
          r"([Ljava/lang/String;Landroid/view/OnReceiveContentListener;)V");

  /// from: public void setOnReceiveContentListener(java.lang.String[] strings, android.view.OnReceiveContentListener onReceiveContentListener)
  void setOnReceiveContentListener(
    jni.JArray<jni.JString> strings,
    jni.JObject onReceiveContentListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnReceiveContentListener,
        jni.JniCallType.voidType,
        [strings.reference, onReceiveContentListener.reference]).check();
  }

  static final _id_performReceiveContent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"performReceiveContent",
      r"(Landroid/view/ContentInfo;)Landroid/view/ContentInfo;");

  /// from: public android.view.ContentInfo performReceiveContent(android.view.ContentInfo contentInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject performReceiveContent(
    jni.JObject contentInfo,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performReceiveContent,
        jni.JniCallType.objectType,
        [contentInfo.reference]).object);
  }

  static final _id_onReceiveContent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onReceiveContent",
      r"(Landroid/view/ContentInfo;)Landroid/view/ContentInfo;");

  /// from: public android.view.ContentInfo onReceiveContent(android.view.ContentInfo contentInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onReceiveContent(
    jni.JObject contentInfo,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onReceiveContent,
        jni.JniCallType.objectType,
        [contentInfo.reference]).object);
  }

  static final _id_getReceiveContentMimeTypes = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getReceiveContentMimeTypes",
      r"()[Ljava/lang/String;");

  /// from: public java.lang.String[] getReceiveContentMimeTypes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getReceiveContentMimeTypes() {
    return const jni.JArrayType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getReceiveContentMimeTypes,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_autofill = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"autofill", r"(Landroid/view/autofill/AutofillValue;)V");

  /// from: public void autofill(android.view.autofill.AutofillValue autofillValue)
  void autofill(
    jni.JObject autofillValue,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_autofill,
        jni.JniCallType.voidType, [autofillValue.reference]).check();
  }

  static final _id_autofill1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"autofill", r"(Landroid/util/SparseArray;)V");

  /// from: public void autofill(android.util.SparseArray sparseArray)
  void autofill1(
    jni.JObject sparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_autofill1,
        jni.JniCallType.voidType, [sparseArray.reference]).check();
  }

  static final _id_getAutofillId = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAutofillId",
      r"()Landroid/view/autofill/AutofillId;");

  /// from: public final android.view.autofill.AutofillId getAutofillId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAutofillId() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAutofillId, jni.JniCallType.objectType, []).object);
  }

  static final _id_setAutofillId = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setAutofillId",
      r"(Landroid/view/autofill/AutofillId;)V");

  /// from: public void setAutofillId(android.view.autofill.AutofillId autofillId)
  void setAutofillId(
    jni.JObject autofillId,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setAutofillId,
        jni.JniCallType.voidType, [autofillId.reference]).check();
  }

  static final _id_getAutofillType = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getAutofillType", r"()I");

  /// from: public int getAutofillType()
  int getAutofillType() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAutofillType, jni.JniCallType.intType, []).integer;
  }

  static final _id_getAutofillHints = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getAutofillHints", r"()[Ljava/lang/String;");

  /// from: public java.lang.String[] getAutofillHints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getAutofillHints() {
    return const jni.JArrayType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getAutofillHints,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getAutofillValue = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAutofillValue",
      r"()Landroid/view/autofill/AutofillValue;");

  /// from: public android.view.autofill.AutofillValue getAutofillValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAutofillValue() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAutofillValue,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getImportantForAutofill = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getImportantForAutofill", r"()I");

  /// from: public int getImportantForAutofill()
  int getImportantForAutofill() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getImportantForAutofill, jni.JniCallType.intType, []).integer;
  }

  static final _id_setImportantForAutofill = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setImportantForAutofill", r"(I)V");

  /// from: public void setImportantForAutofill(int i)
  void setImportantForAutofill(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setImportantForAutofill,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_isImportantForAutofill = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isImportantForAutofill", r"()Z");

  /// from: public final boolean isImportantForAutofill()
  bool isImportantForAutofill() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isImportantForAutofill, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getImportantForContentCapture = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getImportantForContentCapture", r"()I");

  /// from: public int getImportantForContentCapture()
  int getImportantForContentCapture() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getImportantForContentCapture, jni.JniCallType.intType, []).integer;
  }

  static final _id_setImportantForContentCapture = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setImportantForContentCapture", r"(I)V");

  /// from: public void setImportantForContentCapture(int i)
  void setImportantForContentCapture(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setImportantForContentCapture,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_isImportantForContentCapture = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isImportantForContentCapture", r"()Z");

  /// from: public final boolean isImportantForContentCapture()
  bool isImportantForContentCapture() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isImportantForContentCapture,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setContentCaptureSession = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setContentCaptureSession",
      r"(Landroid/view/contentcapture/ContentCaptureSession;)V");

  /// from: public void setContentCaptureSession(android.view.contentcapture.ContentCaptureSession contentCaptureSession)
  void setContentCaptureSession(
    jni.JObject contentCaptureSession,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setContentCaptureSession,
        jni.JniCallType.voidType,
        [contentCaptureSession.reference]).check();
  }

  static final _id_getContentCaptureSession = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getContentCaptureSession",
      r"()Landroid/view/contentcapture/ContentCaptureSession;");

  /// from: public final android.view.contentcapture.ContentCaptureSession getContentCaptureSession()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentCaptureSession() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getContentCaptureSession,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_dispatchProvideStructure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchProvideStructure",
      r"(Landroid/view/ViewStructure;)V");

  /// from: public void dispatchProvideStructure(android.view.ViewStructure viewStructure)
  void dispatchProvideStructure(
    jni.JObject viewStructure,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchProvideStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference]).check();
  }

  static final _id_dispatchProvideAutofillStructure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchProvideAutofillStructure",
          r"(Landroid/view/ViewStructure;I)V");

  /// from: public void dispatchProvideAutofillStructure(android.view.ViewStructure viewStructure, int i)
  void dispatchProvideAutofillStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchProvideAutofillStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference, jni.JValueInt(i)]).check();
  }

  static final _id_addExtraDataToAccessibilityNodeInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"addExtraDataToAccessibilityNodeInfo",
          r"(Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo accessibilityNodeInfo, java.lang.String string, android.os.Bundle bundle)
  void addExtraDataToAccessibilityNodeInfo(
    jni.JObject accessibilityNodeInfo,
    jni.JString string,
    jni.JObject bundle,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_addExtraDataToAccessibilityNodeInfo, jni.JniCallType.voidType, [
      accessibilityNodeInfo.reference,
      string.reference,
      bundle.reference
    ]).check();
  }

  static final _id_isVisibleToUserForAutofill = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isVisibleToUserForAutofill", r"(I)Z");

  /// from: public boolean isVisibleToUserForAutofill(int i)
  bool isVisibleToUserForAutofill(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isVisibleToUserForAutofill,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_getAccessibilityDelegate = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAccessibilityDelegate",
      r"()Landroid/view/View$AccessibilityDelegate;");

  /// from: public android.view.View$AccessibilityDelegate getAccessibilityDelegate()
  /// The returned object must be released after use, by calling the [release] method.
  View_AccessibilityDelegate getAccessibilityDelegate() {
    return const $View_AccessibilityDelegateType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getAccessibilityDelegate,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setAccessibilityDelegate = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setAccessibilityDelegate",
      r"(Landroid/view/View$AccessibilityDelegate;)V");

  /// from: public void setAccessibilityDelegate(android.view.View$AccessibilityDelegate accessibilityDelegate)
  void setAccessibilityDelegate(
    View_AccessibilityDelegate accessibilityDelegate,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityDelegate,
        jni.JniCallType.voidType,
        [accessibilityDelegate.reference]).check();
  }

  static final _id_getAccessibilityNodeProvider = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getAccessibilityNodeProvider",
          r"()Landroid/view/accessibility/AccessibilityNodeProvider;");

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityNodeProvider() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityNodeProvider,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getStateDescription = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getStateDescription", r"()Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence getStateDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getStateDescription() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getStateDescription,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getContentDescription = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getContentDescription",
      r"()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentDescription() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getContentDescription,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setStateDescription = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setStateDescription", r"(Ljava/lang/CharSequence;)V");

  /// from: public void setStateDescription(java.lang.CharSequence charSequence)
  void setStateDescription(
    jni.JObject charSequence,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setStateDescription,
        jni.JniCallType.voidType,
        [charSequence.reference]).check();
  }

  static final _id_setContentDescription = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setContentDescription",
      r"(Ljava/lang/CharSequence;)V");

  /// from: public void setContentDescription(java.lang.CharSequence charSequence)
  void setContentDescription(
    jni.JObject charSequence,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setContentDescription,
        jni.JniCallType.voidType,
        [charSequence.reference]).check();
  }

  static final _id_setAccessibilityTraversalBefore = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setAccessibilityTraversalBefore", r"(I)V");

  /// from: public void setAccessibilityTraversalBefore(int i)
  void setAccessibilityTraversalBefore(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityTraversalBefore,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getAccessibilityTraversalBefore = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getAccessibilityTraversalBefore", r"()I");

  /// from: public int getAccessibilityTraversalBefore()
  int getAccessibilityTraversalBefore() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityTraversalBefore,
        jni.JniCallType.intType, []).integer;
  }

  static final _id_setAccessibilityTraversalAfter = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setAccessibilityTraversalAfter", r"(I)V");

  /// from: public void setAccessibilityTraversalAfter(int i)
  void setAccessibilityTraversalAfter(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityTraversalAfter,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getAccessibilityTraversalAfter = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getAccessibilityTraversalAfter", r"()I");

  /// from: public int getAccessibilityTraversalAfter()
  int getAccessibilityTraversalAfter() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityTraversalAfter,
        jni.JniCallType.intType, []).integer;
  }

  static final _id_getLabelFor =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getLabelFor", r"()I");

  /// from: public int getLabelFor()
  int getLabelFor() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLabelFor, jni.JniCallType.intType, []).integer;
  }

  static final _id_setLabelFor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setLabelFor", r"(I)V");

  /// from: public void setLabelFor(int i)
  void setLabelFor(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLabelFor,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_isFocused =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isFocused", r"()Z");

  /// from: public boolean isFocused()
  bool isFocused() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isFocused, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_findFocus = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"findFocus", r"()Landroid/view/View;");

  /// from: public android.view.View findFocus()
  /// The returned object must be released after use, by calling the [release] method.
  View findFocus() {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_findFocus, jni.JniCallType.objectType, []).object);
  }

  static final _id_isScrollContainer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isScrollContainer", r"()Z");

  /// from: public boolean isScrollContainer()
  bool isScrollContainer() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isScrollContainer, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setScrollContainer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollContainer", r"(Z)V");

  /// from: public void setScrollContainer(boolean z)
  void setScrollContainer(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_setScrollContainer, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_getDrawingCacheQuality = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getDrawingCacheQuality", r"()I");

  /// from: public int getDrawingCacheQuality()
  int getDrawingCacheQuality() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getDrawingCacheQuality, jni.JniCallType.intType, []).integer;
  }

  static final _id_setDrawingCacheQuality = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setDrawingCacheQuality", r"(I)V");

  /// from: public void setDrawingCacheQuality(int i)
  void setDrawingCacheQuality(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDrawingCacheQuality,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getKeepScreenOn = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getKeepScreenOn", r"()Z");

  /// from: public boolean getKeepScreenOn()
  bool getKeepScreenOn() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getKeepScreenOn,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setKeepScreenOn = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setKeepScreenOn", r"(Z)V");

  /// from: public void setKeepScreenOn(boolean z)
  void setKeepScreenOn(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setKeepScreenOn,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_getNextFocusLeftId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNextFocusLeftId", r"()I");

  /// from: public int getNextFocusLeftId()
  int getNextFocusLeftId() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getNextFocusLeftId, jni.JniCallType.intType, []).integer;
  }

  static final _id_setNextFocusLeftId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNextFocusLeftId", r"(I)V");

  /// from: public void setNextFocusLeftId(int i)
  void setNextFocusLeftId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setNextFocusLeftId,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getNextFocusRightId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNextFocusRightId", r"()I");

  /// from: public int getNextFocusRightId()
  int getNextFocusRightId() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getNextFocusRightId, jni.JniCallType.intType, []).integer;
  }

  static final _id_setNextFocusRightId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNextFocusRightId", r"(I)V");

  /// from: public void setNextFocusRightId(int i)
  void setNextFocusRightId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setNextFocusRightId,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getNextFocusUpId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNextFocusUpId", r"()I");

  /// from: public int getNextFocusUpId()
  int getNextFocusUpId() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getNextFocusUpId, jni.JniCallType.intType, []).integer;
  }

  static final _id_setNextFocusUpId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNextFocusUpId", r"(I)V");

  /// from: public void setNextFocusUpId(int i)
  void setNextFocusUpId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setNextFocusUpId,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getNextFocusDownId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNextFocusDownId", r"()I");

  /// from: public int getNextFocusDownId()
  int getNextFocusDownId() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getNextFocusDownId, jni.JniCallType.intType, []).integer;
  }

  static final _id_setNextFocusDownId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNextFocusDownId", r"(I)V");

  /// from: public void setNextFocusDownId(int i)
  void setNextFocusDownId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setNextFocusDownId,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getNextFocusForwardId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNextFocusForwardId", r"()I");

  /// from: public int getNextFocusForwardId()
  int getNextFocusForwardId() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getNextFocusForwardId, jni.JniCallType.intType, []).integer;
  }

  static final _id_setNextFocusForwardId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNextFocusForwardId", r"(I)V");

  /// from: public void setNextFocusForwardId(int i)
  void setNextFocusForwardId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setNextFocusForwardId,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getNextClusterForwardId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNextClusterForwardId", r"()I");

  /// from: public int getNextClusterForwardId()
  int getNextClusterForwardId() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getNextClusterForwardId, jni.JniCallType.intType, []).integer;
  }

  static final _id_setNextClusterForwardId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNextClusterForwardId", r"(I)V");

  /// from: public void setNextClusterForwardId(int i)
  void setNextClusterForwardId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setNextClusterForwardId,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_isShown =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isShown", r"()Z");

  /// from: public boolean isShown()
  bool isShown() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isShown, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_fitSystemWindows = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"fitSystemWindows", r"(Landroid/graphics/Rect;)Z");

  /// from: protected boolean fitSystemWindows(android.graphics.Rect rect)
  bool fitSystemWindows(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_fitSystemWindows,
        jni.JniCallType.booleanType, [rect.reference]).boolean;
  }

  static final _id_onApplyWindowInsets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onApplyWindowInsets",
      r"(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets onApplyWindowInsets(android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onApplyWindowInsets(
    jni.JObject windowInsets,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onApplyWindowInsets,
        jni.JniCallType.objectType,
        [windowInsets.reference]).object);
  }

  static final _id_setOnApplyWindowInsetsListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOnApplyWindowInsetsListener",
          r"(Landroid/view/View$OnApplyWindowInsetsListener;)V");

  /// from: public void setOnApplyWindowInsetsListener(android.view.View$OnApplyWindowInsetsListener onApplyWindowInsetsListener)
  void setOnApplyWindowInsetsListener(
    View_OnApplyWindowInsetsListener onApplyWindowInsetsListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnApplyWindowInsetsListener,
        jni.JniCallType.voidType,
        [onApplyWindowInsetsListener.reference]).check();
  }

  static final _id_dispatchApplyWindowInsets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchApplyWindowInsets",
      r"(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets dispatchApplyWindowInsets(android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatchApplyWindowInsets(
    jni.JObject windowInsets,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchApplyWindowInsets,
        jni.JniCallType.objectType,
        [windowInsets.reference]).object);
  }

  static final _id_setWindowInsetsAnimationCallback = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setWindowInsetsAnimationCallback",
          r"(Landroid/view/WindowInsetsAnimation$Callback;)V");

  /// from: public void setWindowInsetsAnimationCallback(android.view.WindowInsetsAnimation$Callback callback)
  void setWindowInsetsAnimationCallback(
    jni.JObject callback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setWindowInsetsAnimationCallback,
        jni.JniCallType.voidType,
        [callback.reference]).check();
  }

  static final _id_dispatchWindowInsetsAnimationPrepare = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchWindowInsetsAnimationPrepare",
          r"(Landroid/view/WindowInsetsAnimation;)V");

  /// from: public void dispatchWindowInsetsAnimationPrepare(android.view.WindowInsetsAnimation windowInsetsAnimation)
  void dispatchWindowInsetsAnimationPrepare(
    jni.JObject windowInsetsAnimation,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowInsetsAnimationPrepare,
        jni.JniCallType.voidType,
        [windowInsetsAnimation.reference]).check();
  }

  static final _id_dispatchWindowInsetsAnimationStart = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchWindowInsetsAnimationStart",
          r"(Landroid/view/WindowInsetsAnimation;Landroid/view/WindowInsetsAnimation$Bounds;)Landroid/view/WindowInsetsAnimation$Bounds;");

  /// from: public android.view.WindowInsetsAnimation$Bounds dispatchWindowInsetsAnimationStart(android.view.WindowInsetsAnimation windowInsetsAnimation, android.view.WindowInsetsAnimation$Bounds bounds)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatchWindowInsetsAnimationStart(
    jni.JObject windowInsetsAnimation,
    jni.JObject bounds,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowInsetsAnimationStart,
        jni.JniCallType.objectType,
        [windowInsetsAnimation.reference, bounds.reference]).object);
  }

  static final _id_dispatchWindowInsetsAnimationProgress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchWindowInsetsAnimationProgress",
          r"(Landroid/view/WindowInsets;Ljava/util/List;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets dispatchWindowInsetsAnimationProgress(android.view.WindowInsets windowInsets, java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatchWindowInsetsAnimationProgress(
    jni.JObject windowInsets,
    jni.JList<jni.JObject> list,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowInsetsAnimationProgress,
        jni.JniCallType.objectType,
        [windowInsets.reference, list.reference]).object);
  }

  static final _id_dispatchWindowInsetsAnimationEnd = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchWindowInsetsAnimationEnd",
          r"(Landroid/view/WindowInsetsAnimation;)V");

  /// from: public void dispatchWindowInsetsAnimationEnd(android.view.WindowInsetsAnimation windowInsetsAnimation)
  void dispatchWindowInsetsAnimationEnd(
    jni.JObject windowInsetsAnimation,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowInsetsAnimationEnd,
        jni.JniCallType.voidType,
        [windowInsetsAnimation.reference]).check();
  }

  static final _id_setSystemGestureExclusionRects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSystemGestureExclusionRects",
          r"(Ljava/util/List;)V");

  /// from: public void setSystemGestureExclusionRects(java.util.List list)
  void setSystemGestureExclusionRects(
    jni.JList<jni.JObject> list,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setSystemGestureExclusionRects,
        jni.JniCallType.voidType,
        [list.reference]).check();
  }

  static final _id_getSystemGestureExclusionRects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSystemGestureExclusionRects",
          r"()Ljava/util/List;");

  /// from: public java.util.List getSystemGestureExclusionRects()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getSystemGestureExclusionRects() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getSystemGestureExclusionRects,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setPreferKeepClear = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setPreferKeepClear", r"(Z)V");

  /// from: public final void setPreferKeepClear(boolean z)
  void setPreferKeepClear(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_setPreferKeepClear, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isPreferKeepClear = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isPreferKeepClear", r"()Z");

  /// from: public final boolean isPreferKeepClear()
  bool isPreferKeepClear() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isPreferKeepClear, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setPreferKeepClearRects = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setPreferKeepClearRects", r"(Ljava/util/List;)V");

  /// from: public final void setPreferKeepClearRects(java.util.List list)
  void setPreferKeepClearRects(
    jni.JList<jni.JObject> list,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setPreferKeepClearRects,
        jni.JniCallType.voidType,
        [list.reference]).check();
  }

  static final _id_getPreferKeepClearRects = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getPreferKeepClearRects", r"()Ljava/util/List;");

  /// from: public final java.util.List getPreferKeepClearRects()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getPreferKeepClearRects() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getPreferKeepClearRects,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setHandwritingBoundsOffsets = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setHandwritingBoundsOffsets", r"(FFFF)V");

  /// from: public void setHandwritingBoundsOffsets(float f, float f1, float f2, float f3)
  void setHandwritingBoundsOffsets(
    double f,
    double f1,
    double f2,
    double f3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setHandwritingBoundsOffsets, jni.JniCallType.voidType, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3)
    ]).check();
  }

  static final _id_getHandwritingBoundsOffsetLeft = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getHandwritingBoundsOffsetLeft", r"()F");

  /// from: public float getHandwritingBoundsOffsetLeft()
  double getHandwritingBoundsOffsetLeft() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHandwritingBoundsOffsetLeft,
        jni.JniCallType.floatType, []).float;
  }

  static final _id_getHandwritingBoundsOffsetTop = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getHandwritingBoundsOffsetTop", r"()F");

  /// from: public float getHandwritingBoundsOffsetTop()
  double getHandwritingBoundsOffsetTop() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getHandwritingBoundsOffsetTop, jni.JniCallType.floatType, []).float;
  }

  static final _id_getHandwritingBoundsOffsetRight = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getHandwritingBoundsOffsetRight", r"()F");

  /// from: public float getHandwritingBoundsOffsetRight()
  double getHandwritingBoundsOffsetRight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHandwritingBoundsOffsetRight,
        jni.JniCallType.floatType, []).float;
  }

  static final _id_getHandwritingBoundsOffsetBottom = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getHandwritingBoundsOffsetBottom", r"()F");

  /// from: public float getHandwritingBoundsOffsetBottom()
  double getHandwritingBoundsOffsetBottom() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHandwritingBoundsOffsetBottom,
        jni.JniCallType.floatType, []).float;
  }

  static final _id_setHandwritingDelegatorCallback = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setHandwritingDelegatorCallback",
          r"(Ljava/lang/Runnable;)V");

  /// from: public void setHandwritingDelegatorCallback(java.lang.Runnable runnable)
  void setHandwritingDelegatorCallback(
    jni.JObject runnable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHandwritingDelegatorCallback,
        jni.JniCallType.voidType,
        [runnable.reference]).check();
  }

  static final _id_getHandwritingDelegatorCallback = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHandwritingDelegatorCallback",
          r"()Ljava/lang/Runnable;");

  /// from: public java.lang.Runnable getHandwritingDelegatorCallback()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHandwritingDelegatorCallback() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHandwritingDelegatorCallback,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setAllowedHandwritingDelegatePackage = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setAllowedHandwritingDelegatePackage",
          r"(Ljava/lang/String;)V");

  /// from: public void setAllowedHandwritingDelegatePackage(java.lang.String string)
  void setAllowedHandwritingDelegatePackage(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAllowedHandwritingDelegatePackage,
        jni.JniCallType.voidType,
        [string.reference]).check();
  }

  static final _id_getAllowedHandwritingDelegatePackageName = jni.Jni.accessors
      .getMethodIDOf(_class.reference,
          r"getAllowedHandwritingDelegatePackageName", r"()Ljava/lang/String;");

  /// from: public java.lang.String getAllowedHandwritingDelegatePackageName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAllowedHandwritingDelegatePackageName() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAllowedHandwritingDelegatePackageName,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setIsHandwritingDelegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setIsHandwritingDelegate", r"(Z)V");

  /// from: public void setIsHandwritingDelegate(boolean z)
  void setIsHandwritingDelegate(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setIsHandwritingDelegate,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isHandwritingDelegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isHandwritingDelegate", r"()Z");

  /// from: public boolean isHandwritingDelegate()
  bool isHandwritingDelegate() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isHandwritingDelegate, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setAllowedHandwritingDelegatorPackage = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setAllowedHandwritingDelegatorPackage",
          r"(Ljava/lang/String;)V");

  /// from: public void setAllowedHandwritingDelegatorPackage(java.lang.String string)
  void setAllowedHandwritingDelegatorPackage(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAllowedHandwritingDelegatorPackage,
        jni.JniCallType.voidType,
        [string.reference]).check();
  }

  static final _id_getAllowedHandwritingDelegatorPackageName = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference,
          r"getAllowedHandwritingDelegatorPackageName",
          r"()Ljava/lang/String;");

  /// from: public java.lang.String getAllowedHandwritingDelegatorPackageName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAllowedHandwritingDelegatorPackageName() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAllowedHandwritingDelegatorPackageName,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getLocationInSurface = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLocationInSurface", r"([I)V");

  /// from: public void getLocationInSurface(int[] is)
  void getLocationInSurface(
    jni.JArray<jni.jint> is0,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLocationInSurface,
        jni.JniCallType.voidType,
        [is0.reference]).check();
  }

  static final _id_getRootWindowInsets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getRootWindowInsets",
      r"()Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets getRootWindowInsets()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRootWindowInsets() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getRootWindowInsets,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getWindowInsetsController = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getWindowInsetsController",
      r"()Landroid/view/WindowInsetsController;");

  /// from: public android.view.WindowInsetsController getWindowInsetsController()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowInsetsController() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWindowInsetsController,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_findOnBackInvokedDispatcher = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"findOnBackInvokedDispatcher",
          r"()Landroid/window/OnBackInvokedDispatcher;");

  /// from: public final android.window.OnBackInvokedDispatcher findOnBackInvokedDispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject findOnBackInvokedDispatcher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_findOnBackInvokedDispatcher,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_computeSystemWindowInsets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"computeSystemWindowInsets",
      r"(Landroid/view/WindowInsets;Landroid/graphics/Rect;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets computeSystemWindowInsets(android.view.WindowInsets windowInsets, android.graphics.Rect rect)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject computeSystemWindowInsets(
    jni.JObject windowInsets,
    jni.JObject rect,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_computeSystemWindowInsets,
        jni.JniCallType.objectType,
        [windowInsets.reference, rect.reference]).object);
  }

  static final _id_setFitsSystemWindows = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setFitsSystemWindows", r"(Z)V");

  /// from: public void setFitsSystemWindows(boolean z)
  void setFitsSystemWindows(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setFitsSystemWindows,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_getFitsSystemWindows = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getFitsSystemWindows", r"()Z");

  /// from: public boolean getFitsSystemWindows()
  bool getFitsSystemWindows() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getFitsSystemWindows, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_requestFitSystemWindows = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestFitSystemWindows", r"()V");

  /// from: public void requestFitSystemWindows()
  void requestFitSystemWindows() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_requestFitSystemWindows, jni.JniCallType.voidType, []).check();
  }

  static final _id_requestApplyInsets = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestApplyInsets", r"()V");

  /// from: public void requestApplyInsets()
  void requestApplyInsets() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_requestApplyInsets, jni.JniCallType.voidType, []).check();
  }

  static final _id_getVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getVisibility", r"()I");

  /// from: public int getVisibility()
  int getVisibility() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getVisibility, jni.JniCallType.intType, []).integer;
  }

  static final _id_setVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setVisibility", r"(I)V");

  /// from: public void setVisibility(int i)
  void setVisibility(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setVisibility,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_isEnabled =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isEnabled", r"()Z");

  /// from: public boolean isEnabled()
  bool isEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setEnabled =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setEnabled", r"(Z)V");

  /// from: public void setEnabled(boolean z)
  void setEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setEnabled,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_setFocusable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setFocusable", r"(Z)V");

  /// from: public void setFocusable(boolean z)
  void setFocusable(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setFocusable,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_setFocusable1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setFocusable", r"(I)V");

  /// from: public void setFocusable(int i)
  void setFocusable1(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setFocusable1,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_setFocusableInTouchMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setFocusableInTouchMode", r"(Z)V");

  /// from: public void setFocusableInTouchMode(boolean z)
  void setFocusableInTouchMode(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setFocusableInTouchMode,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_setAutofillHints = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setAutofillHints", r"([Ljava/lang/String;)V");

  /// from: public void setAutofillHints(java.lang.String[] strings)
  void setAutofillHints(
    jni.JArray<jni.JString> strings,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setAutofillHints,
        jni.JniCallType.voidType, [strings.reference]).check();
  }

  static final _id_setSoundEffectsEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSoundEffectsEnabled", r"(Z)V");

  /// from: public void setSoundEffectsEnabled(boolean z)
  void setSoundEffectsEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setSoundEffectsEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isSoundEffectsEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSoundEffectsEnabled", r"()Z");

  /// from: public boolean isSoundEffectsEnabled()
  bool isSoundEffectsEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isSoundEffectsEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setHapticFeedbackEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setHapticFeedbackEnabled", r"(Z)V");

  /// from: public void setHapticFeedbackEnabled(boolean z)
  void setHapticFeedbackEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHapticFeedbackEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isHapticFeedbackEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isHapticFeedbackEnabled", r"()Z");

  /// from: public boolean isHapticFeedbackEnabled()
  bool isHapticFeedbackEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isHapticFeedbackEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setLayoutDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setLayoutDirection", r"(I)V");

  /// from: public void setLayoutDirection(int i)
  void setLayoutDirection(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setLayoutDirection,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getLayoutDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLayoutDirection", r"()I");

  /// from: public int getLayoutDirection()
  int getLayoutDirection() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLayoutDirection, jni.JniCallType.intType, []).integer;
  }

  static final _id_hasTransientState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasTransientState", r"()Z");

  /// from: public boolean hasTransientState()
  bool hasTransientState() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasTransientState, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setHasTransientState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setHasTransientState", r"(Z)V");

  /// from: public void setHasTransientState(boolean z)
  void setHasTransientState(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHasTransientState,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isAttachedToWindow = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isAttachedToWindow", r"()Z");

  /// from: public boolean isAttachedToWindow()
  bool isAttachedToWindow() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isAttachedToWindow, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isLaidOut =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isLaidOut", r"()Z");

  /// from: public boolean isLaidOut()
  bool isLaidOut() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isLaidOut, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setWillNotDraw = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setWillNotDraw", r"(Z)V");

  /// from: public void setWillNotDraw(boolean z)
  void setWillNotDraw(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setWillNotDraw,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_willNotDraw =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"willNotDraw", r"()Z");

  /// from: public boolean willNotDraw()
  bool willNotDraw() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_willNotDraw, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setWillNotCacheDrawing = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setWillNotCacheDrawing", r"(Z)V");

  /// from: public void setWillNotCacheDrawing(boolean z)
  void setWillNotCacheDrawing(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setWillNotCacheDrawing,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_willNotCacheDrawing = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"willNotCacheDrawing", r"()Z");

  /// from: public boolean willNotCacheDrawing()
  bool willNotCacheDrawing() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_willNotCacheDrawing, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isClickable =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isClickable", r"()Z");

  /// from: public boolean isClickable()
  bool isClickable() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isClickable, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setClickable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setClickable", r"(Z)V");

  /// from: public void setClickable(boolean z)
  void setClickable(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setClickable,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_setAllowClickWhenDisabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setAllowClickWhenDisabled", r"(Z)V");

  /// from: public void setAllowClickWhenDisabled(boolean z)
  void setAllowClickWhenDisabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAllowClickWhenDisabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isLongClickable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isLongClickable", r"()Z");

  /// from: public boolean isLongClickable()
  bool isLongClickable() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_isLongClickable,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setLongClickable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setLongClickable", r"(Z)V");

  /// from: public void setLongClickable(boolean z)
  void setLongClickable(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLongClickable,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isContextClickable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isContextClickable", r"()Z");

  /// from: public boolean isContextClickable()
  bool isContextClickable() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isContextClickable, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setContextClickable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setContextClickable", r"(Z)V");

  /// from: public void setContextClickable(boolean z)
  void setContextClickable(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_setContextClickable, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_setPressed =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setPressed", r"(Z)V");

  /// from: public void setPressed(boolean z)
  void setPressed(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setPressed,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_dispatchSetPressed = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchSetPressed", r"(Z)V");

  /// from: protected void dispatchSetPressed(boolean z)
  void dispatchSetPressed(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_dispatchSetPressed, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isPressed =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isPressed", r"()Z");

  /// from: public boolean isPressed()
  bool isPressed() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isPressed, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isSaveEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSaveEnabled", r"()Z");

  /// from: public boolean isSaveEnabled()
  bool isSaveEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isSaveEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setSaveEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSaveEnabled", r"(Z)V");

  /// from: public void setSaveEnabled(boolean z)
  void setSaveEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setSaveEnabled,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_getFilterTouchesWhenObscured = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getFilterTouchesWhenObscured", r"()Z");

  /// from: public boolean getFilterTouchesWhenObscured()
  bool getFilterTouchesWhenObscured() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getFilterTouchesWhenObscured,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setFilterTouchesWhenObscured = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setFilterTouchesWhenObscured", r"(Z)V");

  /// from: public void setFilterTouchesWhenObscured(boolean z)
  void setFilterTouchesWhenObscured(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setFilterTouchesWhenObscured,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isSaveFromParentEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSaveFromParentEnabled", r"()Z");

  /// from: public boolean isSaveFromParentEnabled()
  bool isSaveFromParentEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isSaveFromParentEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setSaveFromParentEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSaveFromParentEnabled", r"(Z)V");

  /// from: public void setSaveFromParentEnabled(boolean z)
  void setSaveFromParentEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setSaveFromParentEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isFocusable =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isFocusable", r"()Z");

  /// from: public final boolean isFocusable()
  bool isFocusable() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isFocusable, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getFocusable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getFocusable", r"()I");

  /// from: public int getFocusable()
  int getFocusable() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFocusable, jni.JniCallType.intType, []).integer;
  }

  static final _id_isFocusableInTouchMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isFocusableInTouchMode", r"()Z");

  /// from: public final boolean isFocusableInTouchMode()
  bool isFocusableInTouchMode() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isFocusableInTouchMode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isScreenReaderFocusable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isScreenReaderFocusable", r"()Z");

  /// from: public boolean isScreenReaderFocusable()
  bool isScreenReaderFocusable() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isScreenReaderFocusable, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setScreenReaderFocusable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScreenReaderFocusable", r"(Z)V");

  /// from: public void setScreenReaderFocusable(boolean z)
  void setScreenReaderFocusable(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScreenReaderFocusable,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isAccessibilityHeading = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isAccessibilityHeading", r"()Z");

  /// from: public boolean isAccessibilityHeading()
  bool isAccessibilityHeading() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isAccessibilityHeading, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setAccessibilityHeading = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setAccessibilityHeading", r"(Z)V");

  /// from: public void setAccessibilityHeading(boolean z)
  void setAccessibilityHeading(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityHeading,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_focusSearch = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"focusSearch", r"(I)Landroid/view/View;");

  /// from: public android.view.View focusSearch(int i)
  /// The returned object must be released after use, by calling the [release] method.
  View focusSearch(
    int i,
  ) {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_focusSearch,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_isKeyboardNavigationCluster = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isKeyboardNavigationCluster", r"()Z");

  /// from: public final boolean isKeyboardNavigationCluster()
  bool isKeyboardNavigationCluster() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isKeyboardNavigationCluster,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setKeyboardNavigationCluster = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setKeyboardNavigationCluster", r"(Z)V");

  /// from: public void setKeyboardNavigationCluster(boolean z)
  void setKeyboardNavigationCluster(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setKeyboardNavigationCluster,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isFocusedByDefault = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isFocusedByDefault", r"()Z");

  /// from: public final boolean isFocusedByDefault()
  bool isFocusedByDefault() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isFocusedByDefault, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setFocusedByDefault = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setFocusedByDefault", r"(Z)V");

  /// from: public void setFocusedByDefault(boolean z)
  void setFocusedByDefault(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_setFocusedByDefault, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_keyboardNavigationClusterSearch = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"keyboardNavigationClusterSearch",
          r"(Landroid/view/View;I)Landroid/view/View;");

  /// from: public android.view.View keyboardNavigationClusterSearch(android.view.View view, int i)
  /// The returned object must be released after use, by calling the [release] method.
  View keyboardNavigationClusterSearch(
    View view,
    int i,
  ) {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_keyboardNavigationClusterSearch,
        jni.JniCallType.objectType,
        [view.reference, jni.JValueInt(i)]).object);
  }

  static final _id_dispatchUnhandledMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchUnhandledMove", r"(Landroid/view/View;I)Z");

  /// from: public boolean dispatchUnhandledMove(android.view.View view, int i)
  bool dispatchUnhandledMove(
    View view,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchUnhandledMove,
        jni.JniCallType.booleanType,
        [view.reference, jni.JValueInt(i)]).boolean;
  }

  static final _id_setDefaultFocusHighlightEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setDefaultFocusHighlightEnabled", r"(Z)V");

  /// from: public void setDefaultFocusHighlightEnabled(boolean z)
  void setDefaultFocusHighlightEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDefaultFocusHighlightEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_getDefaultFocusHighlightEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getDefaultFocusHighlightEnabled", r"()Z");

  /// from: public final boolean getDefaultFocusHighlightEnabled()
  bool getDefaultFocusHighlightEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDefaultFocusHighlightEnabled,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getFocusables = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getFocusables", r"(I)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList getFocusables(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFocusables(
    int i,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getFocusables,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_addFocusables = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"addFocusables", r"(Ljava/util/ArrayList;I)V");

  /// from: public void addFocusables(java.util.ArrayList arrayList, int i)
  void addFocusables(
    jni.JObject arrayList,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addFocusables,
        jni.JniCallType.voidType,
        [arrayList.reference, jni.JValueInt(i)]).check();
  }

  static final _id_addFocusables1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"addFocusables", r"(Ljava/util/ArrayList;II)V");

  /// from: public void addFocusables(java.util.ArrayList arrayList, int i, int i1)
  void addFocusables1(
    jni.JObject arrayList,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addFocusables1,
        jni.JniCallType.voidType,
        [arrayList.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_addKeyboardNavigationClusters = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"addKeyboardNavigationClusters",
          r"(Ljava/util/Collection;I)V");

  /// from: public void addKeyboardNavigationClusters(java.util.Collection collection, int i)
  void addKeyboardNavigationClusters(
    jni.JObject collection,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addKeyboardNavigationClusters,
        jni.JniCallType.voidType,
        [collection.reference, jni.JValueInt(i)]).check();
  }

  static final _id_findViewsWithText = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"findViewsWithText",
      r"(Ljava/util/ArrayList;Ljava/lang/CharSequence;I)V");

  /// from: public void findViewsWithText(java.util.ArrayList arrayList, java.lang.CharSequence charSequence, int i)
  void findViewsWithText(
    jni.JObject arrayList,
    jni.JObject charSequence,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_findViewsWithText, jni.JniCallType.voidType, [
      arrayList.reference,
      charSequence.reference,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_getTouchables = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getTouchables", r"()Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList getTouchables()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTouchables() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTouchables, jni.JniCallType.objectType, []).object);
  }

  static final _id_addTouchables = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"addTouchables", r"(Ljava/util/ArrayList;)V");

  /// from: public void addTouchables(java.util.ArrayList arrayList)
  void addTouchables(
    jni.JObject arrayList,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_addTouchables,
        jni.JniCallType.voidType, [arrayList.reference]).check();
  }

  static final _id_isAccessibilityFocused = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isAccessibilityFocused", r"()Z");

  /// from: public boolean isAccessibilityFocused()
  bool isAccessibilityFocused() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isAccessibilityFocused, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_requestFocus = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestFocus", r"()Z");

  /// from: public final boolean requestFocus()
  bool requestFocus() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_requestFocus, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_restoreDefaultFocus = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"restoreDefaultFocus", r"()Z");

  /// from: public boolean restoreDefaultFocus()
  bool restoreDefaultFocus() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_restoreDefaultFocus, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_requestFocus1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestFocus", r"(I)Z");

  /// from: public final boolean requestFocus(int i)
  bool requestFocus1(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_requestFocus1,
        jni.JniCallType.booleanType, [jni.JValueInt(i)]).boolean;
  }

  static final _id_requestFocus2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"requestFocus", r"(ILandroid/graphics/Rect;)Z");

  /// from: public boolean requestFocus(int i, android.graphics.Rect rect)
  bool requestFocus2(
    int i,
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestFocus2,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), rect.reference]).boolean;
  }

  static final _id_requestFocusFromTouch = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestFocusFromTouch", r"()Z");

  /// from: public final boolean requestFocusFromTouch()
  bool requestFocusFromTouch() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_requestFocusFromTouch, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getImportantForAccessibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getImportantForAccessibility", r"()I");

  /// from: public int getImportantForAccessibility()
  int getImportantForAccessibility() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getImportantForAccessibility, jni.JniCallType.intType, []).integer;
  }

  static final _id_setAccessibilityLiveRegion = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setAccessibilityLiveRegion", r"(I)V");

  /// from: public void setAccessibilityLiveRegion(int i)
  void setAccessibilityLiveRegion(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityLiveRegion,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getAccessibilityLiveRegion = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getAccessibilityLiveRegion", r"()I");

  /// from: public int getAccessibilityLiveRegion()
  int getAccessibilityLiveRegion() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getAccessibilityLiveRegion, jni.JniCallType.intType, []).integer;
  }

  static final _id_setImportantForAccessibility = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setImportantForAccessibility", r"(I)V");

  /// from: public void setImportantForAccessibility(int i)
  void setImportantForAccessibility(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setImportantForAccessibility,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_isImportantForAccessibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isImportantForAccessibility", r"()Z");

  /// from: public boolean isImportantForAccessibility()
  bool isImportantForAccessibility() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isImportantForAccessibility,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getParentForAccessibility = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getParentForAccessibility",
      r"()Landroid/view/ViewParent;");

  /// from: public android.view.ViewParent getParentForAccessibility()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getParentForAccessibility() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getParentForAccessibility,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_addChildrenForAccessibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"addChildrenForAccessibility",
          r"(Ljava/util/ArrayList;)V");

  /// from: public void addChildrenForAccessibility(java.util.ArrayList arrayList)
  void addChildrenForAccessibility(
    jni.JObject arrayList,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addChildrenForAccessibility,
        jni.JniCallType.voidType,
        [arrayList.reference]).check();
  }

  static final _id_isAccessibilityDataSensitive = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isAccessibilityDataSensitive", r"()Z");

  /// from: public boolean isAccessibilityDataSensitive()
  bool isAccessibilityDataSensitive() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isAccessibilityDataSensitive,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setAccessibilityDataSensitive = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setAccessibilityDataSensitive", r"(I)V");

  /// from: public void setAccessibilityDataSensitive(int i)
  void setAccessibilityDataSensitive(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAccessibilityDataSensitive,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setTransitionVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTransitionVisibility", r"(I)V");

  /// from: public void setTransitionVisibility(int i)
  void setTransitionVisibility(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setTransitionVisibility,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_dispatchNestedPrePerformAccessibilityAction =
      jni.Jni.accessors.getMethodIDOf(
          _class.reference,
          r"dispatchNestedPrePerformAccessibilityAction",
          r"(ILandroid/os/Bundle;)Z");

  /// from: public boolean dispatchNestedPrePerformAccessibilityAction(int i, android.os.Bundle bundle)
  bool dispatchNestedPrePerformAccessibilityAction(
    int i,
    jni.JObject bundle,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchNestedPrePerformAccessibilityAction,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), bundle.reference]).boolean;
  }

  static final _id_performAccessibilityAction = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"performAccessibilityAction",
      r"(ILandroid/os/Bundle;)Z");

  /// from: public boolean performAccessibilityAction(int i, android.os.Bundle bundle)
  bool performAccessibilityAction(
    int i,
    jni.JObject bundle,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performAccessibilityAction,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), bundle.reference]).boolean;
  }

  static final _id_isTemporarilyDetached = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isTemporarilyDetached", r"()Z");

  /// from: public final boolean isTemporarilyDetached()
  bool isTemporarilyDetached() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isTemporarilyDetached, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_dispatchStartTemporaryDetach = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchStartTemporaryDetach", r"()V");

  /// from: public void dispatchStartTemporaryDetach()
  void dispatchStartTemporaryDetach() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_dispatchStartTemporaryDetach, jni.JniCallType.voidType, []).check();
  }

  static final _id_onStartTemporaryDetach = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onStartTemporaryDetach", r"()V");

  /// from: public void onStartTemporaryDetach()
  void onStartTemporaryDetach() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onStartTemporaryDetach, jni.JniCallType.voidType, []).check();
  }

  static final _id_dispatchFinishTemporaryDetach = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"dispatchFinishTemporaryDetach", r"()V");

  /// from: public void dispatchFinishTemporaryDetach()
  void dispatchFinishTemporaryDetach() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchFinishTemporaryDetach,
        jni.JniCallType.voidType, []).check();
  }

  static final _id_onFinishTemporaryDetach = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onFinishTemporaryDetach", r"()V");

  /// from: public void onFinishTemporaryDetach()
  void onFinishTemporaryDetach() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onFinishTemporaryDetach, jni.JniCallType.voidType, []).check();
  }

  static final _id_getKeyDispatcherState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getKeyDispatcherState",
      r"()Landroid/view/KeyEvent$DispatcherState;");

  /// from: public android.view.KeyEvent$DispatcherState getKeyDispatcherState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getKeyDispatcherState() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getKeyDispatcherState,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_dispatchKeyEventPreIme = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchKeyEventPreIme",
      r"(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEventPreIme(android.view.KeyEvent keyEvent)
  bool dispatchKeyEventPreIme(
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchKeyEventPreIme,
        jni.JniCallType.booleanType,
        [keyEvent.reference]).boolean;
  }

  static final _id_dispatchKeyEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchKeyEvent", r"(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyEvent(
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
        jni.JniCallType.booleanType, [keyEvent.reference]).boolean;
  }

  static final _id_dispatchKeyShortcutEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchKeyShortcutEvent",
      r"(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyShortcutEvent(
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchKeyShortcutEvent,
        jni.JniCallType.booleanType,
        [keyEvent.reference]).boolean;
  }

  static final _id_dispatchTouchEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchTouchEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent motionEvent)
  bool dispatchTouchEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchTouchEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_onFilterTouchEventForSecurity = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onFilterTouchEventForSecurity",
          r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onFilterTouchEventForSecurity(android.view.MotionEvent motionEvent)
  bool onFilterTouchEventForSecurity(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onFilterTouchEventForSecurity,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchTrackballEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchTrackballEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent motionEvent)
  bool dispatchTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchTrackballEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchCapturedPointerEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchCapturedPointerEvent",
          r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchCapturedPointerEvent(android.view.MotionEvent motionEvent)
  bool dispatchCapturedPointerEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchCapturedPointerEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchGenericMotionEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchGenericMotionEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchGenericMotionEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchHoverEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchHoverEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchHoverEvent(android.view.MotionEvent motionEvent)
  bool dispatchHoverEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchHoverEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchGenericPointerEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchGenericPointerEvent",
          r"(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchGenericPointerEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericPointerEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchGenericPointerEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchGenericFocusedEvent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchGenericFocusedEvent",
          r"(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchGenericFocusedEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericFocusedEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchGenericFocusedEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_dispatchWindowFocusChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchWindowFocusChanged", r"(Z)V");

  /// from: public void dispatchWindowFocusChanged(boolean z)
  void dispatchWindowFocusChanged(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowFocusChanged,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_onWindowFocusChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onWindowFocusChanged", r"(Z)V");

  /// from: public void onWindowFocusChanged(boolean z)
  void onWindowFocusChanged(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onWindowFocusChanged,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_hasWindowFocus = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasWindowFocus", r"()Z");

  /// from: public boolean hasWindowFocus()
  bool hasWindowFocus() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasWindowFocus, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_dispatchVisibilityChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchVisibilityChanged",
      r"(Landroid/view/View;I)V");

  /// from: protected void dispatchVisibilityChanged(android.view.View view, int i)
  void dispatchVisibilityChanged(
    View view,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchVisibilityChanged,
        jni.JniCallType.voidType,
        [view.reference, jni.JValueInt(i)]).check();
  }

  static final _id_onVisibilityChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onVisibilityChanged", r"(Landroid/view/View;I)V");

  /// from: protected void onVisibilityChanged(android.view.View view, int i)
  void onVisibilityChanged(
    View view,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onVisibilityChanged,
        jni.JniCallType.voidType,
        [view.reference, jni.JValueInt(i)]).check();
  }

  static final _id_dispatchDisplayHint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchDisplayHint", r"(I)V");

  /// from: public void dispatchDisplayHint(int i)
  void dispatchDisplayHint(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchDisplayHint,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_onDisplayHint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onDisplayHint", r"(I)V");

  /// from: protected void onDisplayHint(int i)
  void onDisplayHint(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDisplayHint,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_dispatchWindowVisibilityChanged = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"dispatchWindowVisibilityChanged", r"(I)V");

  /// from: public void dispatchWindowVisibilityChanged(int i)
  void dispatchWindowVisibilityChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowVisibilityChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_onWindowVisibilityChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onWindowVisibilityChanged", r"(I)V");

  /// from: protected void onWindowVisibilityChanged(int i)
  void onWindowVisibilityChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onWindowVisibilityChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_onVisibilityAggregated = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onVisibilityAggregated", r"(Z)V");

  /// from: public void onVisibilityAggregated(boolean z)
  void onVisibilityAggregated(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onVisibilityAggregated,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_getWindowVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getWindowVisibility", r"()I");

  /// from: public int getWindowVisibility()
  int getWindowVisibility() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getWindowVisibility, jni.JniCallType.intType, []).integer;
  }

  static final _id_getWindowVisibleDisplayFrame = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getWindowVisibleDisplayFrame",
          r"(Landroid/graphics/Rect;)V");

  /// from: public void getWindowVisibleDisplayFrame(android.graphics.Rect rect)
  void getWindowVisibleDisplayFrame(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWindowVisibleDisplayFrame,
        jni.JniCallType.voidType,
        [rect.reference]).check();
  }

  static final _id_dispatchConfigurationChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchConfigurationChanged",
          r"(Landroid/content/res/Configuration;)V");

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration configuration)
  void dispatchConfigurationChanged(
    jni.JObject configuration,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchConfigurationChanged,
        jni.JniCallType.voidType,
        [configuration.reference]).check();
  }

  static final _id_onConfigurationChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onConfigurationChanged",
      r"(Landroid/content/res/Configuration;)V");

  /// from: protected void onConfigurationChanged(android.content.res.Configuration configuration)
  void onConfigurationChanged(
    jni.JObject configuration,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onConfigurationChanged,
        jni.JniCallType.voidType,
        [configuration.reference]).check();
  }

  static final _id_isInTouchMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isInTouchMode", r"()Z");

  /// from: public boolean isInTouchMode()
  bool isInTouchMode() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isInTouchMode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getContext = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getContext", r"()Landroid/content/Context;");

  /// from: public final android.content.Context getContext()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContext() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getContext, jni.JniCallType.objectType, []).object);
  }

  static final _id_onKeyPreIme = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyPreIme", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyPreIme(int i, android.view.KeyEvent keyEvent)
  bool onKeyPreIme(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyPreIme,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onKeyDown = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyDown", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int i, android.view.KeyEvent keyEvent)
  bool onKeyDown(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyDown,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onKeyLongPress = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyLongPress", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int i, android.view.KeyEvent keyEvent)
  bool onKeyLongPress(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyLongPress,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onKeyUp = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyUp", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int i, android.view.KeyEvent keyEvent)
  bool onKeyUp(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyUp,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onKeyMultiple = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyMultiple", r"(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int i, int i1, android.view.KeyEvent keyEvent)
  bool onKeyMultiple(
    int i,
    int i1,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyMultiple,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), jni.JValueInt(i1), keyEvent.reference]).boolean;
  }

  static final _id_onKeyShortcut = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyShortcut", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyShortcut(int i, android.view.KeyEvent keyEvent)
  bool onKeyShortcut(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyShortcut,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onCheckIsTextEditor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onCheckIsTextEditor", r"()Z");

  /// from: public boolean onCheckIsTextEditor()
  bool onCheckIsTextEditor() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onCheckIsTextEditor, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_onCreateInputConnection = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onCreateInputConnection",
      r"(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo editorInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateInputConnection(
    jni.JObject editorInfo,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCreateInputConnection,
        jni.JniCallType.objectType,
        [editorInfo.reference]).object);
  }

  static final _id_checkInputConnectionProxy = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"checkInputConnectionProxy",
      r"(Landroid/view/View;)Z");

  /// from: public boolean checkInputConnectionProxy(android.view.View view)
  bool checkInputConnectionProxy(
    View view,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_checkInputConnectionProxy,
        jni.JniCallType.booleanType,
        [view.reference]).boolean;
  }

  static final _id_createContextMenu = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createContextMenu", r"(Landroid/view/ContextMenu;)V");

  /// from: public void createContextMenu(android.view.ContextMenu contextMenu)
  void createContextMenu(
    jni.JObject contextMenu,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createContextMenu,
        jni.JniCallType.voidType,
        [contextMenu.reference]).check();
  }

  static final _id_getContextMenuInfo = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getContextMenuInfo",
      r"()Landroid/view/ContextMenu$ContextMenuInfo;");

  /// from: protected android.view.ContextMenu$ContextMenuInfo getContextMenuInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContextMenuInfo() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getContextMenuInfo,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onCreateContextMenu = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onCreateContextMenu",
      r"(Landroid/view/ContextMenu;)V");

  /// from: protected void onCreateContextMenu(android.view.ContextMenu contextMenu)
  void onCreateContextMenu(
    jni.JObject contextMenu,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCreateContextMenu,
        jni.JniCallType.voidType,
        [contextMenu.reference]).check();
  }

  static final _id_onTrackballEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onTrackballEvent", r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent motionEvent)
  bool onTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onTrackballEvent,
        jni.JniCallType.booleanType, [motionEvent.reference]).boolean;
  }

  static final _id_onGenericMotionEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onGenericMotionEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool onGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onGenericMotionEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_onHoverEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onHoverEvent", r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onHoverEvent(android.view.MotionEvent motionEvent)
  bool onHoverEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onHoverEvent,
        jni.JniCallType.booleanType, [motionEvent.reference]).boolean;
  }

  static final _id_isHovered =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isHovered", r"()Z");

  /// from: public boolean isHovered()
  bool isHovered() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isHovered, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setHovered =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setHovered", r"(Z)V");

  /// from: public void setHovered(boolean z)
  void setHovered(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setHovered,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_onHoverChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onHoverChanged", r"(Z)V");

  /// from: public void onHoverChanged(boolean z)
  void onHoverChanged(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onHoverChanged,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_onTouchEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onTouchEvent", r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent motionEvent)
  bool onTouchEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onTouchEvent,
        jni.JniCallType.booleanType, [motionEvent.reference]).boolean;
  }

  static final _id_cancelLongPress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cancelLongPress", r"()V");

  /// from: public void cancelLongPress()
  void cancelLongPress() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cancelLongPress, jni.JniCallType.voidType, []).check();
  }

  static final _id_setTouchDelegate = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setTouchDelegate",
      r"(Landroid/view/TouchDelegate;)V");

  /// from: public void setTouchDelegate(android.view.TouchDelegate touchDelegate)
  void setTouchDelegate(
    jni.JObject touchDelegate,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTouchDelegate,
        jni.JniCallType.voidType, [touchDelegate.reference]).check();
  }

  static final _id_getTouchDelegate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getTouchDelegate", r"()Landroid/view/TouchDelegate;");

  /// from: public android.view.TouchDelegate getTouchDelegate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTouchDelegate() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getTouchDelegate,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_requestUnbufferedDispatch = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"requestUnbufferedDispatch",
      r"(Landroid/view/MotionEvent;)V");

  /// from: public final void requestUnbufferedDispatch(android.view.MotionEvent motionEvent)
  void requestUnbufferedDispatch(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestUnbufferedDispatch,
        jni.JniCallType.voidType,
        [motionEvent.reference]).check();
  }

  static final _id_requestUnbufferedDispatch1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestUnbufferedDispatch", r"(I)V");

  /// from: public final void requestUnbufferedDispatch(int i)
  void requestUnbufferedDispatch1(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestUnbufferedDispatch1,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_bringToFront = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"bringToFront", r"()V");

  /// from: public void bringToFront()
  void bringToFront() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_bringToFront, jni.JniCallType.voidType, []).check();
  }

  static final _id_onScrollChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onScrollChanged", r"(IIII)V");

  /// from: protected void onScrollChanged(int i, int i1, int i2, int i3)
  void onScrollChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onScrollChanged, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_onSizeChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onSizeChanged", r"(IIII)V");

  /// from: protected void onSizeChanged(int i, int i1, int i2, int i3)
  void onSizeChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onSizeChanged, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_dispatchDraw = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchDraw", r"(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_dispatchDraw,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_getParent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getParent", r"()Landroid/view/ViewParent;");

  /// from: public final android.view.ViewParent getParent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getParent() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getParent, jni.JniCallType.objectType, []).object);
  }

  static final _id_setScrollX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setScrollX", r"(I)V");

  /// from: public void setScrollX(int i)
  void setScrollX(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setScrollX,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_setScrollY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setScrollY", r"(I)V");

  /// from: public void setScrollY(int i)
  void setScrollY(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setScrollY,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getScrollX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getScrollX", r"()I");

  /// from: public final int getScrollX()
  int getScrollX() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScrollX, jni.JniCallType.intType, []).integer;
  }

  static final _id_getScrollY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getScrollY", r"()I");

  /// from: public final int getScrollY()
  int getScrollY() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScrollY, jni.JniCallType.intType, []).integer;
  }

  static final _id_getWidth =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getWidth", r"()I");

  /// from: public final int getWidth()
  int getWidth() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getWidth, jni.JniCallType.intType, []).integer;
  }

  static final _id_getHeight =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getHeight", r"()I");

  /// from: public final int getHeight()
  int getHeight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHeight, jni.JniCallType.intType, []).integer;
  }

  static final _id_getDrawingRect = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getDrawingRect", r"(Landroid/graphics/Rect;)V");

  /// from: public void getDrawingRect(android.graphics.Rect rect)
  void getDrawingRect(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getDrawingRect,
        jni.JniCallType.voidType, [rect.reference]).check();
  }

  static final _id_getMeasuredWidth = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMeasuredWidth", r"()I");

  /// from: public final int getMeasuredWidth()
  int getMeasuredWidth() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMeasuredWidth, jni.JniCallType.intType, []).integer;
  }

  static final _id_getMeasuredWidthAndState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMeasuredWidthAndState", r"()I");

  /// from: public final int getMeasuredWidthAndState()
  int getMeasuredWidthAndState() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getMeasuredWidthAndState, jni.JniCallType.intType, []).integer;
  }

  static final _id_getMeasuredHeight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMeasuredHeight", r"()I");

  /// from: public final int getMeasuredHeight()
  int getMeasuredHeight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMeasuredHeight, jni.JniCallType.intType, []).integer;
  }

  static final _id_getMeasuredHeightAndState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMeasuredHeightAndState", r"()I");

  /// from: public final int getMeasuredHeightAndState()
  int getMeasuredHeightAndState() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getMeasuredHeightAndState, jni.JniCallType.intType, []).integer;
  }

  static final _id_getMeasuredState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMeasuredState", r"()I");

  /// from: public final int getMeasuredState()
  int getMeasuredState() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMeasuredState, jni.JniCallType.intType, []).integer;
  }

  static final _id_getMatrix = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getMatrix", r"()Landroid/graphics/Matrix;");

  /// from: public android.graphics.Matrix getMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMatrix() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMatrix, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCameraDistance = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getCameraDistance", r"()F");

  /// from: public float getCameraDistance()
  double getCameraDistance() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCameraDistance, jni.JniCallType.floatType, []).float;
  }

  static final _id_setCameraDistance = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setCameraDistance", r"(F)V");

  /// from: public void setCameraDistance(float f)
  void setCameraDistance(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setCameraDistance,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f)]).check();
  }

  static final _id_getRotation =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getRotation", r"()F");

  /// from: public float getRotation()
  double getRotation() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRotation, jni.JniCallType.floatType, []).float;
  }

  static final _id_setRotation = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setRotation", r"(F)V");

  /// from: public void setRotation(float f)
  void setRotation(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setRotation,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getRotationY = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRotationY", r"()F");

  /// from: public float getRotationY()
  double getRotationY() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRotationY, jni.JniCallType.floatType, []).float;
  }

  static final _id_setRotationY = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setRotationY", r"(F)V");

  /// from: public void setRotationY(float f)
  void setRotationY(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setRotationY,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getRotationX = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRotationX", r"()F");

  /// from: public float getRotationX()
  double getRotationX() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRotationX, jni.JniCallType.floatType, []).float;
  }

  static final _id_setRotationX = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setRotationX", r"(F)V");

  /// from: public void setRotationX(float f)
  void setRotationX(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setRotationX,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getScaleX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getScaleX", r"()F");

  /// from: public float getScaleX()
  double getScaleX() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScaleX, jni.JniCallType.floatType, []).float;
  }

  static final _id_setScaleX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setScaleX", r"(F)V");

  /// from: public void setScaleX(float f)
  void setScaleX(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setScaleX,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getScaleY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getScaleY", r"()F");

  /// from: public float getScaleY()
  double getScaleY() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScaleY, jni.JniCallType.floatType, []).float;
  }

  static final _id_setScaleY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setScaleY", r"(F)V");

  /// from: public void setScaleY(float f)
  void setScaleY(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setScaleY,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getPivotX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getPivotX", r"()F");

  /// from: public float getPivotX()
  double getPivotX() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPivotX, jni.JniCallType.floatType, []).float;
  }

  static final _id_setPivotX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setPivotX", r"(F)V");

  /// from: public void setPivotX(float f)
  void setPivotX(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setPivotX,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getPivotY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getPivotY", r"()F");

  /// from: public float getPivotY()
  double getPivotY() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPivotY, jni.JniCallType.floatType, []).float;
  }

  static final _id_setPivotY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setPivotY", r"(F)V");

  /// from: public void setPivotY(float f)
  void setPivotY(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setPivotY,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_isPivotSet =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isPivotSet", r"()Z");

  /// from: public boolean isPivotSet()
  bool isPivotSet() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isPivotSet, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_resetPivot =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"resetPivot", r"()V");

  /// from: public void resetPivot()
  void resetPivot() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_resetPivot, jni.JniCallType.voidType, []).check();
  }

  static final _id_getAlpha =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getAlpha", r"()F");

  /// from: public float getAlpha()
  double getAlpha() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAlpha, jni.JniCallType.floatType, []).float;
  }

  static final _id_forceHasOverlappingRendering = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"forceHasOverlappingRendering", r"(Z)V");

  /// from: public void forceHasOverlappingRendering(boolean z)
  void forceHasOverlappingRendering(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_forceHasOverlappingRendering,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_getHasOverlappingRendering = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHasOverlappingRendering", r"()Z");

  /// from: public final boolean getHasOverlappingRendering()
  bool getHasOverlappingRendering() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHasOverlappingRendering,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_hasOverlappingRendering = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasOverlappingRendering", r"()Z");

  /// from: public boolean hasOverlappingRendering()
  bool hasOverlappingRendering() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasOverlappingRendering, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setAlpha =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setAlpha", r"(F)V");

  /// from: public void setAlpha(float f)
  void setAlpha(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setAlpha,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_setTransitionAlpha = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTransitionAlpha", r"(F)V");

  /// from: public void setTransitionAlpha(float f)
  void setTransitionAlpha(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setTransitionAlpha,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f)]).check();
  }

  static final _id_getTransitionAlpha = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTransitionAlpha", r"()F");

  /// from: public float getTransitionAlpha()
  double getTransitionAlpha() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTransitionAlpha, jni.JniCallType.floatType, []).float;
  }

  static final _id_setForceDarkAllowed = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setForceDarkAllowed", r"(Z)V");

  /// from: public void setForceDarkAllowed(boolean z)
  void setForceDarkAllowed(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_setForceDarkAllowed, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isForceDarkAllowed = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isForceDarkAllowed", r"()Z");

  /// from: public boolean isForceDarkAllowed()
  bool isForceDarkAllowed() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isForceDarkAllowed, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getTop =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getTop", r"()I");

  /// from: public final int getTop()
  int getTop() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTop, jni.JniCallType.intType, []).integer;
  }

  static final _id_setTop =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setTop", r"(I)V");

  /// from: public final void setTop(int i)
  void setTop(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTop,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getBottom =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getBottom", r"()I");

  /// from: public final int getBottom()
  int getBottom() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBottom, jni.JniCallType.intType, []).integer;
  }

  static final _id_isDirty =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDirty", r"()Z");

  /// from: public boolean isDirty()
  bool isDirty() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDirty, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setBottom =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setBottom", r"(I)V");

  /// from: public final void setBottom(int i)
  void setBottom(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setBottom,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getLeft =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getLeft", r"()I");

  /// from: public final int getLeft()
  int getLeft() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLeft, jni.JniCallType.intType, []).integer;
  }

  static final _id_setLeft =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setLeft", r"(I)V");

  /// from: public final void setLeft(int i)
  void setLeft(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLeft,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getRight =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getRight", r"()I");

  /// from: public final int getRight()
  int getRight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRight, jni.JniCallType.intType, []).integer;
  }

  static final _id_setRight =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setRight", r"(I)V");

  /// from: public final void setRight(int i)
  void setRight(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setRight,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getX", r"()F");

  /// from: public float getX()
  double getX() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getX, jni.JniCallType.floatType, []).float;
  }

  static final _id_setX =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setX", r"(F)V");

  /// from: public void setX(float f)
  void setX(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setX,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getY", r"()F");

  /// from: public float getY()
  double getY() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getY, jni.JniCallType.floatType, []).float;
  }

  static final _id_setY =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setY", r"(F)V");

  /// from: public void setY(float f)
  void setY(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setY,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getZ =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getZ", r"()F");

  /// from: public float getZ()
  double getZ() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getZ, jni.JniCallType.floatType, []).float;
  }

  static final _id_setZ =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setZ", r"(F)V");

  /// from: public void setZ(float f)
  void setZ(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setZ,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getElevation = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getElevation", r"()F");

  /// from: public float getElevation()
  double getElevation() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getElevation, jni.JniCallType.floatType, []).float;
  }

  static final _id_setElevation = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setElevation", r"(F)V");

  /// from: public void setElevation(float f)
  void setElevation(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setElevation,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getTranslationX = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTranslationX", r"()F");

  /// from: public float getTranslationX()
  double getTranslationX() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTranslationX, jni.JniCallType.floatType, []).float;
  }

  static final _id_setTranslationX = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTranslationX", r"(F)V");

  /// from: public void setTranslationX(float f)
  void setTranslationX(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTranslationX,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getTranslationY = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTranslationY", r"()F");

  /// from: public float getTranslationY()
  double getTranslationY() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTranslationY, jni.JniCallType.floatType, []).float;
  }

  static final _id_setTranslationY = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTranslationY", r"(F)V");

  /// from: public void setTranslationY(float f)
  void setTranslationY(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTranslationY,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_getTranslationZ = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTranslationZ", r"()F");

  /// from: public float getTranslationZ()
  double getTranslationZ() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTranslationZ, jni.JniCallType.floatType, []).float;
  }

  static final _id_setTranslationZ = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTranslationZ", r"(F)V");

  /// from: public void setTranslationZ(float f)
  void setTranslationZ(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTranslationZ,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_setAnimationMatrix = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setAnimationMatrix", r"(Landroid/graphics/Matrix;)V");

  /// from: public void setAnimationMatrix(android.graphics.Matrix matrix)
  void setAnimationMatrix(
    jni.JObject matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAnimationMatrix,
        jni.JniCallType.voidType,
        [matrix.reference]).check();
  }

  static final _id_getAnimationMatrix = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getAnimationMatrix", r"()Landroid/graphics/Matrix;");

  /// from: public android.graphics.Matrix getAnimationMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAnimationMatrix() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAnimationMatrix,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getStateListAnimator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getStateListAnimator",
      r"()Landroid/animation/StateListAnimator;");

  /// from: public android.animation.StateListAnimator getStateListAnimator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getStateListAnimator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getStateListAnimator,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setStateListAnimator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setStateListAnimator",
      r"(Landroid/animation/StateListAnimator;)V");

  /// from: public void setStateListAnimator(android.animation.StateListAnimator stateListAnimator)
  void setStateListAnimator(
    jni.JObject stateListAnimator,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setStateListAnimator,
        jni.JniCallType.voidType,
        [stateListAnimator.reference]).check();
  }

  static final _id_getClipToOutline = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getClipToOutline", r"()Z");

  /// from: public final boolean getClipToOutline()
  bool getClipToOutline() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getClipToOutline,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setClipToOutline = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setClipToOutline", r"(Z)V");

  /// from: public void setClipToOutline(boolean z)
  void setClipToOutline(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setClipToOutline,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_setOutlineProvider = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setOutlineProvider",
      r"(Landroid/view/ViewOutlineProvider;)V");

  /// from: public void setOutlineProvider(android.view.ViewOutlineProvider viewOutlineProvider)
  void setOutlineProvider(
    jni.JObject viewOutlineProvider,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOutlineProvider,
        jni.JniCallType.voidType,
        [viewOutlineProvider.reference]).check();
  }

  static final _id_getOutlineProvider = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getOutlineProvider",
      r"()Landroid/view/ViewOutlineProvider;");

  /// from: public android.view.ViewOutlineProvider getOutlineProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOutlineProvider() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getOutlineProvider,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_invalidateOutline = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"invalidateOutline", r"()V");

  /// from: public void invalidateOutline()
  void invalidateOutline() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_invalidateOutline, jni.JniCallType.voidType, []).check();
  }

  static final _id_setOutlineSpotShadowColor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOutlineSpotShadowColor", r"(I)V");

  /// from: public void setOutlineSpotShadowColor(int i)
  void setOutlineSpotShadowColor(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOutlineSpotShadowColor,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getOutlineSpotShadowColor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getOutlineSpotShadowColor", r"()I");

  /// from: public int getOutlineSpotShadowColor()
  int getOutlineSpotShadowColor() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getOutlineSpotShadowColor, jni.JniCallType.intType, []).integer;
  }

  static final _id_setOutlineAmbientShadowColor = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setOutlineAmbientShadowColor", r"(I)V");

  /// from: public void setOutlineAmbientShadowColor(int i)
  void setOutlineAmbientShadowColor(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOutlineAmbientShadowColor,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getOutlineAmbientShadowColor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getOutlineAmbientShadowColor", r"()I");

  /// from: public int getOutlineAmbientShadowColor()
  int getOutlineAmbientShadowColor() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getOutlineAmbientShadowColor, jni.JniCallType.intType, []).integer;
  }

  static final _id_getHitRect = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getHitRect", r"(Landroid/graphics/Rect;)V");

  /// from: public void getHitRect(android.graphics.Rect rect)
  void getHitRect(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getHitRect,
        jni.JniCallType.voidType, [rect.reference]).check();
  }

  static final _id_getFocusedRect = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getFocusedRect", r"(Landroid/graphics/Rect;)V");

  /// from: public void getFocusedRect(android.graphics.Rect rect)
  void getFocusedRect(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getFocusedRect,
        jni.JniCallType.voidType, [rect.reference]).check();
  }

  static final _id_getGlobalVisibleRect = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getGlobalVisibleRect",
      r"(Landroid/graphics/Rect;Landroid/graphics/Point;)Z");

  /// from: public boolean getGlobalVisibleRect(android.graphics.Rect rect, android.graphics.Point point)
  bool getGlobalVisibleRect(
    jni.JObject rect,
    jni.JObject point,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getGlobalVisibleRect,
        jni.JniCallType.booleanType,
        [rect.reference, point.reference]).boolean;
  }

  static final _id_getGlobalVisibleRect1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getGlobalVisibleRect", r"(Landroid/graphics/Rect;)Z");

  /// from: public final boolean getGlobalVisibleRect(android.graphics.Rect rect)
  bool getGlobalVisibleRect1(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getGlobalVisibleRect1,
        jni.JniCallType.booleanType,
        [rect.reference]).boolean;
  }

  static final _id_getLocalVisibleRect = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getLocalVisibleRect", r"(Landroid/graphics/Rect;)Z");

  /// from: public final boolean getLocalVisibleRect(android.graphics.Rect rect)
  bool getLocalVisibleRect(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLocalVisibleRect,
        jni.JniCallType.booleanType,
        [rect.reference]).boolean;
  }

  static final _id_offsetTopAndBottom = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"offsetTopAndBottom", r"(I)V");

  /// from: public void offsetTopAndBottom(int i)
  void offsetTopAndBottom(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_offsetTopAndBottom,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_offsetLeftAndRight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"offsetLeftAndRight", r"(I)V");

  /// from: public void offsetLeftAndRight(int i)
  void offsetLeftAndRight(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_offsetLeftAndRight,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getLayoutParams = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getLayoutParams",
      r"()Landroid/view/ViewGroup$LayoutParams;");

  /// from: public android.view.ViewGroup$LayoutParams getLayoutParams()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLayoutParams() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLayoutParams, jni.JniCallType.objectType, []).object);
  }

  static final _id_setLayoutParams = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setLayoutParams",
      r"(Landroid/view/ViewGroup$LayoutParams;)V");

  /// from: public void setLayoutParams(android.view.ViewGroup$LayoutParams layoutParams)
  void setLayoutParams(
    jni.JObject layoutParams,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLayoutParams,
        jni.JniCallType.voidType, [layoutParams.reference]).check();
  }

  static final _id_scrollTo =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"scrollTo", r"(II)V");

  /// from: public void scrollTo(int i, int i1)
  void scrollTo(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_scrollTo,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_scrollBy =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"scrollBy", r"(II)V");

  /// from: public void scrollBy(int i, int i1)
  void scrollBy(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_scrollBy,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_awakenScrollBars = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"awakenScrollBars", r"()Z");

  /// from: protected boolean awakenScrollBars()
  bool awakenScrollBars() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_awakenScrollBars,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_awakenScrollBars1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"awakenScrollBars", r"(I)Z");

  /// from: protected boolean awakenScrollBars(int i)
  bool awakenScrollBars1(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_awakenScrollBars1,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_awakenScrollBars2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"awakenScrollBars", r"(IZ)Z");

  /// from: protected boolean awakenScrollBars(int i, boolean z)
  bool awakenScrollBars2(
    int i,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_awakenScrollBars2,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), z ? 1 : 0]).boolean;
  }

  static final _id_invalidate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"invalidate", r"(Landroid/graphics/Rect;)V");

  /// from: public void invalidate(android.graphics.Rect rect)
  void invalidate(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_invalidate,
        jni.JniCallType.voidType, [rect.reference]).check();
  }

  static final _id_invalidate1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"invalidate", r"(IIII)V");

  /// from: public void invalidate(int i, int i1, int i2, int i3)
  void invalidate1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_invalidate1, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_invalidate2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"invalidate", r"()V");

  /// from: public void invalidate()
  void invalidate2() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_invalidate2, jni.JniCallType.voidType, []).check();
  }

  static final _id_isOpaque =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isOpaque", r"()Z");

  /// from: public boolean isOpaque()
  bool isOpaque() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isOpaque, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getHandler = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getHandler", r"()Landroid/os/Handler;");

  /// from: public android.os.Handler getHandler()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHandler() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHandler, jni.JniCallType.objectType, []).object);
  }

  static final _id_post = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"post", r"(Ljava/lang/Runnable;)Z");

  /// from: public boolean post(java.lang.Runnable runnable)
  bool post(
    jni.JObject runnable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_post,
        jni.JniCallType.booleanType, [runnable.reference]).boolean;
  }

  static final _id_postDelayed = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"postDelayed", r"(Ljava/lang/Runnable;J)Z");

  /// from: public boolean postDelayed(java.lang.Runnable runnable, long j)
  bool postDelayed(
    jni.JObject runnable,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_postDelayed,
        jni.JniCallType.booleanType, [runnable.reference, j]).boolean;
  }

  static final _id_postOnAnimation = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"postOnAnimation", r"(Ljava/lang/Runnable;)V");

  /// from: public void postOnAnimation(java.lang.Runnable runnable)
  void postOnAnimation(
    jni.JObject runnable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_postOnAnimation,
        jni.JniCallType.voidType, [runnable.reference]).check();
  }

  static final _id_postOnAnimationDelayed = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"postOnAnimationDelayed", r"(Ljava/lang/Runnable;J)V");

  /// from: public void postOnAnimationDelayed(java.lang.Runnable runnable, long j)
  void postOnAnimationDelayed(
    jni.JObject runnable,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_postOnAnimationDelayed,
        jni.JniCallType.voidType,
        [runnable.reference, j]).check();
  }

  static final _id_removeCallbacks = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"removeCallbacks", r"(Ljava/lang/Runnable;)Z");

  /// from: public boolean removeCallbacks(java.lang.Runnable runnable)
  bool removeCallbacks(
    jni.JObject runnable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_removeCallbacks,
        jni.JniCallType.booleanType, [runnable.reference]).boolean;
  }

  static final _id_postInvalidate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"postInvalidate", r"()V");

  /// from: public void postInvalidate()
  void postInvalidate() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_postInvalidate, jni.JniCallType.voidType, []).check();
  }

  static final _id_postInvalidate1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"postInvalidate", r"(IIII)V");

  /// from: public void postInvalidate(int i, int i1, int i2, int i3)
  void postInvalidate1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_postInvalidate1, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_postInvalidateDelayed = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"postInvalidateDelayed", r"(J)V");

  /// from: public void postInvalidateDelayed(long j)
  void postInvalidateDelayed(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_postInvalidateDelayed, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_postInvalidateDelayed1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"postInvalidateDelayed", r"(JIIII)V");

  /// from: public void postInvalidateDelayed(long j, int i, int i1, int i2, int i3)
  void postInvalidateDelayed1(
    int j,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_postInvalidateDelayed1, jni.JniCallType.voidType, [
      j,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_postInvalidateOnAnimation = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"postInvalidateOnAnimation", r"()V");

  /// from: public void postInvalidateOnAnimation()
  void postInvalidateOnAnimation() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_postInvalidateOnAnimation, jni.JniCallType.voidType, []).check();
  }

  static final _id_postInvalidateOnAnimation1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"postInvalidateOnAnimation", r"(IIII)V");

  /// from: public void postInvalidateOnAnimation(int i, int i1, int i2, int i3)
  void postInvalidateOnAnimation1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_postInvalidateOnAnimation1, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_computeScroll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeScroll", r"()V");

  /// from: public void computeScroll()
  void computeScroll() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_computeScroll, jni.JniCallType.voidType, []).check();
  }

  static final _id_isHorizontalFadingEdgeEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"isHorizontalFadingEdgeEnabled", r"()Z");

  /// from: public boolean isHorizontalFadingEdgeEnabled()
  bool isHorizontalFadingEdgeEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isHorizontalFadingEdgeEnabled,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setHorizontalFadingEdgeEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setHorizontalFadingEdgeEnabled", r"(Z)V");

  /// from: public void setHorizontalFadingEdgeEnabled(boolean z)
  void setHorizontalFadingEdgeEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHorizontalFadingEdgeEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isVerticalFadingEdgeEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isVerticalFadingEdgeEnabled", r"()Z");

  /// from: public boolean isVerticalFadingEdgeEnabled()
  bool isVerticalFadingEdgeEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isVerticalFadingEdgeEnabled,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setVerticalFadingEdgeEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setVerticalFadingEdgeEnabled", r"(Z)V");

  /// from: public void setVerticalFadingEdgeEnabled(boolean z)
  void setVerticalFadingEdgeEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setVerticalFadingEdgeEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_getTopFadingEdgeStrength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTopFadingEdgeStrength", r"()F");

  /// from: protected float getTopFadingEdgeStrength()
  double getTopFadingEdgeStrength() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getTopFadingEdgeStrength, jni.JniCallType.floatType, []).float;
  }

  static final _id_getBottomFadingEdgeStrength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBottomFadingEdgeStrength", r"()F");

  /// from: protected float getBottomFadingEdgeStrength()
  double getBottomFadingEdgeStrength() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getBottomFadingEdgeStrength, jni.JniCallType.floatType, []).float;
  }

  static final _id_getLeftFadingEdgeStrength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLeftFadingEdgeStrength", r"()F");

  /// from: protected float getLeftFadingEdgeStrength()
  double getLeftFadingEdgeStrength() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getLeftFadingEdgeStrength, jni.JniCallType.floatType, []).float;
  }

  static final _id_getRightFadingEdgeStrength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRightFadingEdgeStrength", r"()F");

  /// from: protected float getRightFadingEdgeStrength()
  double getRightFadingEdgeStrength() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getRightFadingEdgeStrength, jni.JniCallType.floatType, []).float;
  }

  static final _id_isHorizontalScrollBarEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isHorizontalScrollBarEnabled", r"()Z");

  /// from: public boolean isHorizontalScrollBarEnabled()
  bool isHorizontalScrollBarEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isHorizontalScrollBarEnabled,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setHorizontalScrollBarEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setHorizontalScrollBarEnabled", r"(Z)V");

  /// from: public void setHorizontalScrollBarEnabled(boolean z)
  void setHorizontalScrollBarEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHorizontalScrollBarEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isVerticalScrollBarEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isVerticalScrollBarEnabled", r"()Z");

  /// from: public boolean isVerticalScrollBarEnabled()
  bool isVerticalScrollBarEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isVerticalScrollBarEnabled,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setVerticalScrollBarEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setVerticalScrollBarEnabled", r"(Z)V");

  /// from: public void setVerticalScrollBarEnabled(boolean z)
  void setVerticalScrollBarEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setVerticalScrollBarEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_setScrollbarFadingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollbarFadingEnabled", r"(Z)V");

  /// from: public void setScrollbarFadingEnabled(boolean z)
  void setScrollbarFadingEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollbarFadingEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isScrollbarFadingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isScrollbarFadingEnabled", r"()Z");

  /// from: public boolean isScrollbarFadingEnabled()
  bool isScrollbarFadingEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isScrollbarFadingEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getScrollBarDefaultDelayBeforeFade = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getScrollBarDefaultDelayBeforeFade", r"()I");

  /// from: public int getScrollBarDefaultDelayBeforeFade()
  int getScrollBarDefaultDelayBeforeFade() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getScrollBarDefaultDelayBeforeFade,
        jni.JniCallType.intType, []).integer;
  }

  static final _id_setScrollBarDefaultDelayBeforeFade = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setScrollBarDefaultDelayBeforeFade", r"(I)V");

  /// from: public void setScrollBarDefaultDelayBeforeFade(int i)
  void setScrollBarDefaultDelayBeforeFade(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollBarDefaultDelayBeforeFade,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getScrollBarFadeDuration = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getScrollBarFadeDuration", r"()I");

  /// from: public int getScrollBarFadeDuration()
  int getScrollBarFadeDuration() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getScrollBarFadeDuration, jni.JniCallType.intType, []).integer;
  }

  static final _id_setScrollBarFadeDuration = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollBarFadeDuration", r"(I)V");

  /// from: public void setScrollBarFadeDuration(int i)
  void setScrollBarFadeDuration(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollBarFadeDuration,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getScrollBarSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getScrollBarSize", r"()I");

  /// from: public int getScrollBarSize()
  int getScrollBarSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScrollBarSize, jni.JniCallType.intType, []).integer;
  }

  static final _id_setScrollBarSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollBarSize", r"(I)V");

  /// from: public void setScrollBarSize(int i)
  void setScrollBarSize(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setScrollBarSize,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_setScrollBarStyle = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollBarStyle", r"(I)V");

  /// from: public void setScrollBarStyle(int i)
  void setScrollBarStyle(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollBarStyle,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getScrollBarStyle = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getScrollBarStyle", r"()I");

  /// from: public int getScrollBarStyle()
  int getScrollBarStyle() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScrollBarStyle, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeHorizontalScrollRange = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeHorizontalScrollRange", r"()I");

  /// from: protected int computeHorizontalScrollRange()
  int computeHorizontalScrollRange() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeHorizontalScrollRange, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeHorizontalScrollOffset = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"computeHorizontalScrollOffset", r"()I");

  /// from: protected int computeHorizontalScrollOffset()
  int computeHorizontalScrollOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeHorizontalScrollOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeHorizontalScrollExtent = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"computeHorizontalScrollExtent", r"()I");

  /// from: protected int computeHorizontalScrollExtent()
  int computeHorizontalScrollExtent() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeHorizontalScrollExtent, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeVerticalScrollRange = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeVerticalScrollRange", r"()I");

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeVerticalScrollRange, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeVerticalScrollOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeVerticalScrollOffset", r"()I");

  /// from: protected int computeVerticalScrollOffset()
  int computeVerticalScrollOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeVerticalScrollOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeVerticalScrollExtent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeVerticalScrollExtent", r"()I");

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeVerticalScrollExtent, jni.JniCallType.intType, []).integer;
  }

  static final _id_canScrollHorizontally = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canScrollHorizontally", r"(I)Z");

  /// from: public boolean canScrollHorizontally(int i)
  bool canScrollHorizontally(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canScrollHorizontally,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_canScrollVertically = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canScrollVertically", r"(I)Z");

  /// from: public boolean canScrollVertically(int i)
  bool canScrollVertically(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canScrollVertically,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_onDrawScrollBars = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDrawScrollBars", r"(Landroid/graphics/Canvas;)V");

  /// from: protected final void onDrawScrollBars(android.graphics.Canvas canvas)
  void onDrawScrollBars(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDrawScrollBars,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_onDraw = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDraw", r"(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDraw,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_onAttachedToWindow = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onAttachedToWindow", r"()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onAttachedToWindow, jni.JniCallType.voidType, []).check();
  }

  static final _id_onScreenStateChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onScreenStateChanged", r"(I)V");

  /// from: public void onScreenStateChanged(int i)
  void onScreenStateChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onScreenStateChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_onRtlPropertiesChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onRtlPropertiesChanged", r"(I)V");

  /// from: public void onRtlPropertiesChanged(int i)
  void onRtlPropertiesChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onRtlPropertiesChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_canResolveLayoutDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canResolveLayoutDirection", r"()Z");

  /// from: public boolean canResolveLayoutDirection()
  bool canResolveLayoutDirection() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_canResolveLayoutDirection, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isLayoutDirectionResolved = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isLayoutDirectionResolved", r"()Z");

  /// from: public boolean isLayoutDirectionResolved()
  bool isLayoutDirectionResolved() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isLayoutDirectionResolved, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_onDetachedFromWindow = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onDetachedFromWindow", r"()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onDetachedFromWindow, jni.JniCallType.voidType, []).check();
  }

  static final _id_getWindowAttachCount = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getWindowAttachCount", r"()I");

  /// from: protected int getWindowAttachCount()
  int getWindowAttachCount() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getWindowAttachCount, jni.JniCallType.intType, []).integer;
  }

  static final _id_getWindowToken = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getWindowToken", r"()Landroid/os/IBinder;");

  /// from: public android.os.IBinder getWindowToken()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowToken() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getWindowToken, jni.JniCallType.objectType, []).object);
  }

  static final _id_getWindowId = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getWindowId", r"()Landroid/view/WindowId;");

  /// from: public android.view.WindowId getWindowId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowId() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getWindowId, jni.JniCallType.objectType, []).object);
  }

  static final _id_getApplicationWindowToken = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getApplicationWindowToken",
      r"()Landroid/os/IBinder;");

  /// from: public android.os.IBinder getApplicationWindowToken()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getApplicationWindowToken() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getApplicationWindowToken,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getDisplay = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getDisplay", r"()Landroid/view/Display;");

  /// from: public android.view.Display getDisplay()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDisplay() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getDisplay, jni.JniCallType.objectType, []).object);
  }

  static final _id_cancelPendingInputEvents = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cancelPendingInputEvents", r"()V");

  /// from: public final void cancelPendingInputEvents()
  void cancelPendingInputEvents() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_cancelPendingInputEvents, jni.JniCallType.voidType, []).check();
  }

  static final _id_onCancelPendingInputEvents = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onCancelPendingInputEvents", r"()V");

  /// from: public void onCancelPendingInputEvents()
  void onCancelPendingInputEvents() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onCancelPendingInputEvents, jni.JniCallType.voidType, []).check();
  }

  static final _id_saveHierarchyState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"saveHierarchyState",
      r"(Landroid/util/SparseArray;)V");

  /// from: public void saveHierarchyState(android.util.SparseArray sparseArray)
  void saveHierarchyState(
    jni.JObject sparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_saveHierarchyState,
        jni.JniCallType.voidType,
        [sparseArray.reference]).check();
  }

  static final _id_dispatchSaveInstanceState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchSaveInstanceState",
      r"(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchSaveInstanceState(android.util.SparseArray sparseArray)
  void dispatchSaveInstanceState(
    jni.JObject sparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchSaveInstanceState,
        jni.JniCallType.voidType,
        [sparseArray.reference]).check();
  }

  static final _id_onSaveInstanceState = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onSaveInstanceState", r"()Landroid/os/Parcelable;");

  /// from: protected android.os.Parcelable onSaveInstanceState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onSaveInstanceState() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onSaveInstanceState,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_restoreHierarchyState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"restoreHierarchyState",
      r"(Landroid/util/SparseArray;)V");

  /// from: public void restoreHierarchyState(android.util.SparseArray sparseArray)
  void restoreHierarchyState(
    jni.JObject sparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_restoreHierarchyState,
        jni.JniCallType.voidType,
        [sparseArray.reference]).check();
  }

  static final _id_dispatchRestoreInstanceState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchRestoreInstanceState",
          r"(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchRestoreInstanceState(android.util.SparseArray sparseArray)
  void dispatchRestoreInstanceState(
    jni.JObject sparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchRestoreInstanceState,
        jni.JniCallType.voidType,
        [sparseArray.reference]).check();
  }

  static final _id_onRestoreInstanceState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onRestoreInstanceState",
      r"(Landroid/os/Parcelable;)V");

  /// from: protected void onRestoreInstanceState(android.os.Parcelable parcelable)
  void onRestoreInstanceState(
    jni.JObject parcelable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onRestoreInstanceState,
        jni.JniCallType.voidType,
        [parcelable.reference]).check();
  }

  static final _id_getDrawingTime = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getDrawingTime", r"()J");

  /// from: public long getDrawingTime()
  int getDrawingTime() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getDrawingTime, jni.JniCallType.longType, []).long;
  }

  static final _id_setDuplicateParentStateEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setDuplicateParentStateEnabled", r"(Z)V");

  /// from: public void setDuplicateParentStateEnabled(boolean z)
  void setDuplicateParentStateEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDuplicateParentStateEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isDuplicateParentStateEnabled = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"isDuplicateParentStateEnabled", r"()Z");

  /// from: public boolean isDuplicateParentStateEnabled()
  bool isDuplicateParentStateEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isDuplicateParentStateEnabled,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setLayerType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setLayerType", r"(ILandroid/graphics/Paint;)V");

  /// from: public void setLayerType(int i, android.graphics.Paint paint)
  void setLayerType(
    int i,
    jni.JObject paint,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLayerType,
        jni.JniCallType.voidType, [jni.JValueInt(i), paint.reference]).check();
  }

  static final _id_setRenderEffect = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setRenderEffect",
      r"(Landroid/graphics/RenderEffect;)V");

  /// from: public void setRenderEffect(android.graphics.RenderEffect renderEffect)
  void setRenderEffect(
    jni.JObject renderEffect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setRenderEffect,
        jni.JniCallType.voidType, [renderEffect.reference]).check();
  }

  static final _id_setLayerPaint = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setLayerPaint", r"(Landroid/graphics/Paint;)V");

  /// from: public void setLayerPaint(android.graphics.Paint paint)
  void setLayerPaint(
    jni.JObject paint,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLayerPaint,
        jni.JniCallType.voidType, [paint.reference]).check();
  }

  static final _id_getLayerType = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLayerType", r"()I");

  /// from: public int getLayerType()
  int getLayerType() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLayerType, jni.JniCallType.intType, []).integer;
  }

  static final _id_buildLayer =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"buildLayer", r"()V");

  /// from: public void buildLayer()
  void buildLayer() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buildLayer, jni.JniCallType.voidType, []).check();
  }

  static final _id_setDrawingCacheEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setDrawingCacheEnabled", r"(Z)V");

  /// from: public void setDrawingCacheEnabled(boolean z)
  void setDrawingCacheEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDrawingCacheEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isDrawingCacheEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isDrawingCacheEnabled", r"()Z");

  /// from: public boolean isDrawingCacheEnabled()
  bool isDrawingCacheEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isDrawingCacheEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getDrawingCache = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getDrawingCache", r"()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getDrawingCache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDrawingCache() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getDrawingCache, jni.JniCallType.objectType, []).object);
  }

  static final _id_getDrawingCache1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getDrawingCache", r"(Z)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getDrawingCache(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDrawingCache1(
    bool z,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDrawingCache1,
        jni.JniCallType.objectType,
        [z ? 1 : 0]).object);
  }

  static final _id_destroyDrawingCache = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"destroyDrawingCache", r"()V");

  /// from: public void destroyDrawingCache()
  void destroyDrawingCache() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_destroyDrawingCache, jni.JniCallType.voidType, []).check();
  }

  static final _id_setDrawingCacheBackgroundColor = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setDrawingCacheBackgroundColor", r"(I)V");

  /// from: public void setDrawingCacheBackgroundColor(int i)
  void setDrawingCacheBackgroundColor(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDrawingCacheBackgroundColor,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getDrawingCacheBackgroundColor = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getDrawingCacheBackgroundColor", r"()I");

  /// from: public int getDrawingCacheBackgroundColor()
  int getDrawingCacheBackgroundColor() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDrawingCacheBackgroundColor,
        jni.JniCallType.intType, []).integer;
  }

  static final _id_buildDrawingCache = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buildDrawingCache", r"()V");

  /// from: public void buildDrawingCache()
  void buildDrawingCache() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buildDrawingCache, jni.JniCallType.voidType, []).check();
  }

  static final _id_buildDrawingCache1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buildDrawingCache", r"(Z)V");

  /// from: public void buildDrawingCache(boolean z)
  void buildDrawingCache1(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_buildDrawingCache1, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isInEditMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isInEditMode", r"()Z");

  /// from: public boolean isInEditMode()
  bool isInEditMode() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isInEditMode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isPaddingOffsetRequired = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isPaddingOffsetRequired", r"()Z");

  /// from: protected boolean isPaddingOffsetRequired()
  bool isPaddingOffsetRequired() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isPaddingOffsetRequired, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getLeftPaddingOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLeftPaddingOffset", r"()I");

  /// from: protected int getLeftPaddingOffset()
  int getLeftPaddingOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getLeftPaddingOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_getRightPaddingOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRightPaddingOffset", r"()I");

  /// from: protected int getRightPaddingOffset()
  int getRightPaddingOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getRightPaddingOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_getTopPaddingOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTopPaddingOffset", r"()I");

  /// from: protected int getTopPaddingOffset()
  int getTopPaddingOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getTopPaddingOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_getBottomPaddingOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBottomPaddingOffset", r"()I");

  /// from: protected int getBottomPaddingOffset()
  int getBottomPaddingOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getBottomPaddingOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_isHardwareAccelerated = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isHardwareAccelerated", r"()Z");

  /// from: public boolean isHardwareAccelerated()
  bool isHardwareAccelerated() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isHardwareAccelerated, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setClipBounds = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setClipBounds", r"(Landroid/graphics/Rect;)V");

  /// from: public void setClipBounds(android.graphics.Rect rect)
  void setClipBounds(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setClipBounds,
        jni.JniCallType.voidType, [rect.reference]).check();
  }

  static final _id_getClipBounds = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getClipBounds", r"()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getClipBounds()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getClipBounds() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getClipBounds, jni.JniCallType.objectType, []).object);
  }

  static final _id_getClipBounds1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getClipBounds", r"(Landroid/graphics/Rect;)Z");

  /// from: public boolean getClipBounds(android.graphics.Rect rect)
  bool getClipBounds1(
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getClipBounds1,
        jni.JniCallType.booleanType, [rect.reference]).boolean;
  }

  static final _id_draw = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"draw", r"(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_draw,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_getOverlay = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getOverlay", r"()Landroid/view/ViewOverlay;");

  /// from: public android.view.ViewOverlay getOverlay()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOverlay() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getOverlay, jni.JniCallType.objectType, []).object);
  }

  static final _id_getSolidColor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSolidColor", r"()I");

  /// from: public int getSolidColor()
  int getSolidColor() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getSolidColor, jni.JniCallType.intType, []).integer;
  }

  static final _id_isLayoutRequested = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isLayoutRequested", r"()Z");

  /// from: public boolean isLayoutRequested()
  bool isLayoutRequested() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isLayoutRequested, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_layout =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"layout", r"(IIII)V");

  /// from: public void layout(int i, int i1, int i2, int i3)
  void layout(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_layout, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_onLayout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onLayout", r"(ZIIII)V");

  /// from: protected void onLayout(boolean z, int i, int i1, int i2, int i3)
  void onLayout(
    bool z,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_onLayout, jni.JniCallType.voidType, [
      z ? 1 : 0,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_setLeftTopRightBottom = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setLeftTopRightBottom", r"(IIII)V");

  /// from: public final void setLeftTopRightBottom(int i, int i1, int i2, int i3)
  void setLeftTopRightBottom(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setLeftTopRightBottom, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_onFinishInflate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onFinishInflate", r"()V");

  /// from: protected void onFinishInflate()
  void onFinishInflate() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onFinishInflate, jni.JniCallType.voidType, []).check();
  }

  static final _id_getResources = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getResources", r"()Landroid/content/res/Resources;");

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getResources() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getResources, jni.JniCallType.objectType, []).object);
  }

  static final _id_invalidateDrawable = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"invalidateDrawable",
      r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable drawable)
  void invalidateDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_invalidateDrawable,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_scheduleDrawable = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"scheduleDrawable",
      r"(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V");

  /// from: public void scheduleDrawable(android.graphics.drawable.Drawable drawable, java.lang.Runnable runnable, long j)
  void scheduleDrawable(
    jni.JObject drawable,
    jni.JObject runnable,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_scheduleDrawable,
        jni.JniCallType.voidType,
        [drawable.reference, runnable.reference, j]).check();
  }

  static final _id_unscheduleDrawable = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"unscheduleDrawable",
      r"(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable drawable, java.lang.Runnable runnable)
  void unscheduleDrawable(
    jni.JObject drawable,
    jni.JObject runnable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_unscheduleDrawable,
        jni.JniCallType.voidType,
        [drawable.reference, runnable.reference]).check();
  }

  static final _id_unscheduleDrawable1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"unscheduleDrawable",
      r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable drawable)
  void unscheduleDrawable1(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_unscheduleDrawable1,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_verifyDrawable = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"verifyDrawable",
      r"(Landroid/graphics/drawable/Drawable;)Z");

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable drawable)
  bool verifyDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_verifyDrawable,
        jni.JniCallType.booleanType, [drawable.reference]).boolean;
  }

  static final _id_drawableStateChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"drawableStateChanged", r"()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_drawableStateChanged, jni.JniCallType.voidType, []).check();
  }

  static final _id_drawableHotspotChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"drawableHotspotChanged", r"(FF)V");

  /// from: public void drawableHotspotChanged(float f, float f1)
  void drawableHotspotChanged(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_drawableHotspotChanged,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_dispatchDrawableHotspotChanged = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"dispatchDrawableHotspotChanged", r"(FF)V");

  /// from: public void dispatchDrawableHotspotChanged(float f, float f1)
  void dispatchDrawableHotspotChanged(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchDrawableHotspotChanged,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_refreshDrawableState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"refreshDrawableState", r"()V");

  /// from: public void refreshDrawableState()
  void refreshDrawableState() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_refreshDrawableState, jni.JniCallType.voidType, []).check();
  }

  static final _id_getDrawableState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getDrawableState", r"()[I");

  /// from: public final int[] getDrawableState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getDrawableState() {
    return const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getDrawableState,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_onCreateDrawableState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onCreateDrawableState", r"(I)[I");

  /// from: protected int[] onCreateDrawableState(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> onCreateDrawableState(
    int i,
  ) {
    return const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_onCreateDrawableState,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_mergeDrawableStates = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"mergeDrawableStates", r"([I[I)[I");

  /// from: static protected int[] mergeDrawableStates(int[] is, int[] is1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> mergeDrawableStates(
    jni.JArray<jni.jint> is0,
    jni.JArray<jni.jint> is1,
  ) {
    return const jni.JArrayType(jni.jintType()).fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_mergeDrawableStates,
            jni.JniCallType.objectType, [is0.reference, is1.reference]).object);
  }

  static final _id_jumpDrawablesToCurrentState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"jumpDrawablesToCurrentState", r"()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_jumpDrawablesToCurrentState, jni.JniCallType.voidType, []).check();
  }

  static final _id_setBackgroundColor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setBackgroundColor", r"(I)V");

  /// from: public void setBackgroundColor(int i)
  void setBackgroundColor(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundColor,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setBackgroundResource = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setBackgroundResource", r"(I)V");

  /// from: public void setBackgroundResource(int i)
  void setBackgroundResource(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundResource,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setBackground = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setBackground",
      r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setBackground(android.graphics.drawable.Drawable drawable)
  void setBackground(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setBackground,
        jni.JniCallType.voidType, [drawable.reference]).check();
  }

  static final _id_setBackgroundDrawable = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setBackgroundDrawable",
      r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setBackgroundDrawable(android.graphics.drawable.Drawable drawable)
  void setBackgroundDrawable(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundDrawable,
        jni.JniCallType.voidType,
        [drawable.reference]).check();
  }

  static final _id_getBackground = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getBackground",
      r"()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBackground()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackground() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBackground, jni.JniCallType.objectType, []).object);
  }

  static final _id_setBackgroundTintList = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setBackgroundTintList",
      r"(Landroid/content/res/ColorStateList;)V");

  /// from: public void setBackgroundTintList(android.content.res.ColorStateList colorStateList)
  void setBackgroundTintList(
    jni.JObject colorStateList,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundTintList,
        jni.JniCallType.voidType,
        [colorStateList.reference]).check();
  }

  static final _id_getBackgroundTintList = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getBackgroundTintList",
      r"()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getBackgroundTintList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackgroundTintList() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getBackgroundTintList,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setBackgroundTintMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setBackgroundTintMode",
      r"(Landroid/graphics/PorterDuff$Mode;)V");

  /// from: public void setBackgroundTintMode(android.graphics.PorterDuff$Mode mode)
  void setBackgroundTintMode(
    jni.JObject mode,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundTintMode,
        jni.JniCallType.voidType,
        [mode.reference]).check();
  }

  static final _id_setBackgroundTintBlendMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setBackgroundTintBlendMode",
      r"(Landroid/graphics/BlendMode;)V");

  /// from: public void setBackgroundTintBlendMode(android.graphics.BlendMode blendMode)
  void setBackgroundTintBlendMode(
    jni.JObject blendMode,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundTintBlendMode,
        jni.JniCallType.voidType,
        [blendMode.reference]).check();
  }

  static final _id_getBackgroundTintMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getBackgroundTintMode",
      r"()Landroid/graphics/PorterDuff$Mode;");

  /// from: public android.graphics.PorterDuff$Mode getBackgroundTintMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackgroundTintMode() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getBackgroundTintMode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getBackgroundTintBlendMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getBackgroundTintBlendMode",
      r"()Landroid/graphics/BlendMode;");

  /// from: public android.graphics.BlendMode getBackgroundTintBlendMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBackgroundTintBlendMode() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getBackgroundTintBlendMode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getForeground = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getForeground",
      r"()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getForeground()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForeground() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getForeground, jni.JniCallType.objectType, []).object);
  }

  static final _id_setForeground = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setForeground",
      r"(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setForeground(android.graphics.drawable.Drawable drawable)
  void setForeground(
    jni.JObject drawable,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setForeground,
        jni.JniCallType.voidType, [drawable.reference]).check();
  }

  static final _id_getForegroundGravity = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getForegroundGravity", r"()I");

  /// from: public int getForegroundGravity()
  int getForegroundGravity() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getForegroundGravity, jni.JniCallType.intType, []).integer;
  }

  static final _id_setForegroundGravity = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setForegroundGravity", r"(I)V");

  /// from: public void setForegroundGravity(int i)
  void setForegroundGravity(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setForegroundGravity,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setForegroundTintList = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setForegroundTintList",
      r"(Landroid/content/res/ColorStateList;)V");

  /// from: public void setForegroundTintList(android.content.res.ColorStateList colorStateList)
  void setForegroundTintList(
    jni.JObject colorStateList,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setForegroundTintList,
        jni.JniCallType.voidType,
        [colorStateList.reference]).check();
  }

  static final _id_getForegroundTintList = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getForegroundTintList",
      r"()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getForegroundTintList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForegroundTintList() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getForegroundTintList,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setForegroundTintMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setForegroundTintMode",
      r"(Landroid/graphics/PorterDuff$Mode;)V");

  /// from: public void setForegroundTintMode(android.graphics.PorterDuff$Mode mode)
  void setForegroundTintMode(
    jni.JObject mode,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setForegroundTintMode,
        jni.JniCallType.voidType,
        [mode.reference]).check();
  }

  static final _id_setForegroundTintBlendMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setForegroundTintBlendMode",
      r"(Landroid/graphics/BlendMode;)V");

  /// from: public void setForegroundTintBlendMode(android.graphics.BlendMode blendMode)
  void setForegroundTintBlendMode(
    jni.JObject blendMode,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setForegroundTintBlendMode,
        jni.JniCallType.voidType,
        [blendMode.reference]).check();
  }

  static final _id_getForegroundTintMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getForegroundTintMode",
      r"()Landroid/graphics/PorterDuff$Mode;");

  /// from: public android.graphics.PorterDuff$Mode getForegroundTintMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForegroundTintMode() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getForegroundTintMode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getForegroundTintBlendMode = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getForegroundTintBlendMode",
      r"()Landroid/graphics/BlendMode;");

  /// from: public android.graphics.BlendMode getForegroundTintBlendMode()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getForegroundTintBlendMode() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getForegroundTintBlendMode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onDrawForeground = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDrawForeground", r"(Landroid/graphics/Canvas;)V");

  /// from: public void onDrawForeground(android.graphics.Canvas canvas)
  void onDrawForeground(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDrawForeground,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_setPadding = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setPadding", r"(IIII)V");

  /// from: public void setPadding(int i, int i1, int i2, int i3)
  void setPadding(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setPadding, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_setPaddingRelative = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setPaddingRelative", r"(IIII)V");

  /// from: public void setPaddingRelative(int i, int i1, int i2, int i3)
  void setPaddingRelative(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setPaddingRelative, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_getSourceLayoutResId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSourceLayoutResId", r"()I");

  /// from: public int getSourceLayoutResId()
  int getSourceLayoutResId() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getSourceLayoutResId, jni.JniCallType.intType, []).integer;
  }

  static final _id_getPaddingTop = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPaddingTop", r"()I");

  /// from: public int getPaddingTop()
  int getPaddingTop() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPaddingTop, jni.JniCallType.intType, []).integer;
  }

  static final _id_getPaddingBottom = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPaddingBottom", r"()I");

  /// from: public int getPaddingBottom()
  int getPaddingBottom() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPaddingBottom, jni.JniCallType.intType, []).integer;
  }

  static final _id_getPaddingLeft = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPaddingLeft", r"()I");

  /// from: public int getPaddingLeft()
  int getPaddingLeft() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPaddingLeft, jni.JniCallType.intType, []).integer;
  }

  static final _id_getPaddingStart = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPaddingStart", r"()I");

  /// from: public int getPaddingStart()
  int getPaddingStart() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPaddingStart, jni.JniCallType.intType, []).integer;
  }

  static final _id_getPaddingRight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPaddingRight", r"()I");

  /// from: public int getPaddingRight()
  int getPaddingRight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPaddingRight, jni.JniCallType.intType, []).integer;
  }

  static final _id_getPaddingEnd = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPaddingEnd", r"()I");

  /// from: public int getPaddingEnd()
  int getPaddingEnd() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPaddingEnd, jni.JniCallType.intType, []).integer;
  }

  static final _id_isPaddingRelative = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isPaddingRelative", r"()Z");

  /// from: public boolean isPaddingRelative()
  bool isPaddingRelative() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isPaddingRelative, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setSelected = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSelected", r"(Z)V");

  /// from: public void setSelected(boolean z)
  void setSelected(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setSelected,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_dispatchSetSelected = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchSetSelected", r"(Z)V");

  /// from: protected void dispatchSetSelected(boolean z)
  void dispatchSetSelected(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_dispatchSetSelected, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isSelected =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isSelected", r"()Z");

  /// from: public boolean isSelected()
  bool isSelected() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isSelected, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setActivated = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setActivated", r"(Z)V");

  /// from: public void setActivated(boolean z)
  void setActivated(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setActivated,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_dispatchSetActivated = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchSetActivated", r"(Z)V");

  /// from: protected void dispatchSetActivated(boolean z)
  void dispatchSetActivated(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchSetActivated,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isActivated =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isActivated", r"()Z");

  /// from: public boolean isActivated()
  bool isActivated() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isActivated, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getViewTreeObserver = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getViewTreeObserver",
      r"()Landroid/view/ViewTreeObserver;");

  /// from: public android.view.ViewTreeObserver getViewTreeObserver()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getViewTreeObserver() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getViewTreeObserver,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getRootView = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getRootView", r"()Landroid/view/View;");

  /// from: public android.view.View getRootView()
  /// The returned object must be released after use, by calling the [release] method.
  View getRootView() {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRootView, jni.JniCallType.objectType, []).object);
  }

  static final _id_transformMatrixToGlobal = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"transformMatrixToGlobal",
      r"(Landroid/graphics/Matrix;)V");

  /// from: public void transformMatrixToGlobal(android.graphics.Matrix matrix)
  void transformMatrixToGlobal(
    jni.JObject matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_transformMatrixToGlobal,
        jni.JniCallType.voidType,
        [matrix.reference]).check();
  }

  static final _id_transformMatrixToLocal = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"transformMatrixToLocal",
      r"(Landroid/graphics/Matrix;)V");

  /// from: public void transformMatrixToLocal(android.graphics.Matrix matrix)
  void transformMatrixToLocal(
    jni.JObject matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_transformMatrixToLocal,
        jni.JniCallType.voidType,
        [matrix.reference]).check();
  }

  static final _id_getLocationOnScreen = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLocationOnScreen", r"([I)V");

  /// from: public void getLocationOnScreen(int[] is)
  void getLocationOnScreen(
    jni.JArray<jni.jint> is0,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLocationOnScreen,
        jni.JniCallType.voidType,
        [is0.reference]).check();
  }

  static final _id_getLocationInWindow = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getLocationInWindow", r"([I)V");

  /// from: public void getLocationInWindow(int[] is)
  void getLocationInWindow(
    jni.JArray<jni.jint> is0,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLocationInWindow,
        jni.JniCallType.voidType,
        [is0.reference]).check();
  }

  static final _id_findViewById = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"findViewById", r"(I)Landroid/view/View;");

  /// from: public final T findViewById(int i)
  /// The returned object must be released after use, by calling the [release] method.
  $T findViewById<$T extends jni.JObject>(
    int i, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_findViewById,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_requireViewById = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"requireViewById", r"(I)Landroid/view/View;");

  /// from: public final T requireViewById(int i)
  /// The returned object must be released after use, by calling the [release] method.
  $T requireViewById<$T extends jni.JObject>(
    int i, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requireViewById,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_findViewWithTag = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"findViewWithTag",
      r"(Ljava/lang/Object;)Landroid/view/View;");

  /// from: public final T findViewWithTag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  $T findViewWithTag<$T extends jni.JObject>(
    jni.JObject object, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_findViewWithTag,
        jni.JniCallType.objectType,
        [object.reference]).object);
  }

  static final _id_setId =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setId", r"(I)V");

  /// from: public void setId(int i)
  void setId(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setId,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getId =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getId", r"()I");

  /// from: public int getId()
  int getId() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getId, jni.JniCallType.intType, []).integer;
  }

  static final _id_getUniqueDrawingId = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getUniqueDrawingId", r"()J");

  /// from: public long getUniqueDrawingId()
  int getUniqueDrawingId() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getUniqueDrawingId, jni.JniCallType.longType, []).long;
  }

  static final _id_getTag = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTag", r"()Ljava/lang/Object;");

  /// from: public java.lang.Object getTag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTag() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTag, jni.JniCallType.objectType, []).object);
  }

  static final _id_setTag = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTag", r"(Ljava/lang/Object;)V");

  /// from: public void setTag(java.lang.Object object)
  void setTag(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTag,
        jni.JniCallType.voidType, [object.reference]).check();
  }

  static final _id_getTag1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTag", r"(I)Ljava/lang/Object;");

  /// from: public java.lang.Object getTag(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTag1(
    int i,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getTag1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_setTag1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTag", r"(ILjava/lang/Object;)V");

  /// from: public void setTag(int i, java.lang.Object object)
  void setTag1(
    int i,
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTag1,
        jni.JniCallType.voidType, [jni.JValueInt(i), object.reference]).check();
  }

  static final _id_getBaseline =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getBaseline", r"()I");

  /// from: public int getBaseline()
  int getBaseline() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBaseline, jni.JniCallType.intType, []).integer;
  }

  static final _id_isInLayout =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isInLayout", r"()Z");

  /// from: public boolean isInLayout()
  bool isInLayout() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isInLayout, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_requestLayout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestLayout", r"()V");

  /// from: public void requestLayout()
  void requestLayout() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_requestLayout, jni.JniCallType.voidType, []).check();
  }

  static final _id_forceLayout =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"forceLayout", r"()V");

  /// from: public void forceLayout()
  void forceLayout() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_forceLayout, jni.JniCallType.voidType, []).check();
  }

  static final _id_measure =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"measure", r"(II)V");

  /// from: public final void measure(int i, int i1)
  void measure(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_measure,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_onMeasure =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onMeasure", r"(II)V");

  /// from: protected void onMeasure(int i, int i1)
  void onMeasure(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onMeasure,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_setMeasuredDimension = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setMeasuredDimension", r"(II)V");

  /// from: protected final void setMeasuredDimension(int i, int i1)
  void setMeasuredDimension(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setMeasuredDimension,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_combineMeasuredStates = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference, r"combineMeasuredStates", r"(II)I");

  /// from: static public int combineMeasuredStates(int i, int i1)
  static int combineMeasuredStates(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_combineMeasuredStates,
        jni.JniCallType.intType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_resolveSize = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"resolveSize", r"(II)I");

  /// from: static public int resolveSize(int i, int i1)
  static int resolveSize(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_resolveSize,
        jni.JniCallType.intType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_resolveSizeAndState = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"resolveSizeAndState", r"(III)I");

  /// from: static public int resolveSizeAndState(int i, int i1, int i2)
  static int resolveSizeAndState(
    int i,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_resolveSizeAndState,
        jni.JniCallType.intType,
        [jni.JValueInt(i), jni.JValueInt(i1), jni.JValueInt(i2)]).integer;
  }

  static final _id_getDefaultSize = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getDefaultSize", r"(II)I");

  /// from: static public int getDefaultSize(int i, int i1)
  static int getDefaultSize(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_getDefaultSize,
        jni.JniCallType.intType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_getSuggestedMinimumHeight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSuggestedMinimumHeight", r"()I");

  /// from: protected int getSuggestedMinimumHeight()
  int getSuggestedMinimumHeight() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getSuggestedMinimumHeight, jni.JniCallType.intType, []).integer;
  }

  static final _id_getSuggestedMinimumWidth = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSuggestedMinimumWidth", r"()I");

  /// from: protected int getSuggestedMinimumWidth()
  int getSuggestedMinimumWidth() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getSuggestedMinimumWidth, jni.JniCallType.intType, []).integer;
  }

  static final _id_getMinimumHeight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMinimumHeight", r"()I");

  /// from: public int getMinimumHeight()
  int getMinimumHeight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMinimumHeight, jni.JniCallType.intType, []).integer;
  }

  static final _id_setMinimumHeight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setMinimumHeight", r"(I)V");

  /// from: public void setMinimumHeight(int i)
  void setMinimumHeight(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setMinimumHeight,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getMinimumWidth = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getMinimumWidth", r"()I");

  /// from: public int getMinimumWidth()
  int getMinimumWidth() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMinimumWidth, jni.JniCallType.intType, []).integer;
  }

  static final _id_setMinimumWidth = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setMinimumWidth", r"(I)V");

  /// from: public void setMinimumWidth(int i)
  void setMinimumWidth(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setMinimumWidth,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getAnimation = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAnimation",
      r"()Landroid/view/animation/Animation;");

  /// from: public android.view.animation.Animation getAnimation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAnimation() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAnimation, jni.JniCallType.objectType, []).object);
  }

  static final _id_startAnimation = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"startAnimation",
      r"(Landroid/view/animation/Animation;)V");

  /// from: public void startAnimation(android.view.animation.Animation animation)
  void startAnimation(
    jni.JObject animation,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_startAnimation,
        jni.JniCallType.voidType, [animation.reference]).check();
  }

  static final _id_clearAnimation = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearAnimation", r"()V");

  /// from: public void clearAnimation()
  void clearAnimation() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearAnimation, jni.JniCallType.voidType, []).check();
  }

  static final _id_setAnimation = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setAnimation",
      r"(Landroid/view/animation/Animation;)V");

  /// from: public void setAnimation(android.view.animation.Animation animation)
  void setAnimation(
    jni.JObject animation,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setAnimation,
        jni.JniCallType.voidType, [animation.reference]).check();
  }

  static final _id_onAnimationStart = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onAnimationStart", r"()V");

  /// from: protected void onAnimationStart()
  void onAnimationStart() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onAnimationStart, jni.JniCallType.voidType, []).check();
  }

  static final _id_onAnimationEnd = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onAnimationEnd", r"()V");

  /// from: protected void onAnimationEnd()
  void onAnimationEnd() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onAnimationEnd, jni.JniCallType.voidType, []).check();
  }

  static final _id_onSetAlpha =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onSetAlpha", r"(I)Z");

  /// from: protected boolean onSetAlpha(int i)
  bool onSetAlpha(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onSetAlpha,
        jni.JniCallType.booleanType, [jni.JValueInt(i)]).boolean;
  }

  static final _id_gatherTransparentRegion = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"gatherTransparentRegion",
      r"(Landroid/graphics/Region;)Z");

  /// from: public boolean gatherTransparentRegion(android.graphics.Region region)
  bool gatherTransparentRegion(
    jni.JObject region,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_gatherTransparentRegion,
        jni.JniCallType.booleanType,
        [region.reference]).boolean;
  }

  static final _id_playSoundEffect = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"playSoundEffect", r"(I)V");

  /// from: public void playSoundEffect(int i)
  void playSoundEffect(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_playSoundEffect,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_performHapticFeedback = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performHapticFeedback", r"(I)Z");

  /// from: public boolean performHapticFeedback(int i)
  bool performHapticFeedback(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performHapticFeedback,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_performHapticFeedback1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performHapticFeedback", r"(II)Z");

  /// from: public boolean performHapticFeedback(int i, int i1)
  bool performHapticFeedback1(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_performHapticFeedback1,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).boolean;
  }

  static final _id_setSystemUiVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setSystemUiVisibility", r"(I)V");

  /// from: public void setSystemUiVisibility(int i)
  void setSystemUiVisibility(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setSystemUiVisibility,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_getSystemUiVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSystemUiVisibility", r"()I");

  /// from: public int getSystemUiVisibility()
  int getSystemUiVisibility() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getSystemUiVisibility, jni.JniCallType.intType, []).integer;
  }

  static final _id_getWindowSystemUiVisibility = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getWindowSystemUiVisibility", r"()I");

  /// from: public int getWindowSystemUiVisibility()
  int getWindowSystemUiVisibility() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getWindowSystemUiVisibility, jni.JniCallType.intType, []).integer;
  }

  static final _id_onWindowSystemUiVisibilityChanged = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"onWindowSystemUiVisibilityChanged", r"(I)V");

  /// from: public void onWindowSystemUiVisibilityChanged(int i)
  void onWindowSystemUiVisibilityChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onWindowSystemUiVisibilityChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_dispatchWindowSystemUiVisiblityChanged = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"dispatchWindowSystemUiVisiblityChanged", r"(I)V");

  /// from: public void dispatchWindowSystemUiVisiblityChanged(int i)
  void dispatchWindowSystemUiVisiblityChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchWindowSystemUiVisiblityChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setOnSystemUiVisibilityChangeListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOnSystemUiVisibilityChangeListener",
          r"(Landroid/view/View$OnSystemUiVisibilityChangeListener;)V");

  /// from: public void setOnSystemUiVisibilityChangeListener(android.view.View$OnSystemUiVisibilityChangeListener onSystemUiVisibilityChangeListener)
  void setOnSystemUiVisibilityChangeListener(
    View_OnSystemUiVisibilityChangeListener onSystemUiVisibilityChangeListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnSystemUiVisibilityChangeListener,
        jni.JniCallType.voidType,
        [onSystemUiVisibilityChangeListener.reference]).check();
  }

  static final _id_dispatchSystemUiVisibilityChanged = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"dispatchSystemUiVisibilityChanged", r"(I)V");

  /// from: public void dispatchSystemUiVisibilityChanged(int i)
  void dispatchSystemUiVisibilityChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchSystemUiVisibilityChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_startDrag = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"startDrag",
      r"(Landroid/content/ClipData;Landroid/view/View$DragShadowBuilder;Ljava/lang/Object;I)Z");

  /// from: public final boolean startDrag(android.content.ClipData clipData, android.view.View$DragShadowBuilder dragShadowBuilder, java.lang.Object object, int i)
  bool startDrag(
    jni.JObject clipData,
    View_DragShadowBuilder dragShadowBuilder,
    jni.JObject object,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_startDrag, jni.JniCallType.booleanType, [
      clipData.reference,
      dragShadowBuilder.reference,
      object.reference,
      jni.JValueInt(i)
    ]).boolean;
  }

  static final _id_startDragAndDrop = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"startDragAndDrop",
      r"(Landroid/content/ClipData;Landroid/view/View$DragShadowBuilder;Ljava/lang/Object;I)Z");

  /// from: public final boolean startDragAndDrop(android.content.ClipData clipData, android.view.View$DragShadowBuilder dragShadowBuilder, java.lang.Object object, int i)
  bool startDragAndDrop(
    jni.JObject clipData,
    View_DragShadowBuilder dragShadowBuilder,
    jni.JObject object,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_startDragAndDrop, jni.JniCallType.booleanType, [
      clipData.reference,
      dragShadowBuilder.reference,
      object.reference,
      jni.JValueInt(i)
    ]).boolean;
  }

  static final _id_cancelDragAndDrop = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cancelDragAndDrop", r"()V");

  /// from: public final void cancelDragAndDrop()
  void cancelDragAndDrop() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cancelDragAndDrop, jni.JniCallType.voidType, []).check();
  }

  static final _id_updateDragShadow = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"updateDragShadow",
      r"(Landroid/view/View$DragShadowBuilder;)V");

  /// from: public final void updateDragShadow(android.view.View$DragShadowBuilder dragShadowBuilder)
  void updateDragShadow(
    View_DragShadowBuilder dragShadowBuilder,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_updateDragShadow,
        jni.JniCallType.voidType, [dragShadowBuilder.reference]).check();
  }

  static final _id_onDragEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDragEvent", r"(Landroid/view/DragEvent;)Z");

  /// from: public boolean onDragEvent(android.view.DragEvent dragEvent)
  bool onDragEvent(
    jni.JObject dragEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDragEvent,
        jni.JniCallType.booleanType, [dragEvent.reference]).boolean;
  }

  static final _id_dispatchDragEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchDragEvent", r"(Landroid/view/DragEvent;)Z");

  /// from: public boolean dispatchDragEvent(android.view.DragEvent dragEvent)
  bool dispatchDragEvent(
    jni.JObject dragEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchDragEvent,
        jni.JniCallType.booleanType,
        [dragEvent.reference]).boolean;
  }

  static final _id_inflate = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"inflate",
      r"(Landroid/content/Context;ILandroid/view/ViewGroup;)Landroid/view/View;");

  /// from: static public android.view.View inflate(android.content.Context context, int i, android.view.ViewGroup viewGroup)
  /// The returned object must be released after use, by calling the [release] method.
  static View inflate(
    jni.JObject context,
    int i,
    jni.JObject viewGroup,
  ) {
    return const $ViewType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_inflate,
        jni.JniCallType.objectType,
        [context.reference, jni.JValueInt(i), viewGroup.reference]).object);
  }

  static final _id_overScrollBy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"overScrollBy", r"(IIIIIIIIZ)Z");

  /// from: protected boolean overScrollBy(int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7, boolean z)
  bool overScrollBy(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_overScrollBy, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3),
      jni.JValueInt(i4),
      jni.JValueInt(i5),
      jni.JValueInt(i6),
      jni.JValueInt(i7),
      z ? 1 : 0
    ]).boolean;
  }

  static final _id_onOverScrolled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onOverScrolled", r"(IIZZ)V");

  /// from: protected void onOverScrolled(int i, int i1, boolean z, boolean z1)
  void onOverScrolled(
    int i,
    int i1,
    bool z,
    bool z1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onOverScrolled,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1), z ? 1 : 0, z1 ? 1 : 0]).check();
  }

  static final _id_getOverScrollMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getOverScrollMode", r"()I");

  /// from: public int getOverScrollMode()
  int getOverScrollMode() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getOverScrollMode, jni.JniCallType.intType, []).integer;
  }

  static final _id_setOverScrollMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOverScrollMode", r"(I)V");

  /// from: public void setOverScrollMode(int i)
  void setOverScrollMode(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOverScrollMode,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setNestedScrollingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNestedScrollingEnabled", r"(Z)V");

  /// from: public void setNestedScrollingEnabled(boolean z)
  void setNestedScrollingEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setNestedScrollingEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isNestedScrollingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isNestedScrollingEnabled", r"()Z");

  /// from: public boolean isNestedScrollingEnabled()
  bool isNestedScrollingEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isNestedScrollingEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_startNestedScroll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"startNestedScroll", r"(I)Z");

  /// from: public boolean startNestedScroll(int i)
  bool startNestedScroll(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_startNestedScroll,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_stopNestedScroll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"stopNestedScroll", r"()V");

  /// from: public void stopNestedScroll()
  void stopNestedScroll() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_stopNestedScroll, jni.JniCallType.voidType, []).check();
  }

  static final _id_hasNestedScrollingParent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasNestedScrollingParent", r"()Z");

  /// from: public boolean hasNestedScrollingParent()
  bool hasNestedScrollingParent() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasNestedScrollingParent, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_dispatchNestedScroll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchNestedScroll", r"(IIII[I)Z");

  /// from: public boolean dispatchNestedScroll(int i, int i1, int i2, int i3, int[] is)
  bool dispatchNestedScroll(
    int i,
    int i1,
    int i2,
    int i3,
    jni.JArray<jni.jint> is0,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dispatchNestedScroll, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3),
      is0.reference
    ]).boolean;
  }

  static final _id_dispatchNestedPreScroll = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchNestedPreScroll", r"(II[I[I)Z");

  /// from: public boolean dispatchNestedPreScroll(int i, int i1, int[] is, int[] is1)
  bool dispatchNestedPreScroll(
    int i,
    int i1,
    jni.JArray<jni.jint> is0,
    jni.JArray<jni.jint> is1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dispatchNestedPreScroll, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      is0.reference,
      is1.reference
    ]).boolean;
  }

  static final _id_dispatchNestedFling = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchNestedFling", r"(FFZ)Z");

  /// from: public boolean dispatchNestedFling(float f, float f1, boolean z)
  bool dispatchNestedFling(
    double f,
    double f1,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchNestedFling,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1), z ? 1 : 0]).boolean;
  }

  static final _id_dispatchNestedPreFling = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchNestedPreFling", r"(FF)Z");

  /// from: public boolean dispatchNestedPreFling(float f, float f1)
  bool dispatchNestedPreFling(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchNestedPreFling,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).boolean;
  }

  static final _id_setTextDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTextDirection", r"(I)V");

  /// from: public void setTextDirection(int i)
  void setTextDirection(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTextDirection,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getTextDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTextDirection", r"()I");

  /// from: public int getTextDirection()
  int getTextDirection() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTextDirection, jni.JniCallType.intType, []).integer;
  }

  static final _id_canResolveTextDirection = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canResolveTextDirection", r"()Z");

  /// from: public boolean canResolveTextDirection()
  bool canResolveTextDirection() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_canResolveTextDirection, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isTextDirectionResolved = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isTextDirectionResolved", r"()Z");

  /// from: public boolean isTextDirectionResolved()
  bool isTextDirectionResolved() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isTextDirectionResolved, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setTextAlignment = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setTextAlignment", r"(I)V");

  /// from: public void setTextAlignment(int i)
  void setTextAlignment(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTextAlignment,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_getTextAlignment = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTextAlignment", r"()I");

  /// from: public int getTextAlignment()
  int getTextAlignment() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTextAlignment, jni.JniCallType.intType, []).integer;
  }

  static final _id_canResolveTextAlignment = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canResolveTextAlignment", r"()Z");

  /// from: public boolean canResolveTextAlignment()
  bool canResolveTextAlignment() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_canResolveTextAlignment, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isTextAlignmentResolved = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isTextAlignmentResolved", r"()Z");

  /// from: public boolean isTextAlignmentResolved()
  bool isTextAlignmentResolved() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isTextAlignmentResolved, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_generateViewId = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"generateViewId", r"()I");

  /// from: static public int generateViewId()
  static int generateViewId() {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_generateViewId, jni.JniCallType.intType, []).integer;
  }

  static final _id_onResolvePointerIcon = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onResolvePointerIcon",
      r"(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent motionEvent, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onResolvePointerIcon(
    jni.JObject motionEvent,
    int i,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onResolvePointerIcon,
        jni.JniCallType.objectType,
        [motionEvent.reference, jni.JValueInt(i)]).object);
  }

  static final _id_setPointerIcon = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setPointerIcon", r"(Landroid/view/PointerIcon;)V");

  /// from: public void setPointerIcon(android.view.PointerIcon pointerIcon)
  void setPointerIcon(
    jni.JObject pointerIcon,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setPointerIcon,
        jni.JniCallType.voidType, [pointerIcon.reference]).check();
  }

  static final _id_getPointerIcon = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getPointerIcon", r"()Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon getPointerIcon()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getPointerIcon() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPointerIcon, jni.JniCallType.objectType, []).object);
  }

  static final _id_hasPointerCapture = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hasPointerCapture", r"()Z");

  /// from: public boolean hasPointerCapture()
  bool hasPointerCapture() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_hasPointerCapture, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_requestPointerCapture = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestPointerCapture", r"()V");

  /// from: public void requestPointerCapture()
  void requestPointerCapture() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_requestPointerCapture, jni.JniCallType.voidType, []).check();
  }

  static final _id_releasePointerCapture = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"releasePointerCapture", r"()V");

  /// from: public void releasePointerCapture()
  void releasePointerCapture() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_releasePointerCapture, jni.JniCallType.voidType, []).check();
  }

  static final _id_onPointerCaptureChange = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onPointerCaptureChange", r"(Z)V");

  /// from: public void onPointerCaptureChange(boolean z)
  void onPointerCaptureChange(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onPointerCaptureChange,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_dispatchPointerCaptureChanged = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"dispatchPointerCaptureChanged", r"(Z)V");

  /// from: public void dispatchPointerCaptureChanged(boolean z)
  void dispatchPointerCaptureChanged(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchPointerCaptureChanged,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_onCapturedPointerEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onCapturedPointerEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onCapturedPointerEvent(android.view.MotionEvent motionEvent)
  bool onCapturedPointerEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCapturedPointerEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_setOnCapturedPointerListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOnCapturedPointerListener",
          r"(Landroid/view/View$OnCapturedPointerListener;)V");

  /// from: public void setOnCapturedPointerListener(android.view.View$OnCapturedPointerListener onCapturedPointerListener)
  void setOnCapturedPointerListener(
    View_OnCapturedPointerListener onCapturedPointerListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOnCapturedPointerListener,
        jni.JniCallType.voidType,
        [onCapturedPointerListener.reference]).check();
  }

  static final _id_animate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"animate", r"()Landroid/view/ViewPropertyAnimator;");

  /// from: public android.view.ViewPropertyAnimator animate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject animate() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_animate, jni.JniCallType.objectType, []).object);
  }

  static final _id_setTransitionName = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setTransitionName", r"(Ljava/lang/String;)V");

  /// from: public final void setTransitionName(java.lang.String string)
  void setTransitionName(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setTransitionName,
        jni.JniCallType.voidType,
        [string.reference]).check();
  }

  static final _id_getTransitionName = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getTransitionName", r"()Ljava/lang/String;");

  /// from: public java.lang.String getTransitionName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTransitionName() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getTransitionName,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getScrollCaptureHint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getScrollCaptureHint", r"()I");

  /// from: public int getScrollCaptureHint()
  int getScrollCaptureHint() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getScrollCaptureHint, jni.JniCallType.intType, []).integer;
  }

  static final _id_setScrollCaptureHint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollCaptureHint", r"(I)V");

  /// from: public void setScrollCaptureHint(int i)
  void setScrollCaptureHint(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollCaptureHint,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setScrollCaptureCallback = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setScrollCaptureCallback",
      r"(Landroid/view/ScrollCaptureCallback;)V");

  /// from: public final void setScrollCaptureCallback(android.view.ScrollCaptureCallback scrollCaptureCallback)
  void setScrollCaptureCallback(
    jni.JObject scrollCaptureCallback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollCaptureCallback,
        jni.JniCallType.voidType,
        [scrollCaptureCallback.reference]).check();
  }

  static final _id_dispatchScrollCaptureSearch = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatchScrollCaptureSearch",
      r"(Landroid/graphics/Rect;Landroid/graphics/Point;Ljava/util/function/Consumer;)V");

  /// from: public void dispatchScrollCaptureSearch(android.graphics.Rect rect, android.graphics.Point point, java.util.function.Consumer consumer)
  void dispatchScrollCaptureSearch(
    jni.JObject rect,
    jni.JObject point,
    jni.JObject consumer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_dispatchScrollCaptureSearch,
        jni.JniCallType.voidType,
        [rect.reference, point.reference, consumer.reference]).check();
  }

  static final _id_onScrollCaptureSearch = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onScrollCaptureSearch",
      r"(Landroid/graphics/Rect;Landroid/graphics/Point;Ljava/util/function/Consumer;)V");

  /// from: public void onScrollCaptureSearch(android.graphics.Rect rect, android.graphics.Point point, java.util.function.Consumer consumer)
  void onScrollCaptureSearch(
    jni.JObject rect,
    jni.JObject point,
    jni.JObject consumer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onScrollCaptureSearch,
        jni.JniCallType.voidType,
        [rect.reference, point.reference, consumer.reference]).check();
  }

  static final _id_setTooltipText = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setTooltipText", r"(Ljava/lang/CharSequence;)V");

  /// from: public void setTooltipText(java.lang.CharSequence charSequence)
  void setTooltipText(
    jni.JObject charSequence,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setTooltipText,
        jni.JniCallType.voidType, [charSequence.reference]).check();
  }

  static final _id_getTooltipText = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getTooltipText", r"()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTooltipText()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTooltipText() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTooltipText, jni.JniCallType.objectType, []).object);
  }

  static final _id_addOnUnhandledKeyEventListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"addOnUnhandledKeyEventListener",
          r"(Landroid/view/View$OnUnhandledKeyEventListener;)V");

  /// from: public void addOnUnhandledKeyEventListener(android.view.View$OnUnhandledKeyEventListener onUnhandledKeyEventListener)
  void addOnUnhandledKeyEventListener(
    View_OnUnhandledKeyEventListener onUnhandledKeyEventListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addOnUnhandledKeyEventListener,
        jni.JniCallType.voidType,
        [onUnhandledKeyEventListener.reference]).check();
  }

  static final _id_removeOnUnhandledKeyEventListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"removeOnUnhandledKeyEventListener",
          r"(Landroid/view/View$OnUnhandledKeyEventListener;)V");

  /// from: public void removeOnUnhandledKeyEventListener(android.view.View$OnUnhandledKeyEventListener onUnhandledKeyEventListener)
  void removeOnUnhandledKeyEventListener(
    View_OnUnhandledKeyEventListener onUnhandledKeyEventListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeOnUnhandledKeyEventListener,
        jni.JniCallType.voidType,
        [onUnhandledKeyEventListener.reference]).check();
  }

  static final _id_setIsCredential = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setIsCredential", r"(Z)V");

  /// from: public void setIsCredential(boolean z)
  void setIsCredential(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setIsCredential,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_isCredential = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isCredential", r"()Z");

  /// from: public boolean isCredential()
  bool isCredential() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isCredential, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setAutoHandwritingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setAutoHandwritingEnabled", r"(Z)V");

  /// from: public void setAutoHandwritingEnabled(boolean z)
  void setAutoHandwritingEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setAutoHandwritingEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_isAutoHandwritingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isAutoHandwritingEnabled", r"()Z");

  /// from: public boolean isAutoHandwritingEnabled()
  bool isAutoHandwritingEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isAutoHandwritingEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_onCreateViewTranslationRequest = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onCreateViewTranslationRequest",
          r"([ILjava/util/function/Consumer;)V");

  /// from: public void onCreateViewTranslationRequest(java.lang.Object[] is, java.util.function.Consumer consumer)
  void onCreateViewTranslationRequest(
    jni.JArray<jni.jint> is0,
    jni.JObject consumer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCreateViewTranslationRequest,
        jni.JniCallType.voidType,
        [is0.reference, consumer.reference]).check();
  }

  static final _id_onCreateVirtualViewTranslationRequests = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference,
          r"onCreateVirtualViewTranslationRequests",
          r"([J[ILjava/util/function/Consumer;)V");

  /// from: public void onCreateVirtualViewTranslationRequests(java.lang.Object[] js, java.lang.Object[] is, java.util.function.Consumer consumer)
  void onCreateVirtualViewTranslationRequests(
    jni.JArray<jni.jlong> js,
    jni.JArray<jni.jint> is0,
    jni.JObject consumer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCreateVirtualViewTranslationRequests,
        jni.JniCallType.voidType,
        [js.reference, is0.reference, consumer.reference]).check();
  }

  static final _id_setViewTranslationCallback = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setViewTranslationCallback",
      r"(Landroid/view/translation/ViewTranslationCallback;)V");

  /// from: public void setViewTranslationCallback(android.view.translation.ViewTranslationCallback viewTranslationCallback)
  void setViewTranslationCallback(
    jni.JObject viewTranslationCallback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setViewTranslationCallback,
        jni.JniCallType.voidType,
        [viewTranslationCallback.reference]).check();
  }

  static final _id_clearViewTranslationCallback = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearViewTranslationCallback", r"()V");

  /// from: public void clearViewTranslationCallback()
  void clearViewTranslationCallback() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_clearViewTranslationCallback, jni.JniCallType.voidType, []).check();
  }

  static final _id_getViewTranslationResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getViewTranslationResponse",
      r"()Landroid/view/translation/ViewTranslationResponse;");

  /// from: public android.view.translation.ViewTranslationResponse getViewTranslationResponse()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getViewTranslationResponse() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getViewTranslationResponse,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onViewTranslationResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onViewTranslationResponse",
      r"(Landroid/view/translation/ViewTranslationResponse;)V");

  /// from: public void onViewTranslationResponse(android.view.translation.ViewTranslationResponse viewTranslationResponse)
  void onViewTranslationResponse(
    jni.JObject viewTranslationResponse,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onViewTranslationResponse,
        jni.JniCallType.voidType,
        [viewTranslationResponse.reference]).check();
  }

  static final _id_onVirtualViewTranslationResponses = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onVirtualViewTranslationResponses",
          r"(Landroid/util/LongSparseArray;)V");

  /// from: public void onVirtualViewTranslationResponses(android.util.LongSparseArray longSparseArray)
  void onVirtualViewTranslationResponses(
    jni.JObject longSparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onVirtualViewTranslationResponses,
        jni.JniCallType.voidType,
        [longSparseArray.reference]).check();
  }

  static final _id_dispatchCreateViewTranslationRequest = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchCreateViewTranslationRequest",
          r"(Ljava/util/Map;[ILandroid/view/translation/TranslationCapability;Ljava/util/List;)V");

  /// from: public void dispatchCreateViewTranslationRequest(java.util.Map map, java.lang.Object[] is, android.view.translation.TranslationCapability translationCapability, java.util.List list)
  void dispatchCreateViewTranslationRequest(
    jni.JMap<jni.JObject, jni.JArray<jni.jlong>> map,
    jni.JArray<jni.jint> is0,
    jni.JObject translationCapability,
    jni.JList<jni.JObject> list,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_dispatchCreateViewTranslationRequest, jni.JniCallType.voidType, [
      map.reference,
      is0.reference,
      translationCapability.reference,
      list.reference
    ]).check();
  }

  static final _id_generateDisplayHash = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"generateDisplayHash",
      r"(Ljava/lang/String;Landroid/graphics/Rect;Ljava/util/concurrent/Executor;Landroid/view/displayhash/DisplayHashResultCallback;)V");

  /// from: public void generateDisplayHash(java.lang.String string, android.graphics.Rect rect, java.util.concurrent.Executor executor, android.view.displayhash.DisplayHashResultCallback displayHashResultCallback)
  void generateDisplayHash(
    jni.JString string,
    jni.JObject rect,
    jni.JObject executor,
    jni.JObject displayHashResultCallback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_generateDisplayHash, jni.JniCallType.voidType, [
      string.reference,
      rect.reference,
      executor.reference,
      displayHashResultCallback.reference
    ]).check();
  }

  static final _id_getRootSurfaceControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getRootSurfaceControl",
      r"()Landroid/view/AttachedSurfaceControl;");

  /// from: public android.view.AttachedSurfaceControl getRootSurfaceControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRootSurfaceControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getRootSurfaceControl,
        jni.JniCallType.objectType, []).object);
  }
}

final class $ViewType extends jni.JObjType<View> {
  const $ViewType();

  @override
  String get signature => r"Landroid/view/View;";

  @override
  View fromRef(jni.JObjectPtr ref) => View.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ViewType) && other is $ViewType;
  }
}

/// from: android.webkit.WebView$FindListener
class WebView_FindListener extends jni.JObject {
  @override
  late final jni.JObjType<WebView_FindListener> $type = type;

  WebView_FindListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/webkit/WebView$FindListener");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_FindListenerType();
  static final _id_onFindResultReceived = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onFindResultReceived", r"(IIZ)V");

  /// from: public abstract void onFindResultReceived(int i, int i1, boolean z)
  void onFindResultReceived(
    int i,
    int i1,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onFindResultReceived,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1), z ? 1 : 0]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebView_FindListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFindResultReceived(IIZ)V") {
        _$impls[$p]!.onFindResultReceived(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory WebView_FindListener.implement(
    $WebView_FindListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebView_FindListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.webkit.WebView$FindListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $WebView_FindListenerImpl {
  factory $WebView_FindListenerImpl({
    required void Function(int i, int i1, bool z) onFindResultReceived,
  }) = _$WebView_FindListenerImpl;

  void onFindResultReceived(int i, int i1, bool z);
}

class _$WebView_FindListenerImpl implements $WebView_FindListenerImpl {
  _$WebView_FindListenerImpl({
    required void Function(int i, int i1, bool z) onFindResultReceived,
  }) : _onFindResultReceived = onFindResultReceived;

  final void Function(int i, int i1, bool z) _onFindResultReceived;

  void onFindResultReceived(int i, int i1, bool z) {
    return _onFindResultReceived(i, i1, z);
  }
}

final class $WebView_FindListenerType
    extends jni.JObjType<WebView_FindListener> {
  const $WebView_FindListenerType();

  @override
  String get signature => r"Landroid/webkit/WebView$FindListener;";

  @override
  WebView_FindListener fromRef(jni.JObjectPtr ref) =>
      WebView_FindListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_FindListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_FindListenerType) &&
        other is $WebView_FindListenerType;
  }
}

/// from: android.webkit.WebView$HitTestResult
class WebView_HitTestResult extends jni.JObject {
  @override
  late final jni.JObjType<WebView_HitTestResult> $type = type;

  WebView_HitTestResult.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/webkit/WebView$HitTestResult");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_HitTestResultType();

  /// from: static public final int ANCHOR_TYPE
  static const ANCHOR_TYPE = 1;

  /// from: static public final int EDIT_TEXT_TYPE
  static const EDIT_TEXT_TYPE = 9;

  /// from: static public final int EMAIL_TYPE
  static const EMAIL_TYPE = 4;

  /// from: static public final int GEO_TYPE
  static const GEO_TYPE = 3;

  /// from: static public final int IMAGE_ANCHOR_TYPE
  static const IMAGE_ANCHOR_TYPE = 6;

  /// from: static public final int IMAGE_TYPE
  static const IMAGE_TYPE = 5;

  /// from: static public final int PHONE_TYPE
  static const PHONE_TYPE = 2;

  /// from: static public final int SRC_ANCHOR_TYPE
  static const SRC_ANCHOR_TYPE = 7;

  /// from: static public final int SRC_IMAGE_ANCHOR_TYPE
  static const SRC_IMAGE_ANCHOR_TYPE = 8;

  /// from: static public final int UNKNOWN_TYPE
  static const UNKNOWN_TYPE = 0;

  static final _id_getType =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getType", r"()I");

  /// from: public int getType()
  int getType() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getType, jni.JniCallType.intType, []).integer;
  }

  static final _id_getExtra = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getExtra", r"()Ljava/lang/String;");

  /// from: public java.lang.String getExtra()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getExtra() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getExtra, jni.JniCallType.objectType, []).object);
  }
}

final class $WebView_HitTestResultType
    extends jni.JObjType<WebView_HitTestResult> {
  const $WebView_HitTestResultType();

  @override
  String get signature => r"Landroid/webkit/WebView$HitTestResult;";

  @override
  WebView_HitTestResult fromRef(jni.JObjectPtr ref) =>
      WebView_HitTestResult.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_HitTestResultType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_HitTestResultType) &&
        other is $WebView_HitTestResultType;
  }
}

/// from: android.webkit.WebView$PictureListener
class WebView_PictureListener extends jni.JObject {
  @override
  late final jni.JObjType<WebView_PictureListener> $type = type;

  WebView_PictureListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/webkit/WebView$PictureListener");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_PictureListenerType();
  static final _id_onNewPicture = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onNewPicture",
      r"(Landroid/webkit/WebView;Landroid/graphics/Picture;)V");

  /// from: public abstract void onNewPicture(android.webkit.WebView webView, android.graphics.Picture picture)
  void onNewPicture(
    WebView webView,
    jni.JObject picture,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onNewPicture,
        jni.JniCallType.voidType,
        [webView.reference, picture.reference]).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebView_PictureListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"onNewPicture(Landroid/webkit/WebView;Landroid/graphics/Picture;)V") {
        _$impls[$p]!.onNewPicture(
          $a[0].castTo(const $WebViewType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory WebView_PictureListener.implement(
    $WebView_PictureListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebView_PictureListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"android.webkit.WebView$PictureListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $WebView_PictureListenerImpl {
  factory $WebView_PictureListenerImpl({
    required void Function(WebView webView, jni.JObject picture) onNewPicture,
  }) = _$WebView_PictureListenerImpl;

  void onNewPicture(WebView webView, jni.JObject picture);
}

class _$WebView_PictureListenerImpl implements $WebView_PictureListenerImpl {
  _$WebView_PictureListenerImpl({
    required void Function(WebView webView, jni.JObject picture) onNewPicture,
  }) : _onNewPicture = onNewPicture;

  final void Function(WebView webView, jni.JObject picture) _onNewPicture;

  void onNewPicture(WebView webView, jni.JObject picture) {
    return _onNewPicture(webView, picture);
  }
}

final class $WebView_PictureListenerType
    extends jni.JObjType<WebView_PictureListener> {
  const $WebView_PictureListenerType();

  @override
  String get signature => r"Landroid/webkit/WebView$PictureListener;";

  @override
  WebView_PictureListener fromRef(jni.JObjectPtr ref) =>
      WebView_PictureListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_PictureListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_PictureListenerType) &&
        other is $WebView_PictureListenerType;
  }
}

/// from: android.webkit.WebView$VisualStateCallback
class WebView_VisualStateCallback extends jni.JObject {
  @override
  late final jni.JObjType<WebView_VisualStateCallback> $type = type;

  WebView_VisualStateCallback.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/webkit/WebView$VisualStateCallback");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_VisualStateCallbackType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView_VisualStateCallback() {
    return WebView_VisualStateCallback.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_onComplete =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onComplete", r"(J)V");

  /// from: public abstract void onComplete(long j)
  void onComplete(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onComplete, jni.JniCallType.voidType, [j]).check();
  }
}

final class $WebView_VisualStateCallbackType
    extends jni.JObjType<WebView_VisualStateCallback> {
  const $WebView_VisualStateCallbackType();

  @override
  String get signature => r"Landroid/webkit/WebView$VisualStateCallback;";

  @override
  WebView_VisualStateCallback fromRef(jni.JObjectPtr ref) =>
      WebView_VisualStateCallback.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_VisualStateCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_VisualStateCallbackType) &&
        other is $WebView_VisualStateCallbackType;
  }
}

/// from: android.webkit.WebView$WebViewTransport
class WebView_WebViewTransport extends jni.JObject {
  @override
  late final jni.JObjType<WebView_WebViewTransport> $type = type;

  WebView_WebViewTransport.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"android/webkit/WebView$WebViewTransport");

  /// The type which includes information such as the signature of this class.
  static const type = $WebView_WebViewTransportType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Landroid/webkit/WebView;)V");

  /// from: public void <init>(android.webkit.WebView webView)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView_WebViewTransport(
    WebView webView,
  ) {
    return WebView_WebViewTransport.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [webView.reference]).object);
  }

  static final _id_setWebView = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setWebView", r"(Landroid/webkit/WebView;)V");

  /// from: public void setWebView(android.webkit.WebView webView)
  void setWebView(
    WebView webView,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setWebView,
        jni.JniCallType.voidType, [webView.reference]).check();
  }

  static final _id_getWebView = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getWebView", r"()Landroid/webkit/WebView;");

  /// from: public android.webkit.WebView getWebView()
  /// The returned object must be released after use, by calling the [release] method.
  WebView getWebView() {
    return const $WebViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getWebView, jni.JniCallType.objectType, []).object);
  }
}

final class $WebView_WebViewTransportType
    extends jni.JObjType<WebView_WebViewTransport> {
  const $WebView_WebViewTransportType();

  @override
  String get signature => r"Landroid/webkit/WebView$WebViewTransport;";

  @override
  WebView_WebViewTransport fromRef(jni.JObjectPtr ref) =>
      WebView_WebViewTransport.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebView_WebViewTransportType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebView_WebViewTransportType) &&
        other is $WebView_WebViewTransportType;
  }
}

/// from: android.webkit.WebView
class WebView extends jni.JObject {
  @override
  late final jni.JObjType<WebView> $type = type;

  WebView.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"android/webkit/WebView");

  /// The type which includes information such as the signature of this class.
  static const type = $WebViewType();

  /// from: static public final int RENDERER_PRIORITY_BOUND
  static const RENDERER_PRIORITY_BOUND = 1;

  /// from: static public final int RENDERER_PRIORITY_IMPORTANT
  static const RENDERER_PRIORITY_IMPORTANT = 2;

  /// from: static public final int RENDERER_PRIORITY_WAIVED
  static const RENDERER_PRIORITY_WAIVED = 0;

  /// from: static public final java.lang.String SCHEME_GEO
  static const SCHEME_GEO = r"""geo:0,0?q=""";

  /// from: static public final java.lang.String SCHEME_MAILTO
  static const SCHEME_MAILTO = r"""mailto:""";

  /// from: static public final java.lang.String SCHEME_TEL
  static const SCHEME_TEL = r"""tel:""";

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView(
    jni.JObject context,
  ) {
    return WebView.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [context.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new1(
    jni.JObject context,
    jni.JObject attributeSet,
  ) {
    return WebView.fromRef(jni.Jni.accessors.newObjectWithArgs(_class.reference,
        _id_new1, [context.reference, attributeSet.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new2(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
  ) {
    return WebView.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new2,
        [context.reference, attributeSet.reference, jni.JValueInt(i)]).object);
  }

  static final _id_new3 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new3(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    int i1,
  ) {
    return WebView.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new3, [
      context.reference,
      attributeSet.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).object);
  }

  static final _id_new4 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Landroid/content/Context;Landroid/util/AttributeSet;IZ)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebView.new4(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    bool z,
  ) {
    return WebView.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new4, [
      context.reference,
      attributeSet.reference,
      jni.JValueInt(i),
      z ? 1 : 0
    ]).object);
  }

  static final _id_setHorizontalScrollbarOverlay = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"setHorizontalScrollbarOverlay", r"(Z)V");

  /// from: public void setHorizontalScrollbarOverlay(boolean z)
  void setHorizontalScrollbarOverlay(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setHorizontalScrollbarOverlay,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_setVerticalScrollbarOverlay = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setVerticalScrollbarOverlay", r"(Z)V");

  /// from: public void setVerticalScrollbarOverlay(boolean z)
  void setVerticalScrollbarOverlay(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setVerticalScrollbarOverlay,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_overlayHorizontalScrollbar = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"overlayHorizontalScrollbar", r"()Z");

  /// from: public boolean overlayHorizontalScrollbar()
  bool overlayHorizontalScrollbar() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_overlayHorizontalScrollbar,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_overlayVerticalScrollbar = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"overlayVerticalScrollbar", r"()Z");

  /// from: public boolean overlayVerticalScrollbar()
  bool overlayVerticalScrollbar() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_overlayVerticalScrollbar, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getCertificate = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getCertificate",
      r"()Landroid/net/http/SslCertificate;");

  /// from: public android.net.http.SslCertificate getCertificate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCertificate() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCertificate, jni.JniCallType.objectType, []).object);
  }

  static final _id_setCertificate = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setCertificate",
      r"(Landroid/net/http/SslCertificate;)V");

  /// from: public void setCertificate(android.net.http.SslCertificate sslCertificate)
  void setCertificate(
    jni.JObject sslCertificate,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setCertificate,
        jni.JniCallType.voidType, [sslCertificate.reference]).check();
  }

  static final _id_savePassword = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"savePassword",
      r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void savePassword(java.lang.String string, java.lang.String string1, java.lang.String string2)
  void savePassword(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_savePassword,
        jni.JniCallType.voidType,
        [string.reference, string1.reference, string2.reference]).check();
  }

  static final _id_setHttpAuthUsernamePassword = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setHttpAuthUsernamePassword",
      r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setHttpAuthUsernamePassword(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)
  void setHttpAuthUsernamePassword(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setHttpAuthUsernamePassword, jni.JniCallType.voidType, [
      string.reference,
      string1.reference,
      string2.reference,
      string3.reference
    ]).check();
  }

  static final _id_getHttpAuthUsernamePassword = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHttpAuthUsernamePassword",
          r"(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getHttpAuthUsernamePassword(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getHttpAuthUsernamePassword(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JArrayType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_getHttpAuthUsernamePassword,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_destroy =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"destroy", r"()V");

  /// from: public void destroy()
  void destroy() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_destroy, jni.JniCallType.voidType, []).check();
  }

  static final _id_setNetworkAvailable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setNetworkAvailable", r"(Z)V");

  /// from: public void setNetworkAvailable(boolean z)
  void setNetworkAvailable(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_setNetworkAvailable, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_saveState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"saveState",
      r"(Landroid/os/Bundle;)Landroid/webkit/WebBackForwardList;");

  /// from: public android.webkit.WebBackForwardList saveState(android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject saveState(
    jni.JObject bundle,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_saveState,
        jni.JniCallType.objectType,
        [bundle.reference]).object);
  }

  static final _id_restoreState = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"restoreState",
      r"(Landroid/os/Bundle;)Landroid/webkit/WebBackForwardList;");

  /// from: public android.webkit.WebBackForwardList restoreState(android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject restoreState(
    jni.JObject bundle,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_restoreState,
        jni.JniCallType.objectType,
        [bundle.reference]).object);
  }

  static final _id_loadUrl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"loadUrl", r"(Ljava/lang/String;Ljava/util/Map;)V");

  /// from: public void loadUrl(java.lang.String string, java.util.Map map)
  void loadUrl(
    jni.JString string,
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_loadUrl,
        jni.JniCallType.voidType, [string.reference, map.reference]).check();
  }

  static final _id_loadUrl1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"loadUrl", r"(Ljava/lang/String;)V");

  /// from: public void loadUrl(java.lang.String string)
  void loadUrl1(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_loadUrl1,
        jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_postUrl = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"postUrl", r"(Ljava/lang/String;[B)V");

  /// from: public void postUrl(java.lang.String string, byte[] bs)
  void postUrl(
    jni.JString string,
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_postUrl,
        jni.JniCallType.voidType, [string.reference, bs.reference]).check();
  }

  static final _id_loadData = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"loadData",
      r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void loadData(java.lang.String string, java.lang.String string1, java.lang.String string2)
  void loadData(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_loadData,
        jni.JniCallType.voidType,
        [string.reference, string1.reference, string2.reference]).check();
  }

  static final _id_loadDataWithBaseURL = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"loadDataWithBaseURL",
      r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void loadDataWithBaseURL(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4)
  void loadDataWithBaseURL(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_loadDataWithBaseURL, jni.JniCallType.voidType, [
      string.reference,
      string1.reference,
      string2.reference,
      string3.reference,
      string4.reference
    ]).check();
  }

  static final _id_evaluateJavascript = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"evaluateJavascript",
      r"(Ljava/lang/String;Landroid/webkit/ValueCallback;)V");

  /// from: public void evaluateJavascript(java.lang.String string, android.webkit.ValueCallback valueCallback)
  void evaluateJavascript(
    jni.JString string,
    jni.JObject valueCallback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_evaluateJavascript,
        jni.JniCallType.voidType,
        [string.reference, valueCallback.reference]).check();
  }

  static final _id_saveWebArchive = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"saveWebArchive", r"(Ljava/lang/String;)V");

  /// from: public void saveWebArchive(java.lang.String string)
  void saveWebArchive(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_saveWebArchive,
        jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_saveWebArchive1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"saveWebArchive",
      r"(Ljava/lang/String;ZLandroid/webkit/ValueCallback;)V");

  /// from: public void saveWebArchive(java.lang.String string, boolean z, android.webkit.ValueCallback valueCallback)
  void saveWebArchive1(
    jni.JString string,
    bool z,
    jni.JObject valueCallback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_saveWebArchive1,
        jni.JniCallType.voidType,
        [string.reference, z ? 1 : 0, valueCallback.reference]).check();
  }

  static final _id_stopLoading =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"stopLoading", r"()V");

  /// from: public void stopLoading()
  void stopLoading() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_stopLoading, jni.JniCallType.voidType, []).check();
  }

  static final _id_reload =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"reload", r"()V");

  /// from: public void reload()
  void reload() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_reload, jni.JniCallType.voidType, []).check();
  }

  static final _id_canGoBack =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"canGoBack", r"()Z");

  /// from: public boolean canGoBack()
  bool canGoBack() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canGoBack, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_goBack =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"goBack", r"()V");

  /// from: public void goBack()
  void goBack() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_goBack, jni.JniCallType.voidType, []).check();
  }

  static final _id_canGoForward = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canGoForward", r"()Z");

  /// from: public boolean canGoForward()
  bool canGoForward() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canGoForward, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_goForward =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"goForward", r"()V");

  /// from: public void goForward()
  void goForward() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_goForward, jni.JniCallType.voidType, []).check();
  }

  static final _id_canGoBackOrForward = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"canGoBackOrForward", r"(I)Z");

  /// from: public boolean canGoBackOrForward(int i)
  bool canGoBackOrForward(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canGoBackOrForward,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_goBackOrForward = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"goBackOrForward", r"(I)V");

  /// from: public void goBackOrForward(int i)
  void goBackOrForward(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_goBackOrForward,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_isPrivateBrowsingEnabled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isPrivateBrowsingEnabled", r"()Z");

  /// from: public boolean isPrivateBrowsingEnabled()
  bool isPrivateBrowsingEnabled() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isPrivateBrowsingEnabled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_pageUp =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"pageUp", r"(Z)Z");

  /// from: public boolean pageUp(boolean z)
  bool pageUp(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_pageUp,
        jni.JniCallType.booleanType, [z ? 1 : 0]).boolean;
  }

  static final _id_pageDown =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"pageDown", r"(Z)Z");

  /// from: public boolean pageDown(boolean z)
  bool pageDown(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_pageDown,
        jni.JniCallType.booleanType, [z ? 1 : 0]).boolean;
  }

  static final _id_postVisualStateCallback = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"postVisualStateCallback",
      r"(JLandroid/webkit/WebView$VisualStateCallback;)V");

  /// from: public void postVisualStateCallback(long j, android.webkit.WebView$VisualStateCallback visualStateCallback)
  void postVisualStateCallback(
    int j,
    WebView_VisualStateCallback visualStateCallback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_postVisualStateCallback,
        jni.JniCallType.voidType,
        [j, visualStateCallback.reference]).check();
  }

  static final _id_clearView =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"clearView", r"()V");

  /// from: public void clearView()
  void clearView() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearView, jni.JniCallType.voidType, []).check();
  }

  static final _id_capturePicture = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"capturePicture", r"()Landroid/graphics/Picture;");

  /// from: public android.graphics.Picture capturePicture()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject capturePicture() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_capturePicture, jni.JniCallType.objectType, []).object);
  }

  static final _id_createPrintDocumentAdapter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createPrintDocumentAdapter",
      r"()Landroid/print/PrintDocumentAdapter;");

  /// from: public android.print.PrintDocumentAdapter createPrintDocumentAdapter()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createPrintDocumentAdapter() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createPrintDocumentAdapter,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_createPrintDocumentAdapter1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createPrintDocumentAdapter",
          r"(Ljava/lang/String;)Landroid/print/PrintDocumentAdapter;");

  /// from: public android.print.PrintDocumentAdapter createPrintDocumentAdapter(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createPrintDocumentAdapter1(
    jni.JString string,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createPrintDocumentAdapter1,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_getScale =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getScale", r"()F");

  /// from: public float getScale()
  double getScale() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getScale, jni.JniCallType.floatType, []).float;
  }

  static final _id_setInitialScale = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setInitialScale", r"(I)V");

  /// from: public void setInitialScale(int i)
  void setInitialScale(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setInitialScale,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_invokeZoomPicker = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"invokeZoomPicker", r"()V");

  /// from: public void invokeZoomPicker()
  void invokeZoomPicker() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_invokeZoomPicker, jni.JniCallType.voidType, []).check();
  }

  static final _id_getHitTestResult = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getHitTestResult",
      r"()Landroid/webkit/WebView$HitTestResult;");

  /// from: public android.webkit.WebView$HitTestResult getHitTestResult()
  /// The returned object must be released after use, by calling the [release] method.
  WebView_HitTestResult getHitTestResult() {
    return const $WebView_HitTestResultType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getHitTestResult,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_requestFocusNodeHref = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"requestFocusNodeHref", r"(Landroid/os/Message;)V");

  /// from: public void requestFocusNodeHref(android.os.Message message)
  void requestFocusNodeHref(
    jni.JObject message,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestFocusNodeHref,
        jni.JniCallType.voidType,
        [message.reference]).check();
  }

  static final _id_requestImageRef = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"requestImageRef", r"(Landroid/os/Message;)V");

  /// from: public void requestImageRef(android.os.Message message)
  void requestImageRef(
    jni.JObject message,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_requestImageRef,
        jni.JniCallType.voidType, [message.reference]).check();
  }

  static final _id_getUrl = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getUrl", r"()Ljava/lang/String;");

  /// from: public java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getUrl, jni.JniCallType.objectType, []).object);
  }

  static final _id_getOriginalUrl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getOriginalUrl", r"()Ljava/lang/String;");

  /// from: public java.lang.String getOriginalUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOriginalUrl() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getOriginalUrl, jni.JniCallType.objectType, []).object);
  }

  static final _id_getTitle = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTitle", r"()Ljava/lang/String;");

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTitle, jni.JniCallType.objectType, []).object);
  }

  static final _id_getFavicon = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getFavicon", r"()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFavicon()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFavicon() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFavicon, jni.JniCallType.objectType, []).object);
  }

  static final _id_getProgress =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getProgress", r"()I");

  /// from: public int getProgress()
  int getProgress() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getProgress, jni.JniCallType.intType, []).integer;
  }

  static final _id_getContentHeight = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getContentHeight", r"()I");

  /// from: public int getContentHeight()
  int getContentHeight() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getContentHeight, jni.JniCallType.intType, []).integer;
  }

  static final _id_pauseTimers =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"pauseTimers", r"()V");

  /// from: public void pauseTimers()
  void pauseTimers() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_pauseTimers, jni.JniCallType.voidType, []).check();
  }

  static final _id_resumeTimers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"resumeTimers", r"()V");

  /// from: public void resumeTimers()
  void resumeTimers() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_resumeTimers, jni.JniCallType.voidType, []).check();
  }

  static final _id_onPause =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onPause", r"()V");

  /// from: public void onPause()
  void onPause() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onPause, jni.JniCallType.voidType, []).check();
  }

  static final _id_onResume =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onResume", r"()V");

  /// from: public void onResume()
  void onResume() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onResume, jni.JniCallType.voidType, []).check();
  }

  static final _id_freeMemory =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"freeMemory", r"()V");

  /// from: public void freeMemory()
  void freeMemory() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_freeMemory, jni.JniCallType.voidType, []).check();
  }

  static final _id_clearCache =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"clearCache", r"(Z)V");

  /// from: public void clearCache(boolean z)
  void clearCache(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_clearCache,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_clearFormData = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearFormData", r"()V");

  /// from: public void clearFormData()
  void clearFormData() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearFormData, jni.JniCallType.voidType, []).check();
  }

  static final _id_clearHistory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearHistory", r"()V");

  /// from: public void clearHistory()
  void clearHistory() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearHistory, jni.JniCallType.voidType, []).check();
  }

  static final _id_clearSslPreferences = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearSslPreferences", r"()V");

  /// from: public void clearSslPreferences()
  void clearSslPreferences() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_clearSslPreferences, jni.JniCallType.voidType, []).check();
  }

  static final _id_clearClientCertPreferences = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"clearClientCertPreferences",
          r"(Ljava/lang/Runnable;)V");

  /// from: static public void clearClientCertPreferences(java.lang.Runnable runnable)
  static void clearClientCertPreferences(
    jni.JObject runnable,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_clearClientCertPreferences,
        jni.JniCallType.voidType,
        [runnable.reference]).check();
  }

  static final _id_startSafeBrowsing = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"startSafeBrowsing",
      r"(Landroid/content/Context;Landroid/webkit/ValueCallback;)V");

  /// from: static public void startSafeBrowsing(android.content.Context context, android.webkit.ValueCallback valueCallback)
  static void startSafeBrowsing(
    jni.JObject context,
    jni.JObject valueCallback,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_startSafeBrowsing,
        jni.JniCallType.voidType,
        [context.reference, valueCallback.reference]).check();
  }

  static final _id_setSafeBrowsingWhitelist = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"setSafeBrowsingWhitelist",
          r"(Ljava/util/List;Landroid/webkit/ValueCallback;)V");

  /// from: static public void setSafeBrowsingWhitelist(java.util.List list, android.webkit.ValueCallback valueCallback)
  static void setSafeBrowsingWhitelist(
    jni.JList<jni.JString> list,
    jni.JObject valueCallback,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_setSafeBrowsingWhitelist,
        jni.JniCallType.voidType,
        [list.reference, valueCallback.reference]).check();
  }

  static final _id_getSafeBrowsingPrivacyPolicyUrl = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getSafeBrowsingPrivacyPolicyUrl",
          r"()Landroid/net/Uri;");

  /// from: static public android.net.Uri getSafeBrowsingPrivacyPolicyUrl()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getSafeBrowsingPrivacyPolicyUrl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_getSafeBrowsingPrivacyPolicyUrl,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_copyBackForwardList = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"copyBackForwardList",
      r"()Landroid/webkit/WebBackForwardList;");

  /// from: public android.webkit.WebBackForwardList copyBackForwardList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject copyBackForwardList() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_copyBackForwardList,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setFindListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setFindListener",
      r"(Landroid/webkit/WebView$FindListener;)V");

  /// from: public void setFindListener(android.webkit.WebView$FindListener findListener)
  void setFindListener(
    WebView_FindListener findListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setFindListener,
        jni.JniCallType.voidType, [findListener.reference]).check();
  }

  static final _id_findNext =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"findNext", r"(Z)V");

  /// from: public void findNext(boolean z)
  void findNext(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_findNext, jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_findAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"findAll", r"(Ljava/lang/String;)I");

  /// from: public int findAll(java.lang.String string)
  int findAll(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_findAll,
        jni.JniCallType.intType, [string.reference]).integer;
  }

  static final _id_findAllAsync = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"findAllAsync", r"(Ljava/lang/String;)V");

  /// from: public void findAllAsync(java.lang.String string)
  void findAllAsync(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_findAllAsync,
        jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_showFindDialog = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"showFindDialog", r"(Ljava/lang/String;Z)Z");

  /// from: public boolean showFindDialog(java.lang.String string, boolean z)
  bool showFindDialog(
    jni.JString string,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_showFindDialog,
        jni.JniCallType.booleanType, [string.reference, z ? 1 : 0]).boolean;
  }

  static final _id_findAddress = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"findAddress",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String findAddress(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString findAddress(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_findAddress,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_enableSlowWholeDocumentDraw = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference, r"enableSlowWholeDocumentDraw", r"()V");

  /// from: static public void enableSlowWholeDocumentDraw()
  static void enableSlowWholeDocumentDraw() {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_enableSlowWholeDocumentDraw, jni.JniCallType.voidType, []).check();
  }

  static final _id_clearMatches = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearMatches", r"()V");

  /// from: public void clearMatches()
  void clearMatches() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearMatches, jni.JniCallType.voidType, []).check();
  }

  static final _id_documentHasImages = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"documentHasImages", r"(Landroid/os/Message;)V");

  /// from: public void documentHasImages(android.os.Message message)
  void documentHasImages(
    jni.JObject message,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_documentHasImages,
        jni.JniCallType.voidType,
        [message.reference]).check();
  }

  static final _id_setWebViewClient = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setWebViewClient",
      r"(Landroid/webkit/WebViewClient;)V");

  /// from: public void setWebViewClient(android.webkit.WebViewClient webViewClient)
  void setWebViewClient(
    jni.JObject webViewClient,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setWebViewClient,
        jni.JniCallType.voidType, [webViewClient.reference]).check();
  }

  static final _id_getWebViewClient = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getWebViewClient",
      r"()Landroid/webkit/WebViewClient;");

  /// from: public android.webkit.WebViewClient getWebViewClient()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewClient() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWebViewClient,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getWebViewRenderProcess = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getWebViewRenderProcess",
      r"()Landroid/webkit/WebViewRenderProcess;");

  /// from: public android.webkit.WebViewRenderProcess getWebViewRenderProcess()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewRenderProcess() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWebViewRenderProcess,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setWebViewRenderProcessClient = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setWebViewRenderProcessClient",
      r"(Ljava/util/concurrent/Executor;Landroid/webkit/WebViewRenderProcessClient;)V");

  /// from: public void setWebViewRenderProcessClient(java.util.concurrent.Executor executor, android.webkit.WebViewRenderProcessClient webViewRenderProcessClient)
  void setWebViewRenderProcessClient(
    jni.JObject executor,
    jni.JObject webViewRenderProcessClient,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setWebViewRenderProcessClient,
        jni.JniCallType.voidType,
        [executor.reference, webViewRenderProcessClient.reference]).check();
  }

  static final _id_setWebViewRenderProcessClient1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setWebViewRenderProcessClient",
          r"(Landroid/webkit/WebViewRenderProcessClient;)V");

  /// from: public void setWebViewRenderProcessClient(android.webkit.WebViewRenderProcessClient webViewRenderProcessClient)
  void setWebViewRenderProcessClient1(
    jni.JObject webViewRenderProcessClient,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setWebViewRenderProcessClient1,
        jni.JniCallType.voidType,
        [webViewRenderProcessClient.reference]).check();
  }

  static final _id_getWebViewRenderProcessClient = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getWebViewRenderProcessClient",
          r"()Landroid/webkit/WebViewRenderProcessClient;");

  /// from: public android.webkit.WebViewRenderProcessClient getWebViewRenderProcessClient()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewRenderProcessClient() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWebViewRenderProcessClient,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setDownloadListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setDownloadListener",
      r"(Landroid/webkit/DownloadListener;)V");

  /// from: public void setDownloadListener(android.webkit.DownloadListener downloadListener)
  void setDownloadListener(
    jni.JObject downloadListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDownloadListener,
        jni.JniCallType.voidType,
        [downloadListener.reference]).check();
  }

  static final _id_setWebChromeClient = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setWebChromeClient",
      r"(Landroid/webkit/WebChromeClient;)V");

  /// from: public void setWebChromeClient(android.webkit.WebChromeClient webChromeClient)
  void setWebChromeClient(
    jni.JObject webChromeClient,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setWebChromeClient,
        jni.JniCallType.voidType,
        [webChromeClient.reference]).check();
  }

  static final _id_getWebChromeClient = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getWebChromeClient",
      r"()Landroid/webkit/WebChromeClient;");

  /// from: public android.webkit.WebChromeClient getWebChromeClient()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebChromeClient() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWebChromeClient,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_setPictureListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setPictureListener",
      r"(Landroid/webkit/WebView$PictureListener;)V");

  /// from: public void setPictureListener(android.webkit.WebView$PictureListener pictureListener)
  void setPictureListener(
    WebView_PictureListener pictureListener,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setPictureListener,
        jni.JniCallType.voidType,
        [pictureListener.reference]).check();
  }

  static final _id_addJavascriptInterface = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addJavascriptInterface",
      r"(Ljava/lang/Object;Ljava/lang/String;)V");

  /// from: public void addJavascriptInterface(java.lang.Object object, java.lang.String string)
  void addJavascriptInterface(
    jni.JObject object,
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addJavascriptInterface,
        jni.JniCallType.voidType,
        [object.reference, string.reference]).check();
  }

  static final _id_removeJavascriptInterface = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"removeJavascriptInterface", r"(Ljava/lang/String;)V");

  /// from: public void removeJavascriptInterface(java.lang.String string)
  void removeJavascriptInterface(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeJavascriptInterface,
        jni.JniCallType.voidType,
        [string.reference]).check();
  }

  static final _id_createWebMessageChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"createWebMessageChannel",
      r"()[Landroid/webkit/WebMessagePort;");

  /// from: public android.webkit.WebMessagePort[] createWebMessageChannel()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> createWebMessageChannel() {
    return const jni.JArrayType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_createWebMessageChannel,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_postWebMessage = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"postWebMessage",
      r"(Landroid/webkit/WebMessage;Landroid/net/Uri;)V");

  /// from: public void postWebMessage(android.webkit.WebMessage webMessage, android.net.Uri uri)
  void postWebMessage(
    jni.JObject webMessage,
    jni.JObject uri,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_postWebMessage,
        jni.JniCallType.voidType,
        [webMessage.reference, uri.reference]).check();
  }

  static final _id_getSettings = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getSettings", r"()Landroid/webkit/WebSettings;");

  /// from: public android.webkit.WebSettings getSettings()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSettings() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getSettings, jni.JniCallType.objectType, []).object);
  }

  static final _id_setWebContentsDebuggingEnabled = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference, r"setWebContentsDebuggingEnabled", r"(Z)V");

  /// from: static public void setWebContentsDebuggingEnabled(boolean z)
  static void setWebContentsDebuggingEnabled(
    bool z,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_setWebContentsDebuggingEnabled,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_setDataDirectorySuffix = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"setDataDirectorySuffix",
          r"(Ljava/lang/String;)V");

  /// from: static public void setDataDirectorySuffix(java.lang.String string)
  static void setDataDirectorySuffix(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_setDataDirectorySuffix,
        jni.JniCallType.voidType,
        [string.reference]).check();
  }

  static final _id_disableWebView = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"disableWebView", r"()V");

  /// from: static public void disableWebView()
  static void disableWebView() {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_disableWebView, jni.JniCallType.voidType, []).check();
  }

  static final _id_onChildViewAdded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onChildViewAdded",
      r"(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onChildViewAdded(android.view.View view, android.view.View view1)
  void onChildViewAdded(
    View view,
    View view1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onChildViewAdded,
        jni.JniCallType.voidType, [view.reference, view1.reference]).check();
  }

  static final _id_onChildViewRemoved = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onChildViewRemoved",
      r"(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onChildViewRemoved(android.view.View view, android.view.View view1)
  void onChildViewRemoved(
    View view,
    View view1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onChildViewRemoved,
        jni.JniCallType.voidType,
        [view.reference, view1.reference]).check();
  }

  static final _id_onGlobalFocusChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onGlobalFocusChanged",
      r"(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onGlobalFocusChanged(android.view.View view, android.view.View view1)
  void onGlobalFocusChanged(
    View view,
    View view1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onGlobalFocusChanged,
        jni.JniCallType.voidType,
        [view.reference, view1.reference]).check();
  }

  static final _id_setMapTrackballToArrowKeys = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setMapTrackballToArrowKeys", r"(Z)V");

  /// from: public void setMapTrackballToArrowKeys(boolean z)
  void setMapTrackballToArrowKeys(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setMapTrackballToArrowKeys,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_flingScroll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"flingScroll", r"(II)V");

  /// from: public void flingScroll(int i, int i1)
  void flingScroll(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_flingScroll,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_canZoomIn =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"canZoomIn", r"()Z");

  /// from: public boolean canZoomIn()
  bool canZoomIn() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canZoomIn, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_canZoomOut =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"canZoomOut", r"()Z");

  /// from: public boolean canZoomOut()
  bool canZoomOut() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canZoomOut, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_zoomBy =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"zoomBy", r"(F)V");

  /// from: public void zoomBy(float f)
  void zoomBy(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_zoomBy,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_zoomIn =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"zoomIn", r"()Z");

  /// from: public boolean zoomIn()
  bool zoomIn() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_zoomIn, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_zoomOut =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"zoomOut", r"()Z");

  /// from: public boolean zoomOut()
  bool zoomOut() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_zoomOut, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setRendererPriorityPolicy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setRendererPriorityPolicy", r"(IZ)V");

  /// from: public void setRendererPriorityPolicy(int i, boolean z)
  void setRendererPriorityPolicy(
    int i,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setRendererPriorityPolicy,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), z ? 1 : 0]).check();
  }

  static final _id_getRendererRequestedPriority = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRendererRequestedPriority", r"()I");

  /// from: public int getRendererRequestedPriority()
  int getRendererRequestedPriority() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getRendererRequestedPriority, jni.JniCallType.intType, []).integer;
  }

  static final _id_getRendererPriorityWaivedWhenNotVisible = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"getRendererPriorityWaivedWhenNotVisible", r"()Z");

  /// from: public boolean getRendererPriorityWaivedWhenNotVisible()
  bool getRendererPriorityWaivedWhenNotVisible() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getRendererPriorityWaivedWhenNotVisible,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setTextClassifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setTextClassifier",
      r"(Landroid/view/textclassifier/TextClassifier;)V");

  /// from: public void setTextClassifier(android.view.textclassifier.TextClassifier textClassifier)
  void setTextClassifier(
    jni.JObject textClassifier,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setTextClassifier,
        jni.JniCallType.voidType,
        [textClassifier.reference]).check();
  }

  static final _id_getTextClassifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getTextClassifier",
      r"()Landroid/view/textclassifier/TextClassifier;");

  /// from: public android.view.textclassifier.TextClassifier getTextClassifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTextClassifier() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getTextClassifier,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getWebViewClassLoader = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getWebViewClassLoader",
          r"()Ljava/lang/ClassLoader;");

  /// from: static public java.lang.ClassLoader getWebViewClassLoader()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getWebViewClassLoader() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getWebViewClassLoader,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getWebViewLooper = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getWebViewLooper", r"()Landroid/os/Looper;");

  /// from: public android.os.Looper getWebViewLooper()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWebViewLooper() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getWebViewLooper,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onAttachedToWindow = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onAttachedToWindow", r"()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onAttachedToWindow, jni.JniCallType.voidType, []).check();
  }

  static final _id_setLayoutParams = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setLayoutParams",
      r"(Landroid/view/ViewGroup$LayoutParams;)V");

  /// from: public void setLayoutParams(android.view.ViewGroup$LayoutParams layoutParams)
  void setLayoutParams(
    jni.JObject layoutParams,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLayoutParams,
        jni.JniCallType.voidType, [layoutParams.reference]).check();
  }

  static final _id_setOverScrollMode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setOverScrollMode", r"(I)V");

  /// from: public void setOverScrollMode(int i)
  void setOverScrollMode(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setOverScrollMode,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setScrollBarStyle = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setScrollBarStyle", r"(I)V");

  /// from: public void setScrollBarStyle(int i)
  void setScrollBarStyle(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setScrollBarStyle,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_computeHorizontalScrollRange = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeHorizontalScrollRange", r"()I");

  /// from: protected int computeHorizontalScrollRange()
  int computeHorizontalScrollRange() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeHorizontalScrollRange, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeHorizontalScrollOffset = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"computeHorizontalScrollOffset", r"()I");

  /// from: protected int computeHorizontalScrollOffset()
  int computeHorizontalScrollOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeHorizontalScrollOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeVerticalScrollRange = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeVerticalScrollRange", r"()I");

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeVerticalScrollRange, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeVerticalScrollOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeVerticalScrollOffset", r"()I");

  /// from: protected int computeVerticalScrollOffset()
  int computeVerticalScrollOffset() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeVerticalScrollOffset, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeVerticalScrollExtent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeVerticalScrollExtent", r"()I");

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_computeVerticalScrollExtent, jni.JniCallType.intType, []).integer;
  }

  static final _id_computeScroll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"computeScroll", r"()V");

  /// from: public void computeScroll()
  void computeScroll() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_computeScroll, jni.JniCallType.voidType, []).check();
  }

  static final _id_onHoverEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onHoverEvent", r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onHoverEvent(android.view.MotionEvent motionEvent)
  bool onHoverEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onHoverEvent,
        jni.JniCallType.booleanType, [motionEvent.reference]).boolean;
  }

  static final _id_onTouchEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onTouchEvent", r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent motionEvent)
  bool onTouchEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onTouchEvent,
        jni.JniCallType.booleanType, [motionEvent.reference]).boolean;
  }

  static final _id_onGenericMotionEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onGenericMotionEvent",
      r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool onGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onGenericMotionEvent,
        jni.JniCallType.booleanType,
        [motionEvent.reference]).boolean;
  }

  static final _id_onTrackballEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onTrackballEvent", r"(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent motionEvent)
  bool onTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onTrackballEvent,
        jni.JniCallType.booleanType, [motionEvent.reference]).boolean;
  }

  static final _id_onKeyDown = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyDown", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int i, android.view.KeyEvent keyEvent)
  bool onKeyDown(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyDown,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onKeyUp = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyUp", r"(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int i, android.view.KeyEvent keyEvent)
  bool onKeyUp(
    int i,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyUp,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), keyEvent.reference]).boolean;
  }

  static final _id_onKeyMultiple = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onKeyMultiple", r"(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int i, int i1, android.view.KeyEvent keyEvent)
  bool onKeyMultiple(
    int i,
    int i1,
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onKeyMultiple,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), jni.JValueInt(i1), keyEvent.reference]).boolean;
  }

  static final _id_getAccessibilityNodeProvider = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getAccessibilityNodeProvider",
          r"()Landroid/view/accessibility/AccessibilityNodeProvider;");

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityNodeProvider() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityNodeProvider,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_shouldDelayChildPressedState = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"shouldDelayChildPressedState", r"()Z");

  /// from: public boolean shouldDelayChildPressedState()
  bool shouldDelayChildPressedState() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_shouldDelayChildPressedState,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getAccessibilityClassName = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getAccessibilityClassName",
      r"()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAccessibilityClassName() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getAccessibilityClassName,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_onProvideVirtualStructure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onProvideVirtualStructure",
      r"(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideVirtualStructure(android.view.ViewStructure viewStructure)
  void onProvideVirtualStructure(
    jni.JObject viewStructure,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideVirtualStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference]).check();
  }

  static final _id_onProvideAutofillVirtualStructure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onProvideAutofillVirtualStructure",
          r"(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillVirtualStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideAutofillVirtualStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideAutofillVirtualStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference, jni.JValueInt(i)]).check();
  }

  static final _id_onProvideContentCaptureStructure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onProvideContentCaptureStructure",
          r"(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideContentCaptureStructure(android.view.ViewStructure viewStructure, int i)
  void onProvideContentCaptureStructure(
    jni.JObject viewStructure,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onProvideContentCaptureStructure,
        jni.JniCallType.voidType,
        [viewStructure.reference, jni.JValueInt(i)]).check();
  }

  static final _id_autofill = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"autofill", r"(Landroid/util/SparseArray;)V");

  /// from: public void autofill(android.util.SparseArray sparseArray)
  void autofill(
    jni.JObject sparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_autofill,
        jni.JniCallType.voidType, [sparseArray.reference]).check();
  }

  static final _id_isVisibleToUserForAutofill = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isVisibleToUserForAutofill", r"(I)Z");

  /// from: public boolean isVisibleToUserForAutofill(int i)
  bool isVisibleToUserForAutofill(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_isVisibleToUserForAutofill,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_onCreateVirtualViewTranslationRequests = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference,
          r"onCreateVirtualViewTranslationRequests",
          r"([J[ILjava/util/function/Consumer;)V");

  /// from: public void onCreateVirtualViewTranslationRequests(java.lang.Object[] js, java.lang.Object[] is, java.util.function.Consumer consumer)
  void onCreateVirtualViewTranslationRequests(
    jni.JArray<jni.jlong> js,
    jni.JArray<jni.jint> is0,
    jni.JObject consumer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCreateVirtualViewTranslationRequests,
        jni.JniCallType.voidType,
        [js.reference, is0.reference, consumer.reference]).check();
  }

  static final _id_dispatchCreateViewTranslationRequest = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dispatchCreateViewTranslationRequest",
          r"(Ljava/util/Map;[ILandroid/view/translation/TranslationCapability;Ljava/util/List;)V");

  /// from: public void dispatchCreateViewTranslationRequest(java.util.Map map, java.lang.Object[] is, android.view.translation.TranslationCapability translationCapability, java.util.List list)
  void dispatchCreateViewTranslationRequest(
    jni.JMap<jni.JObject, jni.JArray<jni.jlong>> map,
    jni.JArray<jni.jint> is0,
    jni.JObject translationCapability,
    jni.JList<jni.JObject> list,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_dispatchCreateViewTranslationRequest, jni.JniCallType.voidType, [
      map.reference,
      is0.reference,
      translationCapability.reference,
      list.reference
    ]).check();
  }

  static final _id_onVirtualViewTranslationResponses = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onVirtualViewTranslationResponses",
          r"(Landroid/util/LongSparseArray;)V");

  /// from: public void onVirtualViewTranslationResponses(android.util.LongSparseArray longSparseArray)
  void onVirtualViewTranslationResponses(
    jni.JObject longSparseArray,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onVirtualViewTranslationResponses,
        jni.JniCallType.voidType,
        [longSparseArray.reference]).check();
  }

  static final _id_onOverScrolled = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onOverScrolled", r"(IIZZ)V");

  /// from: protected void onOverScrolled(int i, int i1, boolean z, boolean z1)
  void onOverScrolled(
    int i,
    int i1,
    bool z,
    bool z1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onOverScrolled,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1), z ? 1 : 0, z1 ? 1 : 0]).check();
  }

  static final _id_onWindowVisibilityChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onWindowVisibilityChanged", r"(I)V");

  /// from: protected void onWindowVisibilityChanged(int i)
  void onWindowVisibilityChanged(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onWindowVisibilityChanged,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_onDraw = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDraw", r"(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDraw,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_performLongClick = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"performLongClick", r"()Z");

  /// from: public boolean performLongClick()
  bool performLongClick() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_performLongClick,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_onConfigurationChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onConfigurationChanged",
      r"(Landroid/content/res/Configuration;)V");

  /// from: protected void onConfigurationChanged(android.content.res.Configuration configuration)
  void onConfigurationChanged(
    jni.JObject configuration,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onConfigurationChanged,
        jni.JniCallType.voidType,
        [configuration.reference]).check();
  }

  static final _id_onCreateInputConnection = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onCreateInputConnection",
      r"(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo editorInfo)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateInputConnection(
    jni.JObject editorInfo,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCreateInputConnection,
        jni.JniCallType.objectType,
        [editorInfo.reference]).object);
  }

  static final _id_onDragEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onDragEvent", r"(Landroid/view/DragEvent;)Z");

  /// from: public boolean onDragEvent(android.view.DragEvent dragEvent)
  bool onDragEvent(
    jni.JObject dragEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_onDragEvent,
        jni.JniCallType.booleanType, [dragEvent.reference]).boolean;
  }

  static final _id_onVisibilityChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onVisibilityChanged", r"(Landroid/view/View;I)V");

  /// from: protected void onVisibilityChanged(android.view.View view, int i)
  void onVisibilityChanged(
    View view,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onVisibilityChanged,
        jni.JniCallType.voidType,
        [view.reference, jni.JValueInt(i)]).check();
  }

  static final _id_onWindowFocusChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onWindowFocusChanged", r"(Z)V");

  /// from: public void onWindowFocusChanged(boolean z)
  void onWindowFocusChanged(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onWindowFocusChanged,
        jni.JniCallType.voidType,
        [z ? 1 : 0]).check();
  }

  static final _id_onFocusChanged = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"onFocusChanged", r"(ZILandroid/graphics/Rect;)V");

  /// from: protected void onFocusChanged(boolean z, int i, android.graphics.Rect rect)
  void onFocusChanged(
    bool z,
    int i,
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onFocusChanged,
        jni.JniCallType.voidType,
        [z ? 1 : 0, jni.JValueInt(i), rect.reference]).check();
  }

  static final _id_onSizeChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onSizeChanged", r"(IIII)V");

  /// from: protected void onSizeChanged(int i, int i1, int i2, int i3)
  void onSizeChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onSizeChanged, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_onScrollChanged = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onScrollChanged", r"(IIII)V");

  /// from: protected void onScrollChanged(int i, int i1, int i2, int i3)
  void onScrollChanged(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onScrollChanged, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      jni.JValueInt(i1),
      jni.JValueInt(i2),
      jni.JValueInt(i3)
    ]).check();
  }

  static final _id_dispatchKeyEvent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchKeyEvent", r"(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyEvent(
    jni.JObject keyEvent,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
        jni.JniCallType.booleanType, [keyEvent.reference]).boolean;
  }

  static final _id_requestFocus = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"requestFocus", r"(ILandroid/graphics/Rect;)Z");

  /// from: public boolean requestFocus(int i, android.graphics.Rect rect)
  bool requestFocus(
    int i,
    jni.JObject rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestFocus,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i), rect.reference]).boolean;
  }

  static final _id_onMeasure =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"onMeasure", r"(II)V");

  /// from: protected void onMeasure(int i, int i1)
  void onMeasure(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onMeasure,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_requestChildRectangleOnScreen = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"requestChildRectangleOnScreen",
          r"(Landroid/view/View;Landroid/graphics/Rect;Z)Z");

  /// from: public boolean requestChildRectangleOnScreen(android.view.View view, android.graphics.Rect rect, boolean z)
  bool requestChildRectangleOnScreen(
    View view,
    jni.JObject rect,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_requestChildRectangleOnScreen,
        jni.JniCallType.booleanType,
        [view.reference, rect.reference, z ? 1 : 0]).boolean;
  }

  static final _id_setBackgroundColor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setBackgroundColor", r"(I)V");

  /// from: public void setBackgroundColor(int i)
  void setBackgroundColor(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setBackgroundColor,
        jni.JniCallType.voidType,
        [jni.JValueInt(i)]).check();
  }

  static final _id_setLayerType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"setLayerType", r"(ILandroid/graphics/Paint;)V");

  /// from: public void setLayerType(int i, android.graphics.Paint paint)
  void setLayerType(
    int i,
    jni.JObject paint,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLayerType,
        jni.JniCallType.voidType, [jni.JValueInt(i), paint.reference]).check();
  }

  static final _id_dispatchDraw = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatchDraw", r"(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(
    jni.JObject canvas,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_dispatchDraw,
        jni.JniCallType.voidType, [canvas.reference]).check();
  }

  static final _id_onStartTemporaryDetach = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onStartTemporaryDetach", r"()V");

  /// from: public void onStartTemporaryDetach()
  void onStartTemporaryDetach() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onStartTemporaryDetach, jni.JniCallType.voidType, []).check();
  }

  static final _id_onFinishTemporaryDetach = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onFinishTemporaryDetach", r"()V");

  /// from: public void onFinishTemporaryDetach()
  void onFinishTemporaryDetach() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onFinishTemporaryDetach, jni.JniCallType.voidType, []).check();
  }

  static final _id_getHandler = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getHandler", r"()Landroid/os/Handler;");

  /// from: public android.os.Handler getHandler()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHandler() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHandler, jni.JniCallType.objectType, []).object);
  }

  static final _id_findFocus = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"findFocus", r"()Landroid/view/View;");

  /// from: public android.view.View findFocus()
  /// The returned object must be released after use, by calling the [release] method.
  View findFocus() {
    return const $ViewType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_findFocus, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCurrentWebViewPackage = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getCurrentWebViewPackage",
          r"()Landroid/content/pm/PackageInfo;");

  /// from: static public android.content.pm.PackageInfo getCurrentWebViewPackage()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getCurrentWebViewPackage() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_getCurrentWebViewPackage,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_onCheckIsTextEditor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"onCheckIsTextEditor", r"()Z");

  /// from: public boolean onCheckIsTextEditor()
  bool onCheckIsTextEditor() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_onCheckIsTextEditor, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_onApplyWindowInsets = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onApplyWindowInsets",
      r"(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets onApplyWindowInsets(android.view.WindowInsets windowInsets)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onApplyWindowInsets(
    jni.JObject windowInsets,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onApplyWindowInsets,
        jni.JniCallType.objectType,
        [windowInsets.reference]).object);
  }
}

final class $WebViewType extends jni.JObjType<WebView> {
  const $WebViewType();

  @override
  String get signature => r"Landroid/webkit/WebView;";

  @override
  WebView fromRef(jni.JObjectPtr ref) => WebView.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebViewType) && other is $WebViewType;
  }
}
